
(function(l, r) { if (!l || l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (self.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(self.document);
var app = (function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    let src_url_equal_anchor;
    function src_url_equal(element_src, url) {
        if (!src_url_equal_anchor) {
            src_url_equal_anchor = document.createElement('a');
        }
        src_url_equal_anchor.href = url;
        return element_src === src_url_equal_anchor.href;
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function set_store_value(store, ret, value) {
        store.set(value);
        return ret;
    }
    function split_css_unit(value) {
        const split = typeof value === 'string' && value.match(/^\s*(-?[\d.]+)([^\s]*)\s*$/);
        return split ? [parseFloat(split[1]), split[2] || 'px'] : [value, 'px'];
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);
    function append(target, node) {
        target.appendChild(node);
    }
    function get_root_for_style(node) {
        if (!node)
            return document;
        const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
        if (root && root.host) {
            return root;
        }
        return node.ownerDocument;
    }
    function append_empty_stylesheet(node) {
        const style_element = element('style');
        append_stylesheet(get_root_for_style(node), style_element);
        return style_element.sheet;
    }
    function append_stylesheet(node, style) {
        append(node.head || node, style);
        return style.sheet;
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        if (node.parentNode) {
            node.parentNode.removeChild(node);
        }
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        if (value == null) {
            node.style.removeProperty(key);
        }
        else {
            node.style.setProperty(key, value, important ? 'important' : '');
        }
    }
    function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, bubbles, cancelable, detail);
        return e;
    }

    // we need to store the information for multiple documents because a Svelte application could also contain iframes
    // https://github.com/sveltejs/svelte/issues/3624
    const managed_styles = new Map();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_style_information(doc, node) {
        const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
        managed_styles.set(doc, info);
        return info;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = get_root_for_style(node);
        const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
        if (!rules[name]) {
            rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ''}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            managed_styles.forEach(info => {
                const { ownerNode } = info.stylesheet;
                // there is no ownerNode if it runs on jsdom.
                if (ownerNode)
                    detach(ownerNode);
            });
            managed_styles.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error('Function called outside component initialization');
        return current_component;
    }
    /**
     * The `onMount` function schedules a callback to run as soon as the component has been mounted to the DOM.
     * It must be called during the component's initialisation (but doesn't need to live *inside* the component;
     * it can be called from an external module).
     *
     * `onMount` does not run inside a [server-side component](/docs#run-time-server-side-component-api).
     *
     * https://svelte.dev/docs#run-time-svelte-onmount
     */
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    /**
     * Schedules a callback to run immediately after the component has been updated.
     *
     * The first time the callback runs will be after the initial `onMount`
     */
    function afterUpdate(fn) {
        get_current_component().$$.after_update.push(fn);
    }
    /**
     * Schedules a callback to run immediately before the component is unmounted.
     *
     * Out of `onMount`, `beforeUpdate`, `afterUpdate` and `onDestroy`, this is the
     * only one that runs inside a server-side component.
     *
     * https://svelte.dev/docs#run-time-svelte-ondestroy
     */
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    /**
     * Creates an event dispatcher that can be used to dispatch [component events](/docs#template-syntax-component-directives-on-eventname).
     * Event dispatchers are functions that can take two arguments: `name` and `detail`.
     *
     * Component events created with `createEventDispatcher` create a
     * [CustomEvent](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent).
     * These events do not [bubble](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Building_blocks/Events#Event_bubbling_and_capture).
     * The `detail` argument corresponds to the [CustomEvent.detail](https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent/detail)
     * property and can contain any type of data.
     *
     * https://svelte.dev/docs#run-time-svelte-createeventdispatcher
     */
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail, { cancelable = false } = {}) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail, { cancelable });
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
                return !event.defaultPrevented;
            }
            return true;
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            // @ts-ignore
            callbacks.slice().forEach(fn => fn.call(this, event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    let render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = /* @__PURE__ */ Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    // flush() calls callbacks in this order:
    // 1. All beforeUpdate callbacks, in order: parents before children
    // 2. All bind:this callbacks, in reverse order: children before parents.
    // 3. All afterUpdate callbacks, in order: parents before children. EXCEPT
    //    for afterUpdates called during the initial onMount, which are called in
    //    reverse order: children before parents.
    // Since callbacks might update component values, which could trigger another
    // call to flush(), the following steps guard against this:
    // 1. During beforeUpdate, any updated components will be added to the
    //    dirty_components array and will cause a reentrant call to flush(). Because
    //    the flush index is kept outside the function, the reentrant call will pick
    //    up where the earlier call left off and go through all dirty components. The
    //    current_component value is saved and restored so that the reentrant call will
    //    not interfere with the "parent" flush() call.
    // 2. bind:this callbacks cannot trigger new flush() calls.
    // 3. During afterUpdate, any updated components will NOT have their afterUpdate
    //    callback called a second time; the seen_callbacks set, outside the flush()
    //    function, guarantees this behavior.
    const seen_callbacks = new Set();
    let flushidx = 0; // Do *not* move this inside the flush() function
    function flush() {
        // Do not reenter flush while dirty components are updated, as this can
        // result in an infinite loop. Instead, let the inner flush handle it.
        // Reentrancy is ok afterwards for bindings etc.
        if (flushidx !== 0) {
            return;
        }
        const saved_component = current_component;
        do {
            // first, call beforeUpdate functions
            // and update components
            try {
                while (flushidx < dirty_components.length) {
                    const component = dirty_components[flushidx];
                    flushidx++;
                    set_current_component(component);
                    update(component.$$);
                }
            }
            catch (e) {
                // reset dirty state to not end up in a deadlocked state and then rethrow
                dirty_components.length = 0;
                flushidx = 0;
                throw e;
            }
            set_current_component(null);
            dirty_components.length = 0;
            flushidx = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        seen_callbacks.clear();
        set_current_component(saved_component);
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }
    /**
     * Useful for example to execute remaining `afterUpdate` callbacks before executing `destroy`.
     */
    function flush_render_callbacks(fns) {
        const filtered = [];
        const targets = [];
        render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
        targets.forEach((c) => c());
        render_callbacks = filtered;
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
        else if (callback) {
            callback();
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        const options = { direction: 'in' };
        let config = fn(node, params, options);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                started = true;
                delete_rule(node);
                if (is_function(config)) {
                    config = config(options);
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        const options = { direction: 'out' };
        let config = fn(node, params, options);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config(options);
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        const options = { direction: 'both' };
        let config = fn(node, params, options);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = (program.b - t);
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config(options);
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }
    function get_spread_object(spread_props) {
        return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor, customElement) {
        const { fragment, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        if (!customElement) {
            // onMount happens before the initial afterUpdate
            add_render_callback(() => {
                const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
                // if the component was destroyed immediately
                // it will update the `$$.on_destroy` reference to `null`.
                // the destructured on_destroy may still reference to the old array
                if (component.$$.on_destroy) {
                    component.$$.on_destroy.push(...new_on_destroy);
                }
                else {
                    // Edge case - component was destroyed immediately,
                    // most likely as a result of a binding initialising
                    run_all(new_on_destroy);
                }
                component.$$.on_mount = [];
            });
        }
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            flush_render_callbacks($$.after_update);
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const $$ = component.$$ = {
            fragment: null,
            ctx: [],
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            on_disconnect: [],
            before_update: [],
            after_update: [],
            context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false,
            root: options.target || parent_component.$$.root
        };
        append_styles && append_styles($$.root);
        let ready = false;
        $$.ctx = instance
            ? instance(component, options.props || {}, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor, options.customElement);
            flush();
        }
        set_current_component(parent_component);
    }
    /**
     * Base class for Svelte components. Used when dev=false.
     */
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            if (!is_function(callback)) {
                return noop;
            }
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.59.2' }, detail), { bubbles: true }));
    }
    function append_dev(target, node) {
        dispatch_dev('SvelteDOMInsert', { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev('SvelteDOMInsert', { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev('SvelteDOMRemove', { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation, has_stop_immediate_propagation) {
        const modifiers = options === true ? ['capture'] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        if (has_stop_immediate_propagation)
            modifiers.push('stopImmediatePropagation');
        dispatch_dev('SvelteDOMAddEventListener', { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev('SvelteDOMRemoveEventListener', { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev('SvelteDOMRemoveAttribute', { node, attribute });
        else
            dispatch_dev('SvelteDOMSetAttribute', { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.data === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function set_data_contenteditable_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev('SvelteDOMSetData', { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    function construct_svelte_component_dev(component, props) {
        const error_message = 'this={...} of <svelte:component> should specify a Svelte component.';
        try {
            const instance = new component(props);
            if (!instance.$$ || !instance.$set || !instance.$on || !instance.$destroy) {
                throw new Error(error_message);
            }
            return instance;
        }
        catch (err) {
            const { message } = err;
            if (typeof message === 'string' && message.indexOf('is not a constructor') !== -1) {
                throw new Error(error_message);
            }
            else {
                throw err;
            }
        }
    }
    /**
     * Base class for Svelte components with some minor dev-enhancements. Used when dev=true.
     */
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error("'target' is a required option");
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn('Component was already destroyed'); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    const subscriber_queue = [];
    /**
     * Creates a `Readable` store that allows reading by subscription.
     * @param value initial value
     * @param {StartStopNotifier} [start]
     */
    function readable(value, start) {
        return {
            subscribe: writable(value, start).subscribe
        };
    }
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=} start
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = new Set();
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (const subscriber of subscribers) {
                        subscriber[1]();
                        subscriber_queue.push(subscriber, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.add(subscriber);
            if (subscribers.size === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                subscribers.delete(subscriber);
                if (subscribers.size === 0 && stop) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }
    function derived(stores, fn, initial_value) {
        const single = !Array.isArray(stores);
        const stores_array = single
            ? [stores]
            : stores;
        const auto = fn.length < 2;
        return readable(initial_value, (set) => {
            let started = false;
            const values = [];
            let pending = 0;
            let cleanup = noop;
            const sync = () => {
                if (pending) {
                    return;
                }
                cleanup();
                const result = fn(single ? values[0] : values, set);
                if (auto) {
                    set(result);
                }
                else {
                    cleanup = is_function(result) ? result : noop;
                }
            };
            const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
                values[i] = value;
                pending &= ~(1 << i);
                if (started) {
                    sync();
                }
            }, () => {
                pending |= (1 << i);
            }));
            started = true;
            sync();
            return function stop() {
                run_all(unsubscribers);
                cleanup();
                // We need to set this to false because callbacks can still happen despite having unsubscribed:
                // Callbacks might already be placed in the queue which doesn't know it should no longer
                // invoke this derived store.
                started = false;
            };
        });
    }

    function parse(str, loose) {
    	if (str instanceof RegExp) return { keys:false, pattern:str };
    	var c, o, tmp, ext, keys=[], pattern='', arr = str.split('/');
    	arr[0] || arr.shift();

    	while (tmp = arr.shift()) {
    		c = tmp[0];
    		if (c === '*') {
    			keys.push('wild');
    			pattern += '/(.*)';
    		} else if (c === ':') {
    			o = tmp.indexOf('?', 1);
    			ext = tmp.indexOf('.', 1);
    			keys.push( tmp.substring(1, !!~o ? o : !!~ext ? ext : tmp.length) );
    			pattern += !!~o && !~ext ? '(?:/([^/]+?))?' : '/([^/]+?)';
    			if (!!~ext) pattern += (!!~o ? '?' : '') + '\\' + tmp.substring(ext);
    		} else {
    			pattern += '/' + tmp;
    		}
    	}

    	return {
    		keys: keys,
    		pattern: new RegExp('^' + pattern + (loose ? '(?=$|\/)' : '\/?$'), 'i')
    	};
    }

    /* node_modules\svelte-spa-router\Router.svelte generated by Svelte v3.59.2 */

    const { Error: Error_1, Object: Object_1, console: console_1$G } = globals;

    // (246:0) {:else}
    function create_else_block$9(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [/*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*props*/ 4)
    			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*props*/ ctx[2])])
    			: {};

    			if (dirty & /*component*/ 1 && switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler_1*/ ctx[7]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(246:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (239:0) {#if componentParams}
    function create_if_block$H(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	const switch_instance_spread_levels = [{ params: /*componentParams*/ ctx[1] }, /*props*/ ctx[2]];
    	var switch_value = /*component*/ ctx[0];

    	function switch_props(ctx) {
    		let switch_instance_props = {};

    		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
    			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
    		}

    		return {
    			props: switch_instance_props,
    			$$inline: true
    		};
    	}

    	if (switch_value) {
    		switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    		switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) mount_component(switch_instance, target, anchor);
    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const switch_instance_changes = (dirty & /*componentParams, props*/ 6)
    			? get_spread_update(switch_instance_spread_levels, [
    					dirty & /*componentParams*/ 2 && { params: /*componentParams*/ ctx[1] },
    					dirty & /*props*/ 4 && get_spread_object(/*props*/ ctx[2])
    				])
    			: {};

    			if (dirty & /*component*/ 1 && switch_value !== (switch_value = /*component*/ ctx[0])) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = construct_svelte_component_dev(switch_value, switch_props());
    					switch_instance.$on("routeEvent", /*routeEvent_handler*/ ctx[6]);
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			} else if (switch_value) {
    				switch_instance.$set(switch_instance_changes);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$H.name,
    		type: "if",
    		source: "(239:0) {#if componentParams}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1V(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$H, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*componentParams*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error_1("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function getLocation() {
    	const hashPosition = window.location.href.indexOf('#/');

    	let location = hashPosition > -1
    	? window.location.href.substr(hashPosition + 1)
    	: '/';

    	// Check if there's a querystring
    	const qsPosition = location.indexOf('?');

    	let querystring = '';

    	if (qsPosition > -1) {
    		querystring = location.substr(qsPosition + 1);
    		location = location.substr(0, qsPosition);
    	}

    	return { location, querystring };
    }

    const loc = readable(null, // eslint-disable-next-line prefer-arrow-callback
    function start(set) {
    	set(getLocation());

    	const update = () => {
    		set(getLocation());
    	};

    	window.addEventListener('hashchange', update, false);

    	return function stop() {
    		window.removeEventListener('hashchange', update, false);
    	};
    });

    const location = derived(loc, _loc => _loc.location);
    const querystring = derived(loc, _loc => _loc.querystring);
    const params = writable(undefined);

    async function push(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	// Note: this will include scroll state in history even when restoreScrollState is false
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined
    	);

    	window.location.hash = (location.charAt(0) == '#' ? '' : '#') + location;
    }

    async function pop() {
    	// Execute this code when the current call stack is complete
    	await tick();

    	window.history.back();
    }

    async function replace(location) {
    	if (!location || location.length < 1 || location.charAt(0) != '/' && location.indexOf('#/') !== 0) {
    		throw Error('Invalid parameter location');
    	}

    	// Execute this code when the current call stack is complete
    	await tick();

    	const dest = (location.charAt(0) == '#' ? '' : '#') + location;

    	try {
    		const newState = { ...history.state };
    		delete newState['__svelte_spa_router_scrollX'];
    		delete newState['__svelte_spa_router_scrollY'];
    		window.history.replaceState(newState, undefined, dest);
    	} catch(e) {
    		// eslint-disable-next-line no-console
    		console.warn('Caught exception while replacing the current page. If you\'re running this in the Svelte REPL, please note that the `replace` method might not work in this environment.');
    	}

    	// The method above doesn't trigger the hashchange event, so let's do that manually
    	window.dispatchEvent(new Event('hashchange'));
    }

    function link(node, opts) {
    	opts = linkOpts(opts);

    	// Only apply to <a> tags
    	if (!node || !node.tagName || node.tagName.toLowerCase() != 'a') {
    		throw Error('Action "link" can only be used with <a> tags');
    	}

    	updateLink(node, opts);

    	return {
    		update(updated) {
    			updated = linkOpts(updated);
    			updateLink(node, updated);
    		}
    	};
    }

    function restoreScroll(state) {
    	// If this exists, then this is a back navigation: restore the scroll position
    	if (state) {
    		window.scrollTo(state.__svelte_spa_router_scrollX, state.__svelte_spa_router_scrollY);
    	} else {
    		// Otherwise this is a forward navigation: scroll to top
    		window.scrollTo(0, 0);
    	}
    }

    // Internal function used by the link function
    function updateLink(node, opts) {
    	let href = opts.href || node.getAttribute('href');

    	// Destination must start with '/' or '#/'
    	if (href && href.charAt(0) == '/') {
    		// Add # to the href attribute
    		href = '#' + href;
    	} else if (!href || href.length < 2 || href.slice(0, 2) != '#/') {
    		throw Error('Invalid value for "href" attribute: ' + href);
    	}

    	node.setAttribute('href', href);

    	node.addEventListener('click', event => {
    		// Prevent default anchor onclick behaviour
    		event.preventDefault();

    		if (!opts.disabled) {
    			scrollstateHistoryHandler(event.currentTarget.getAttribute('href'));
    		}
    	});
    }

    // Internal function that ensures the argument of the link action is always an object
    function linkOpts(val) {
    	if (val && typeof val == 'string') {
    		return { href: val };
    	} else {
    		return val || {};
    	}
    }

    /**
     * The handler attached to an anchor tag responsible for updating the
     * current history state with the current scroll state
     *
     * @param {string} href - Destination
     */
    function scrollstateHistoryHandler(href) {
    	// Setting the url (3rd arg) to href will break clicking for reasons, so don't try to do that
    	history.replaceState(
    		{
    			...history.state,
    			__svelte_spa_router_scrollX: window.scrollX,
    			__svelte_spa_router_scrollY: window.scrollY
    		},
    		undefined
    	);

    	// This will force an update as desired, but this time our scroll state will be attached
    	window.location.hash = href;
    }

    function instance$1V($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Router', slots, []);
    	let { routes = {} } = $$props;
    	let { prefix = '' } = $$props;
    	let { restoreScrollState = false } = $$props;

    	/**
     * Container for a route: path, component
     */
    	class RouteItem {
    		/**
     * Initializes the object and creates a regular expression from the path, using regexparam.
     *
     * @param {string} path - Path to the route (must start with '/' or '*')
     * @param {SvelteComponent|WrappedComponent} component - Svelte component for the route, optionally wrapped
     */
    		constructor(path, component) {
    			if (!component || typeof component != 'function' && (typeof component != 'object' || component._sveltesparouter !== true)) {
    				throw Error('Invalid component object');
    			}

    			// Path must be a regular or expression, or a string starting with '/' or '*'
    			if (!path || typeof path == 'string' && (path.length < 1 || path.charAt(0) != '/' && path.charAt(0) != '*') || typeof path == 'object' && !(path instanceof RegExp)) {
    				throw Error('Invalid value for "path" argument - strings must start with / or *');
    			}

    			const { pattern, keys } = parse(path);
    			this.path = path;

    			// Check if the component is wrapped and we have conditions
    			if (typeof component == 'object' && component._sveltesparouter === true) {
    				this.component = component.component;
    				this.conditions = component.conditions || [];
    				this.userData = component.userData;
    				this.props = component.props || {};
    			} else {
    				// Convert the component to a function that returns a Promise, to normalize it
    				this.component = () => Promise.resolve(component);

    				this.conditions = [];
    				this.props = {};
    			}

    			this._pattern = pattern;
    			this._keys = keys;
    		}

    		/**
     * Checks if `path` matches the current route.
     * If there's a match, will return the list of parameters from the URL (if any).
     * In case of no match, the method will return `null`.
     *
     * @param {string} path - Path to test
     * @returns {null|Object.<string, string>} List of paramters from the URL if there's a match, or `null` otherwise.
     */
    		match(path) {
    			// If there's a prefix, check if it matches the start of the path.
    			// If not, bail early, else remove it before we run the matching.
    			if (prefix) {
    				if (typeof prefix == 'string') {
    					if (path.startsWith(prefix)) {
    						path = path.substr(prefix.length) || '/';
    					} else {
    						return null;
    					}
    				} else if (prefix instanceof RegExp) {
    					const match = path.match(prefix);

    					if (match && match[0]) {
    						path = path.substr(match[0].length) || '/';
    					} else {
    						return null;
    					}
    				}
    			}

    			// Check if the pattern matches
    			const matches = this._pattern.exec(path);

    			if (matches === null) {
    				return null;
    			}

    			// If the input was a regular expression, this._keys would be false, so return matches as is
    			if (this._keys === false) {
    				return matches;
    			}

    			const out = {};
    			let i = 0;

    			while (i < this._keys.length) {
    				// In the match parameters, URL-decode all values
    				try {
    					out[this._keys[i]] = decodeURIComponent(matches[i + 1] || '') || null;
    				} catch(e) {
    					out[this._keys[i]] = null;
    				}

    				i++;
    			}

    			return out;
    		}

    		/**
     * Dictionary with route details passed to the pre-conditions functions, as well as the `routeLoading`, `routeLoaded` and `conditionsFailed` events
     * @typedef {Object} RouteDetail
     * @property {string|RegExp} route - Route matched as defined in the route definition (could be a string or a reguar expression object)
     * @property {string} location - Location path
     * @property {string} querystring - Querystring from the hash
     * @property {object} [userData] - Custom data passed by the user
     * @property {SvelteComponent} [component] - Svelte component (only in `routeLoaded` events)
     * @property {string} [name] - Name of the Svelte component (only in `routeLoaded` events)
     */
    		/**
     * Executes all conditions (if any) to control whether the route can be shown. Conditions are executed in the order they are defined, and if a condition fails, the following ones aren't executed.
     * 
     * @param {RouteDetail} detail - Route detail
     * @returns {boolean} Returns true if all the conditions succeeded
     */
    		async checkConditions(detail) {
    			for (let i = 0; i < this.conditions.length; i++) {
    				if (!await this.conditions[i](detail)) {
    					return false;
    				}
    			}

    			return true;
    		}
    	}

    	// Set up all routes
    	const routesList = [];

    	if (routes instanceof Map) {
    		// If it's a map, iterate on it right away
    		routes.forEach((route, path) => {
    			routesList.push(new RouteItem(path, route));
    		});
    	} else {
    		// We have an object, so iterate on its own properties
    		Object.keys(routes).forEach(path => {
    			routesList.push(new RouteItem(path, routes[path]));
    		});
    	}

    	// Props for the component to render
    	let component = null;

    	let componentParams = null;
    	let props = {};

    	// Event dispatcher from Svelte
    	const dispatch = createEventDispatcher();

    	// Just like dispatch, but executes on the next iteration of the event loop
    	async function dispatchNextTick(name, detail) {
    		// Execute this code when the current call stack is complete
    		await tick();

    		dispatch(name, detail);
    	}

    	// If this is set, then that means we have popped into this var the state of our last scroll position
    	let previousScrollState = null;

    	let popStateChanged = null;

    	if (restoreScrollState) {
    		popStateChanged = event => {
    			// If this event was from our history.replaceState, event.state will contain
    			// our scroll history. Otherwise, event.state will be null (like on forward
    			// navigation)
    			if (event.state && (event.state.__svelte_spa_router_scrollY || event.state.__svelte_spa_router_scrollX)) {
    				previousScrollState = event.state;
    			} else {
    				previousScrollState = null;
    			}
    		};

    		// This is removed in the destroy() invocation below
    		window.addEventListener('popstate', popStateChanged);

    		afterUpdate(() => {
    			restoreScroll(previousScrollState);
    		});
    	}

    	// Always have the latest value of loc
    	let lastLoc = null;

    	// Current object of the component loaded
    	let componentObj = null;

    	// Handle hash change events
    	// Listen to changes in the $loc store and update the page
    	// Do not use the $: syntax because it gets triggered by too many things
    	const unsubscribeLoc = loc.subscribe(async newLoc => {
    		lastLoc = newLoc;

    		// Find a route matching the location
    		let i = 0;

    		while (i < routesList.length) {
    			const match = routesList[i].match(newLoc.location);

    			if (!match) {
    				i++;
    				continue;
    			}

    			const detail = {
    				route: routesList[i].path,
    				location: newLoc.location,
    				querystring: newLoc.querystring,
    				userData: routesList[i].userData,
    				params: match && typeof match == 'object' && Object.keys(match).length
    				? match
    				: null
    			};

    			// Check if the route can be loaded - if all conditions succeed
    			if (!await routesList[i].checkConditions(detail)) {
    				// Don't display anything
    				$$invalidate(0, component = null);

    				componentObj = null;

    				// Trigger an event to notify the user, then exit
    				dispatchNextTick('conditionsFailed', detail);

    				return;
    			}

    			// Trigger an event to alert that we're loading the route
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoading', Object.assign({}, detail));

    			// If there's a component to show while we're loading the route, display it
    			const obj = routesList[i].component;

    			// Do not replace the component if we're loading the same one as before, to avoid the route being unmounted and re-mounted
    			if (componentObj != obj) {
    				if (obj.loading) {
    					$$invalidate(0, component = obj.loading);
    					componentObj = obj;
    					$$invalidate(1, componentParams = obj.loadingParams);
    					$$invalidate(2, props = {});

    					// Trigger the routeLoaded event for the loading component
    					// Create a copy of detail so we don't modify the object for the dynamic route (and the dynamic route doesn't modify our object too)
    					dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    						component,
    						name: component.name,
    						params: componentParams
    					}));
    				} else {
    					$$invalidate(0, component = null);
    					componentObj = null;
    				}

    				// Invoke the Promise
    				const loaded = await obj();

    				// Now that we're here, after the promise resolved, check if we still want this component, as the user might have navigated to another page in the meanwhile
    				if (newLoc != lastLoc) {
    					// Don't update the component, just exit
    					return;
    				}

    				// If there is a "default" property, which is used by async routes, then pick that
    				$$invalidate(0, component = loaded && loaded.default || loaded);

    				componentObj = obj;
    			}

    			// Set componentParams only if we have a match, to avoid a warning similar to `<Component> was created with unknown prop 'params'`
    			// Of course, this assumes that developers always add a "params" prop when they are expecting parameters
    			if (match && typeof match == 'object' && Object.keys(match).length) {
    				$$invalidate(1, componentParams = match);
    			} else {
    				$$invalidate(1, componentParams = null);
    			}

    			// Set static props, if any
    			$$invalidate(2, props = routesList[i].props);

    			// Dispatch the routeLoaded event then exit
    			// We need to clone the object on every event invocation so we don't risk the object to be modified in the next tick
    			dispatchNextTick('routeLoaded', Object.assign({}, detail, {
    				component,
    				name: component.name,
    				params: componentParams
    			})).then(() => {
    				params.set(componentParams);
    			});

    			return;
    		}

    		// If we're still here, there was no match, so show the empty component
    		$$invalidate(0, component = null);

    		componentObj = null;
    		params.set(undefined);
    	});

    	onDestroy(() => {
    		unsubscribeLoc();
    		popStateChanged && window.removeEventListener('popstate', popStateChanged);
    	});

    	const writable_props = ['routes', 'prefix', 'restoreScrollState'];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$G.warn(`<Router> was created with unknown prop '${key}'`);
    	});

    	function routeEvent_handler(event) {
    		bubble.call(this, $$self, event);
    	}

    	function routeEvent_handler_1(event) {
    		bubble.call(this, $$self, event);
    	}

    	$$self.$$set = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    	};

    	$$self.$capture_state = () => ({
    		readable,
    		writable,
    		derived,
    		tick,
    		getLocation,
    		loc,
    		location,
    		querystring,
    		params,
    		push,
    		pop,
    		replace,
    		link,
    		restoreScroll,
    		updateLink,
    		linkOpts,
    		scrollstateHistoryHandler,
    		onDestroy,
    		createEventDispatcher,
    		afterUpdate,
    		parse,
    		routes,
    		prefix,
    		restoreScrollState,
    		RouteItem,
    		routesList,
    		component,
    		componentParams,
    		props,
    		dispatch,
    		dispatchNextTick,
    		previousScrollState,
    		popStateChanged,
    		lastLoc,
    		componentObj,
    		unsubscribeLoc
    	});

    	$$self.$inject_state = $$props => {
    		if ('routes' in $$props) $$invalidate(3, routes = $$props.routes);
    		if ('prefix' in $$props) $$invalidate(4, prefix = $$props.prefix);
    		if ('restoreScrollState' in $$props) $$invalidate(5, restoreScrollState = $$props.restoreScrollState);
    		if ('component' in $$props) $$invalidate(0, component = $$props.component);
    		if ('componentParams' in $$props) $$invalidate(1, componentParams = $$props.componentParams);
    		if ('props' in $$props) $$invalidate(2, props = $$props.props);
    		if ('previousScrollState' in $$props) previousScrollState = $$props.previousScrollState;
    		if ('popStateChanged' in $$props) popStateChanged = $$props.popStateChanged;
    		if ('lastLoc' in $$props) lastLoc = $$props.lastLoc;
    		if ('componentObj' in $$props) componentObj = $$props.componentObj;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*restoreScrollState*/ 32) {
    			// Update history.scrollRestoration depending on restoreScrollState
    			history.scrollRestoration = restoreScrollState ? 'manual' : 'auto';
    		}
    	};

    	return [
    		component,
    		componentParams,
    		props,
    		routes,
    		prefix,
    		restoreScrollState,
    		routeEvent_handler,
    		routeEvent_handler_1
    	];
    }

    class Router extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$1V, create_fragment$1V, safe_not_equal, {
    			routes: 3,
    			prefix: 4,
    			restoreScrollState: 5
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Router",
    			options,
    			id: create_fragment$1V.name
    		});
    	}

    	get routes() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set routes(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get prefix() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set prefix(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get restoreScrollState() {
    		throw new Error_1("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set restoreScrollState(value) {
    		throw new Error_1("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\DaskBoard\illustrateIMG\IMGcomponent.svelte generated by Svelte v3.59.2 */

    const file$1O = "src\\DaskBoard\\illustrateIMG\\IMGcomponent.svelte";

    function create_fragment$1U(ctx) {
    	let div4;
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let div3;
    	let div1;
    	let t1;
    	let t2;
    	let div2;
    	let t3;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			div3 = element("div");
    			div1 = element("div");
    			t1 = text(/*title*/ ctx[1]);
    			t2 = space();
    			div2 = element("div");
    			t3 = text(/*trans*/ ctx[2]);
    			if (!src_url_equal(img.src, img_src_value = /*address*/ ctx[0])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "illusimgage");
    			attr_dev(img, "class", "svelte-embs29");
    			add_location(img, file$1O, 23, 8, 536);
    			attr_dev(div0, "class", "containIMGsmall svelte-embs29");
    			add_location(div0, file$1O, 22, 4, 495);
    			attr_dev(div1, "class", "tilte svelte-embs29");
    			add_location(div1, file$1O, 27, 8, 724);
    			attr_dev(div2, "class", "trans svelte-embs29");
    			add_location(div2, file$1O, 28, 8, 767);
    			attr_dev(div3, "class", "describe svelte-embs29");
    			add_location(div3, file$1O, 26, 4, 690);
    			attr_dev(div4, "class", "containback svelte-embs29");
    			add_location(div4, file$1O, 21, 0, 462);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div0, img);
    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, div1);
    			append_dev(div1, t1);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, t3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(img, "mouseover", /*mouseover_handler*/ ctx[5], false, false, false, false),
    					listen_dev(img, "mouseleave", /*mouseleave_handler*/ ctx[6], false, false, false, false),
    					listen_dev(img, "focus", focus_handler, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*address*/ 1 && !src_url_equal(img.src, img_src_value = /*address*/ ctx[0])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*title*/ 2) set_data_dev(t1, /*title*/ ctx[1]);
    			if (dirty & /*trans*/ 4) set_data_dev(t3, /*trans*/ ctx[2]);
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Leave(e) {
    	e.target.style.cssText = `position: relative; width: 100%; transition: 0.5s;`;
    }

    const focus_handler = () => {
    	
    };

    function instance$1U($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IMGcomponent', slots, []);
    	let { address, title, trans } = $$props;
    	let { which = false } = $$props;

    	function Change(e) {
    		if (which) {
    			e.target.style.cssText = `scale: 2;
    transition: 0.5s;
    transform: translate(-25%,25%);`;
    		} else {
    			e.target.style.cssText = `  scale:2;
      transition:0.5s;  `;
    		}
    	}

    	$$self.$$.on_mount.push(function () {
    		if (address === undefined && !('address' in $$props || $$self.$$.bound[$$self.$$.props['address']])) {
    			console.warn("<IMGcomponent> was created without expected prop 'address'");
    		}

    		if (title === undefined && !('title' in $$props || $$self.$$.bound[$$self.$$.props['title']])) {
    			console.warn("<IMGcomponent> was created without expected prop 'title'");
    		}

    		if (trans === undefined && !('trans' in $$props || $$self.$$.bound[$$self.$$.props['trans']])) {
    			console.warn("<IMGcomponent> was created without expected prop 'trans'");
    		}
    	});

    	const writable_props = ['address', 'title', 'trans', 'which'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IMGcomponent> was created with unknown prop '${key}'`);
    	});

    	const mouseover_handler = () => {
    		Change(event);
    	};

    	const mouseleave_handler = () => {
    		Leave(event);
    	};

    	$$self.$$set = $$props => {
    		if ('address' in $$props) $$invalidate(0, address = $$props.address);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('trans' in $$props) $$invalidate(2, trans = $$props.trans);
    		if ('which' in $$props) $$invalidate(4, which = $$props.which);
    	};

    	$$self.$capture_state = () => ({
    		address,
    		title,
    		trans,
    		which,
    		Change,
    		Leave
    	});

    	$$self.$inject_state = $$props => {
    		if ('address' in $$props) $$invalidate(0, address = $$props.address);
    		if ('title' in $$props) $$invalidate(1, title = $$props.title);
    		if ('trans' in $$props) $$invalidate(2, trans = $$props.trans);
    		if ('which' in $$props) $$invalidate(4, which = $$props.which);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [address, title, trans, Change, which, mouseover_handler, mouseleave_handler];
    }

    class IMGcomponent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1U, create_fragment$1U, safe_not_equal, { address: 0, title: 1, trans: 2, which: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IMGcomponent",
    			options,
    			id: create_fragment$1U.name
    		});
    	}

    	get address() {
    		throw new Error("<IMGcomponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set address(value) {
    		throw new Error("<IMGcomponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get title() {
    		throw new Error("<IMGcomponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set title(value) {
    		throw new Error("<IMGcomponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get trans() {
    		throw new Error("<IMGcomponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set trans(value) {
    		throw new Error("<IMGcomponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get which() {
    		throw new Error("<IMGcomponent>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set which(value) {
    		throw new Error("<IMGcomponent>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\DaskBoard\illustrateIMG\illustrateIMG.svelte generated by Svelte v3.59.2 */
    const file$1N = "src\\DaskBoard\\illustrateIMG\\illustrateIMG.svelte";

    function create_fragment$1T(ctx) {
    	let div1;
    	let div0;
    	let t1;
    	let imgcomponent0;
    	let t2;
    	let imgcomponent1;
    	let t3;
    	let imgcomponent2;
    	let t4;
    	let imgcomponent3;
    	let t5;
    	let imgcomponent4;
    	let t6;
    	let imgcomponent5;
    	let t7;
    	let imgcomponent6;
    	let t8;
    	let imgcomponent7;
    	let t9;
    	let imgcomponent8;
    	let t10;
    	let imgcomponent9;
    	let t11;
    	let imgcomponent10;
    	let t12;
    	let imgcomponent11;
    	let t13;
    	let imgcomponent12;
    	let current;

    	imgcomponent0 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/READING/reading1.png",
    				title: "Instant Translation on Text",
    				trans: "Simply selecting a word and unlock a world of definitions, synonyms, antonyms, and collocations in an instant."
    			},
    			$$inline: true
    		});

    	imgcomponent1 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/LISTENING/listening1.png",
    				title: "Gap-Filling Creator",
    				trans: "Inputing your transcript and let the algorithm work its magic, creating randomized gaps for you to practise Gap-Filling exercise in listening."
    			},
    			$$inline: true
    		});

    	imgcomponent2 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/REVIVING/reviving1.png",
    				title: "Passive Reminding",
    				trans: "Patiently entering your words or phrases and their meanings, this tool will automatically create exercises for you to learn vocabulary by heart without much effort."
    			},
    			$$inline: true
    		});

    	imgcomponent3 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/GAME/game1.png",
    				title: "Vocabulary Activation",
    				trans: "Playing with AI, taking turns typing words that begin with the last letter of the previous word, there will be definitions expressed for you after each turn. Do not repeat any words. Who will win?"
    			},
    			$$inline: true
    		});

    	imgcomponent4 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/READING/collocation.png",
    				title: "Collocation Storage",
    				trans: "With just one click, discover collocations and find suitable adjectives for nouns, and vice versa."
    			},
    			$$inline: true
    		});

    	imgcomponent5 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/READING/synant.png",
    				which: true,
    				title: "Synonyms - Antonyms",
    				trans: "By a simple gesture, unveil a lavish array of alternatives for the word and its antonyms"
    			},
    			$$inline: true
    		});

    	imgcomponent6 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/READING/selectablepdf.png",
    				title: "Instant Translation on PDF",
    				trans: "Choosing any words in the pdf, you will immediately get its definitions and other relevant information."
    			},
    			$$inline: true
    		});

    	imgcomponent7 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/READING/editTool.png",
    				which: true,
    				title: "Mutiple PDF Edit Tools",
    				trans: "A multitude of gifted tools are available for you to embellish your PDF."
    			},
    			$$inline: true
    		});

    	imgcomponent8 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/READING/capturescreen.png",
    				title: "English ScreenSearch PDF",
    				trans: "Unable to copy text in unselectable PDFs? No need to worry. This tool helps you convert any part of the file in just a moment to text format."
    			},
    			$$inline: true
    		});

    	imgcomponent9 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/READING/transaftercap.png",
    				which: true,
    				title: "Looking up on Unselectable PDF",
    				trans: "Converting to text format, just only select your word, boomm! The dictionary will abruptly appear."
    			},
    			$$inline: true
    		});

    	imgcomponent10 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/READING/dragImage.png",
    				title: "Drop Image in one Drop",
    				trans: "Holding your image from Facebook Messenger, Zalo or any other websites, dragging it, changing tabs and dropping it. No need to download!"
    			},
    			$$inline: true
    		});

    	imgcomponent11 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/READING/aftercaptureimage.png",
    				which: true,
    				title: "Looking up on Image",
    				trans: "Similar to that in PDF one, converting then you can easily get it."
    			},
    			$$inline: true
    		});

    	imgcomponent12 = new IMGcomponent({
    			props: {
    				address: "../images/IMGStorage/READING/vietconvert.png",
    				title: "Vietnamese Convert",
    				trans: "Tired of typing a long sentence when making presentation, this one helps Vietnam Students convert any image to text that they like to insert into their powerpoint in a second!"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			div0.textContent = "Muitiple convenience for you";
    			t1 = space();
    			create_component(imgcomponent0.$$.fragment);
    			t2 = space();
    			create_component(imgcomponent1.$$.fragment);
    			t3 = space();
    			create_component(imgcomponent2.$$.fragment);
    			t4 = space();
    			create_component(imgcomponent3.$$.fragment);
    			t5 = space();
    			create_component(imgcomponent4.$$.fragment);
    			t6 = space();
    			create_component(imgcomponent5.$$.fragment);
    			t7 = space();
    			create_component(imgcomponent6.$$.fragment);
    			t8 = space();
    			create_component(imgcomponent7.$$.fragment);
    			t9 = space();
    			create_component(imgcomponent8.$$.fragment);
    			t10 = space();
    			create_component(imgcomponent9.$$.fragment);
    			t11 = space();
    			create_component(imgcomponent10.$$.fragment);
    			t12 = space();
    			create_component(imgcomponent11.$$.fragment);
    			t13 = space();
    			create_component(imgcomponent12.$$.fragment);
    			attr_dev(div0, "class", "topic svelte-supypq");
    			add_location(div0, file$1N, 5, 4, 105);
    			attr_dev(div1, "id", "containIMG");
    			attr_dev(div1, "class", "svelte-supypq");
    			add_location(div1, file$1N, 4, 0, 76);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t1);
    			mount_component(imgcomponent0, div1, null);
    			append_dev(div1, t2);
    			mount_component(imgcomponent1, div1, null);
    			append_dev(div1, t3);
    			mount_component(imgcomponent2, div1, null);
    			append_dev(div1, t4);
    			mount_component(imgcomponent3, div1, null);
    			append_dev(div1, t5);
    			mount_component(imgcomponent4, div1, null);
    			append_dev(div1, t6);
    			mount_component(imgcomponent5, div1, null);
    			append_dev(div1, t7);
    			mount_component(imgcomponent6, div1, null);
    			append_dev(div1, t8);
    			mount_component(imgcomponent7, div1, null);
    			append_dev(div1, t9);
    			mount_component(imgcomponent8, div1, null);
    			append_dev(div1, t10);
    			mount_component(imgcomponent9, div1, null);
    			append_dev(div1, t11);
    			mount_component(imgcomponent10, div1, null);
    			append_dev(div1, t12);
    			mount_component(imgcomponent11, div1, null);
    			append_dev(div1, t13);
    			mount_component(imgcomponent12, div1, null);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imgcomponent0.$$.fragment, local);
    			transition_in(imgcomponent1.$$.fragment, local);
    			transition_in(imgcomponent2.$$.fragment, local);
    			transition_in(imgcomponent3.$$.fragment, local);
    			transition_in(imgcomponent4.$$.fragment, local);
    			transition_in(imgcomponent5.$$.fragment, local);
    			transition_in(imgcomponent6.$$.fragment, local);
    			transition_in(imgcomponent7.$$.fragment, local);
    			transition_in(imgcomponent8.$$.fragment, local);
    			transition_in(imgcomponent9.$$.fragment, local);
    			transition_in(imgcomponent10.$$.fragment, local);
    			transition_in(imgcomponent11.$$.fragment, local);
    			transition_in(imgcomponent12.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imgcomponent0.$$.fragment, local);
    			transition_out(imgcomponent1.$$.fragment, local);
    			transition_out(imgcomponent2.$$.fragment, local);
    			transition_out(imgcomponent3.$$.fragment, local);
    			transition_out(imgcomponent4.$$.fragment, local);
    			transition_out(imgcomponent5.$$.fragment, local);
    			transition_out(imgcomponent6.$$.fragment, local);
    			transition_out(imgcomponent7.$$.fragment, local);
    			transition_out(imgcomponent8.$$.fragment, local);
    			transition_out(imgcomponent9.$$.fragment, local);
    			transition_out(imgcomponent10.$$.fragment, local);
    			transition_out(imgcomponent11.$$.fragment, local);
    			transition_out(imgcomponent12.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(imgcomponent0);
    			destroy_component(imgcomponent1);
    			destroy_component(imgcomponent2);
    			destroy_component(imgcomponent3);
    			destroy_component(imgcomponent4);
    			destroy_component(imgcomponent5);
    			destroy_component(imgcomponent6);
    			destroy_component(imgcomponent7);
    			destroy_component(imgcomponent8);
    			destroy_component(imgcomponent9);
    			destroy_component(imgcomponent10);
    			destroy_component(imgcomponent11);
    			destroy_component(imgcomponent12);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('IllustrateIMG', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<IllustrateIMG> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ ImGcomponent: IMGcomponent });
    	return [];
    }

    class IllustrateIMG extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1T, create_fragment$1T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "IllustrateIMG",
    			options,
    			id: create_fragment$1T.name
    		});
    	}
    }

    function cubicInOut(t) {
        return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
    }
    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }

    function blur(node, { delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const f = style.filter === 'none' ? '' : style.filter;
        const od = target_opacity * (1 - opacity);
        const [value, unit] = split_css_unit(amount);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `opacity: ${target_opacity - (od * u)}; filter: ${f} blur(${u * value}${unit});`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = 'y' } = {}) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const primary_property = axis === 'y' ? 'height' : 'width';
        const primary_property_value = parseFloat(style[primary_property]);
        const secondary_properties = axis === 'y' ? ['top', 'bottom'] : ['left', 'right'];
        const capitalized_secondary_properties = secondary_properties.map((e) => `${e[0].toUpperCase()}${e.slice(1)}`);
        const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
        const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
        const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
        const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
        const border_width_start_value = parseFloat(style[`border${capitalized_secondary_properties[0]}Width`]);
        const border_width_end_value = parseFloat(style[`border${capitalized_secondary_properties[1]}Width`]);
        return {
            delay,
            duration,
            easing,
            css: t => 'overflow: hidden;' +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `${primary_property}: ${t * primary_property_value}px;` +
                `padding-${secondary_properties[0]}: ${t * padding_start_value}px;` +
                `padding-${secondary_properties[1]}: ${t * padding_end_value}px;` +
                `margin-${secondary_properties[0]}: ${t * margin_start_value}px;` +
                `margin-${secondary_properties[1]}: ${t * margin_end_value}px;` +
                `border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;` +
                `border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
        };
    }
    function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 } = {}) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const sd = 1 - start;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
        };
    }

    /* src\DocContent\DocContent.svelte generated by Svelte v3.59.2 */
    const file$1M = "src\\DocContent\\DocContent.svelte";

    function create_fragment$1S(ctx) {
    	let div14;
    	let div3;
    	let button0;
    	let t1;
    	let div2;
    	let img;
    	let img_src_value;
    	let img_intro;
    	let t2;
    	let div0;
    	let t4;
    	let div1;
    	let button1;
    	let span0;
    	let t6;
    	let button1_intro;
    	let t7;
    	let button2;
    	let span1;
    	let t9;
    	let button2_intro;
    	let t10;
    	let button3;
    	let span2;
    	let t12;
    	let button3_intro;
    	let t13;
    	let button4;
    	let span3;
    	let t15;
    	let button4_intro;
    	let t16;
    	let div4;
    	let illustrateimg;
    	let t17;
    	let div13;
    	let div5;
    	let t19;
    	let div12;
    	let div6;
    	let span4;
    	let t21;
    	let t22;
    	let div7;
    	let span5;
    	let t24;
    	let t25;
    	let div8;
    	let span6;
    	let t27;
    	let t28;
    	let div9;
    	let span7;
    	let t30;
    	let t31;
    	let div10;
    	let span8;
    	let t33;
    	let t34;
    	let div11;
    	let span9;
    	let t36;
    	let current;
    	let mounted;
    	let dispose;
    	illustrateimg = new IllustrateIMG({ $$inline: true });

    	const block = {
    		c: function create() {
    			div14 = element("div");
    			div3 = element("div");
    			button0 = element("button");
    			button0.textContent = "archive";
    			t1 = space();
    			div2 = element("div");
    			img = element("img");
    			t2 = space();
    			div0 = element("div");
    			div0.textContent = "cultivating your english excellence";
    			t4 = space();
    			div1 = element("div");
    			button1 = element("button");
    			span0 = element("span");
    			span0.textContent = "book_5\r\n                ";
    			t6 = text("READING");
    			t7 = space();
    			button2 = element("button");
    			span1 = element("span");
    			span1.textContent = "headset_mic\r\n                ";
    			t9 = text("LISTENING");
    			t10 = space();
    			button3 = element("button");
    			span2 = element("span");
    			span2.textContent = "play_lesson\r\n                ";
    			t12 = text("REVIVING");
    			t13 = space();
    			button4 = element("button");
    			span3 = element("span");
    			span3.textContent = "sports_esports\r\n                ";
    			t15 = text("GAME");
    			t16 = space();
    			div4 = element("div");
    			create_component(illustrateimg.$$.fragment);
    			t17 = space();
    			div13 = element("div");
    			div5 = element("div");
    			div5.textContent = "Contacting us for supports";
    			t19 = space();
    			div12 = element("div");
    			div6 = element("div");
    			span4 = element("span");
    			span4.textContent = "person\r\n                ";
    			t21 = text("Nguyễn Văn Tây");
    			t22 = space();
    			div7 = element("div");
    			span5 = element("span");
    			span5.textContent = "perm_phone_msg\r\n                ";
    			t24 = text("0973884347");
    			t25 = space();
    			div8 = element("div");
    			span6 = element("span");
    			span6.textContent = "person\r\n                ";
    			t27 = text("Nguyễn Hoàng Ngân");
    			t28 = space();
    			div9 = element("div");
    			span7 = element("span");
    			span7.textContent = "perm_phone_msg\r\n                ";
    			t30 = text("0941393037");
    			t31 = space();
    			div10 = element("div");
    			span8 = element("span");
    			span8.textContent = "school\r\n                ";
    			t33 = text("Trường THPT Nguyễn Trân");
    			t34 = space();
    			div11 = element("div");
    			span9 = element("span");
    			span9.textContent = "mail\r\n                ";
    			t36 = text("worddolearning@gmail.com");
    			attr_dev(button0, "class", "material-symbols-outlined svelte-pysjzp");
    			attr_dev(button0, "id", "storelink");
    			add_location(button0, file$1M, 13, 8, 330);
    			if (!src_url_equal(img.src, img_src_value = "../images/logob.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "english");
    			attr_dev(img, "id", "superlogo");
    			attr_dev(img, "class", "svelte-pysjzp");
    			add_location(img, file$1M, 18, 12, 506);
    			attr_dev(div0, "id", "message");
    			attr_dev(div0, "class", "svelte-pysjzp");
    			add_location(div0, file$1M, 19, 12, 613);
    			attr_dev(span0, "class", "material-symbols-outlined svelte-pysjzp");
    			add_location(span0, file$1M, 24, 155, 901);
    			attr_dev(button1, "id", "pdfbut");
    			attr_dev(button1, "class", "choice svelte-pysjzp");
    			add_location(button1, file$1M, 24, 12, 758);
    			attr_dev(span1, "class", "material-symbols-outlined svelte-pysjzp");
    			add_location(span1, file$1M, 27, 158, 1166);
    			attr_dev(button2, "id", "listbut");
    			attr_dev(button2, "class", "choice svelte-pysjzp");
    			add_location(button2, file$1M, 27, 12, 1020);
    			attr_dev(span2, "class", "material-symbols-outlined svelte-pysjzp");
    			add_location(span2, file$1M, 31, 156, 1448);
    			attr_dev(button3, "id", "revibut");
    			attr_dev(button3, "class", "choice svelte-pysjzp");
    			add_location(button3, file$1M, 31, 12, 1304);
    			attr_dev(span3, "class", "material-symbols-outlined svelte-pysjzp");
    			add_location(span3, file$1M, 34, 150, 1711);
    			attr_dev(button4, "id", "game");
    			attr_dev(button4, "class", "choice svelte-pysjzp");
    			add_location(button4, file$1M, 34, 12, 1573);
    			attr_dev(div1, "id", "contaidoc1part2");
    			attr_dev(div1, "class", "svelte-pysjzp");
    			add_location(div1, file$1M, 22, 8, 702);
    			attr_dev(div2, "id", "contaidoc1part1");
    			attr_dev(div2, "class", "svelte-pysjzp");
    			add_location(div2, file$1M, 17, 8, 464);
    			attr_dev(div3, "class", "containdoc svelte-pysjzp");
    			add_location(div3, file$1M, 11, 4, 286);
    			attr_dev(div4, "class", "containdoc svelte-pysjzp");
    			set_style(div4, "height", "max-content");
    			add_location(div4, file$1M, 44, 4, 1900);
    			attr_dev(div5, "class", "topic svelte-pysjzp");
    			add_location(div5, file$1M, 48, 8, 2037);
    			attr_dev(span4, "class", "material-symbols-outlined svelte-pysjzp");
    			add_location(span4, file$1M, 50, 33, 2160);
    			attr_dev(div6, "class", "infor svelte-pysjzp");
    			add_location(div6, file$1M, 50, 12, 2139);
    			attr_dev(span5, "class", "material-symbols-outlined svelte-pysjzp");
    			add_location(span5, file$1M, 53, 33, 2304);
    			attr_dev(div7, "class", "infor svelte-pysjzp");
    			add_location(div7, file$1M, 53, 12, 2283);
    			attr_dev(span6, "class", "material-symbols-outlined svelte-pysjzp");
    			add_location(span6, file$1M, 56, 33, 2452);
    			attr_dev(div8, "class", "infor svelte-pysjzp");
    			add_location(div8, file$1M, 56, 12, 2431);
    			attr_dev(span7, "class", "material-symbols-outlined svelte-pysjzp");
    			add_location(span7, file$1M, 59, 33, 2599);
    			attr_dev(div9, "class", "infor svelte-pysjzp");
    			add_location(div9, file$1M, 59, 12, 2578);
    			attr_dev(span8, "class", "material-symbols-outlined svelte-pysjzp");
    			add_location(span8, file$1M, 62, 33, 2747);
    			attr_dev(div10, "class", "infor svelte-pysjzp");
    			add_location(div10, file$1M, 62, 12, 2726);
    			attr_dev(span9, "class", "material-symbols-outlined svelte-pysjzp");
    			add_location(span9, file$1M, 65, 33, 2900);
    			attr_dev(div11, "class", "infor svelte-pysjzp");
    			add_location(div11, file$1M, 65, 12, 2879);
    			attr_dev(div12, "id", "containinfor");
    			attr_dev(div12, "class", "svelte-pysjzp");
    			add_location(div12, file$1M, 49, 8, 2100);
    			attr_dev(div13, "id", "containdocinfor");
    			attr_dev(div13, "class", "svelte-pysjzp");
    			add_location(div13, file$1M, 47, 4, 1999);
    			attr_dev(div14, "id", "contentDoc");
    			attr_dev(div14, "class", "svelte-pysjzp");
    			add_location(div14, file$1M, 10, 0, 258);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div14, anchor);
    			append_dev(div14, div3);
    			append_dev(div3, button0);
    			append_dev(div3, t1);
    			append_dev(div3, div2);
    			append_dev(div2, img);
    			append_dev(div2, t2);
    			append_dev(div2, div0);
    			append_dev(div2, t4);
    			append_dev(div2, div1);
    			append_dev(div1, button1);
    			append_dev(button1, span0);
    			append_dev(button1, t6);
    			append_dev(div1, t7);
    			append_dev(div1, button2);
    			append_dev(button2, span1);
    			append_dev(button2, t9);
    			append_dev(div1, t10);
    			append_dev(div1, button3);
    			append_dev(button3, span2);
    			append_dev(button3, t12);
    			append_dev(div1, t13);
    			append_dev(div1, button4);
    			append_dev(button4, span3);
    			append_dev(button4, t15);
    			append_dev(div14, t16);
    			append_dev(div14, div4);
    			mount_component(illustrateimg, div4, null);
    			append_dev(div14, t17);
    			append_dev(div14, div13);
    			append_dev(div13, div5);
    			append_dev(div13, t19);
    			append_dev(div13, div12);
    			append_dev(div12, div6);
    			append_dev(div6, span4);
    			append_dev(div6, t21);
    			append_dev(div12, t22);
    			append_dev(div12, div7);
    			append_dev(div7, span5);
    			append_dev(div7, t24);
    			append_dev(div12, t25);
    			append_dev(div12, div8);
    			append_dev(div8, span6);
    			append_dev(div8, t27);
    			append_dev(div12, t28);
    			append_dev(div12, div9);
    			append_dev(div9, span7);
    			append_dev(div9, t30);
    			append_dev(div12, t31);
    			append_dev(div12, div10);
    			append_dev(div10, span8);
    			append_dev(div10, t33);
    			append_dev(div12, t34);
    			append_dev(div12, div11);
    			append_dev(div11, span9);
    			append_dev(div11, t36);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", store, false, false, false, false),
    					listen_dev(button1, "click", /*click_handler*/ ctx[0], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_1*/ ctx[1], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_2*/ ctx[2], false, false, false, false),
    					listen_dev(button4, "click", /*click_handler_3*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			if (!img_intro) {
    				add_render_callback(() => {
    					img_intro = create_in_transition(img, blur, { duration: 1000 });
    					img_intro.start();
    				});
    			}

    			if (!button1_intro) {
    				add_render_callback(() => {
    					button1_intro = create_in_transition(button1, slide, { duration: 1000 });
    					button1_intro.start();
    				});
    			}

    			if (!button2_intro) {
    				add_render_callback(() => {
    					button2_intro = create_in_transition(button2, slide, { duration: 1000 });
    					button2_intro.start();
    				});
    			}

    			if (!button3_intro) {
    				add_render_callback(() => {
    					button3_intro = create_in_transition(button3, slide, { duration: 1000 });
    					button3_intro.start();
    				});
    			}

    			if (!button4_intro) {
    				add_render_callback(() => {
    					button4_intro = create_in_transition(button4, slide, { duration: 1000 });
    					button4_intro.start();
    				});
    			}

    			transition_in(illustrateimg.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(illustrateimg.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div14);
    			destroy_component(illustrateimg);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function store() {
    	window.open('http://localhost:1805/#/store', '_blank');
    }

    function instance$1S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DocContent', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<DocContent> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		window.open('http://localhost:1805/#/reading', '_blank');
    	};

    	const click_handler_1 = () => {
    		window.open('http://localhost:1805/#/listening', '_blank');
    	};

    	const click_handler_2 = () => {
    		window.open('http://localhost:1805/#/reviving', '_blank');
    	};

    	const click_handler_3 = () => {
    		window.open('http://localhost:1805/#/game', '_blank');
    	};

    	$$self.$capture_state = () => ({ IllustrateImg: IllustrateIMG, slide, blur, store });
    	return [click_handler, click_handler_1, click_handler_2, click_handler_3];
    }

    class DocContent extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1S, create_fragment$1S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DocContent",
    			options,
    			id: create_fragment$1S.name
    		});
    	}
    }

    /* src\WelcomePage\WelComePage.svelte generated by Svelte v3.59.2 */

    function create_fragment$1R(ctx) {
    	let doccontent;
    	let current;
    	doccontent = new DocContent({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(doccontent.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(doccontent, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(doccontent.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(doccontent.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(doccontent, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WelComePage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WelComePage> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ DocContent });
    	return [];
    }

    class WelComePage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1R, create_fragment$1R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WelComePage",
    			options,
    			id: create_fragment$1R.name
    		});
    	}
    }

    let stepHomePage = writable('welcome');

    let stepDay = writable();

    /* src\HomeComponent\HomeMain.svelte generated by Svelte v3.59.2 */

    // (6:2) {#if $stepHomePage == 'welcome'}
    function create_if_block$G(ctx) {
    	let welcomepage;
    	let current;
    	welcomepage = new WelComePage({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(welcomepage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(welcomepage, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(welcomepage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(welcomepage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(welcomepage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$G.name,
    		type: "if",
    		source: "(6:2) {#if $stepHomePage == 'welcome'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1Q(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$stepHomePage*/ ctx[0] == 'welcome' && create_if_block$G(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$stepHomePage*/ ctx[0] == 'welcome') {
    				if (if_block) {
    					if (dirty & /*$stepHomePage*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$G(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1Q($$self, $$props, $$invalidate) {
    	let $stepHomePage;
    	validate_store(stepHomePage, 'stepHomePage');
    	component_subscribe($$self, stepHomePage, $$value => $$invalidate(0, $stepHomePage = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('HomeMain', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<HomeMain> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ WelComePage, stepHomePage, $stepHomePage });
    	return [$stepHomePage];
    }

    class HomeMain extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1Q, create_fragment$1Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HomeMain",
    			options,
    			id: create_fragment$1Q.name
    		});
    	}
    }

    let moreless = writable("more");
    let taskbar = writable("no");

    let step = writable(["nothing"]); // cac buoc

    let tab = writable(["draft_1"]); //Ten tab 

    let onTab = writable(1);

    let typesFile = writable(["no"]); // Types file pdf, text, images...
    let preventReloadFile = writable([false]);

    //export let panelHighlight = writable(false)

    let selectedText = writable(); //Cai bang luc boi den
    let selectedTextForQuickTask = writable(false);
    let selectedTextForQuickTaskPDF = writable(false);
    let coordinateMouse = writable([0,0]);

    let stepDic = writable('defi'); // defi, syn,ant

    let choseText = writable('');

    let dictionaryDS$2 = writable(false);
    let stepDS$2 = writable('defi');
    let enterText$2 = writable();
    let captureTF = writable(false);
    let captureLink = writable();
    let nowlinkTess = writable();
    let isConvertingTess = writable(false);
    let convertedTextTess = writable('');

    let noteTF = writable(false);
    // export let noteStep = writable("list")

    // export let numberNotesOn = writable([])

    let imageTF = writable(false);
    let imageList = writable([]);

    let DisplayImageList = writable([]);
    let imageListTab = writable([]); // create image tab = add []
    let onTabImage = writable();

    let isOning = writable([true]); // false = unmount

    let nameTF = writable(true);

    /* srcReading\TextTask\TextTask.svelte generated by Svelte v3.59.2 */
    const file$1L = "srcReading\\TextTask\\TextTask.svelte";

    function create_fragment$1P(ctx) {
    	let div4;
    	let div0;
    	let select0;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let t5;
    	let select1;
    	let option5;
    	let option6;
    	let option7;
    	let option8;
    	let option9;
    	let option10;
    	let option11;
    	let t13;
    	let div2;
    	let button0;
    	let t15;
    	let button1;
    	let t17;
    	let button2;
    	let t19;
    	let button3;
    	let t21;
    	let div1;
    	let input;
    	let t22;
    	let div3;
    	let button4;
    	let div4_intro;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div0 = element("div");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "cursive";
    			option1 = element("option");
    			option1.textContent = "fantasy";
    			option2 = element("option");
    			option2.textContent = "serif";
    			option3 = element("option");
    			option3.textContent = "monospace";
    			option4 = element("option");
    			option4.textContent = "Times New Roman";
    			t5 = space();
    			select1 = element("select");
    			option5 = element("option");
    			option5.textContent = "1";
    			option6 = element("option");
    			option6.textContent = "2";
    			option7 = element("option");
    			option7.textContent = "3";
    			option8 = element("option");
    			option8.textContent = "4";
    			option9 = element("option");
    			option9.textContent = "5";
    			option10 = element("option");
    			option10.textContent = "6";
    			option11 = element("option");
    			option11.textContent = "7";
    			t13 = space();
    			div2 = element("div");
    			button0 = element("button");
    			button0.textContent = "bold";
    			t15 = space();
    			button1 = element("button");
    			button1.textContent = "italic";
    			t17 = space();
    			button2 = element("button");
    			button2.textContent = "underline";
    			t19 = space();
    			button3 = element("button");
    			button3.textContent = "colorize";
    			t21 = space();
    			div1 = element("div");
    			input = element("input");
    			t22 = space();
    			div3 = element("div");
    			button4 = element("button");
    			button4.textContent = "more";
    			option0.__value = "cursive";
    			option0.value = option0.__value;
    			add_location(option0, file$1L, 43, 8, 1111);
    			option1.__value = "fantasy";
    			option1.value = option1.__value;
    			add_location(option1, file$1L, 44, 8, 1162);
    			option2.__value = "serif";
    			option2.value = option2.__value;
    			add_location(option2, file$1L, 45, 8, 1214);
    			option3.__value = "monospace";
    			option3.value = option3.__value;
    			add_location(option3, file$1L, 46, 8, 1262);
    			option4.__value = "\"Times New Roman\"";
    			option4.value = option4.__value;
    			add_location(option4, file$1L, 47, 8, 1318);
    			attr_dev(select0, "id", "font");
    			attr_dev(select0, "class", "svelte-7zofrj");
    			add_location(select0, file$1L, 42, 4, 1063);
    			option5.__value = "1";
    			option5.value = option5.__value;
    			add_location(option5, file$1L, 51, 8, 1449);
    			option6.__value = "2";
    			option6.value = option6.__value;
    			add_location(option6, file$1L, 52, 8, 1488);
    			option7.__value = "3";
    			option7.value = option7.__value;
    			add_location(option7, file$1L, 53, 8, 1528);
    			option8.__value = "4";
    			option8.value = option8.__value;
    			add_location(option8, file$1L, 54, 8, 1568);
    			option9.__value = "5";
    			option9.value = option9.__value;
    			add_location(option9, file$1L, 55, 8, 1608);
    			option10.__value = "6";
    			option10.value = option10.__value;
    			add_location(option10, file$1L, 56, 8, 1648);
    			option11.__value = "7";
    			option11.value = option11.__value;
    			add_location(option11, file$1L, 57, 8, 1688);
    			attr_dev(select1, "id", "size");
    			attr_dev(select1, "class", "svelte-7zofrj");
    			add_location(select1, file$1L, 50, 4, 1401);
    			attr_dev(div0, "class", "group1 svelte-7zofrj");
    			add_location(div0, file$1L, 41, 4, 1035);
    			attr_dev(button0, "id", "bold");
    			attr_dev(button0, "class", "svelte-7zofrj");
    			add_location(button0, file$1L, 64, 4, 1792);
    			attr_dev(button1, "id", "italic");
    			attr_dev(button1, "class", "svelte-7zofrj");
    			add_location(button1, file$1L, 65, 4, 1848);
    			attr_dev(button2, "id", "underline");
    			attr_dev(button2, "class", "svelte-7zofrj");
    			add_location(button2, file$1L, 66, 4, 1910);
    			attr_dev(button3, "id", "colorize");
    			attr_dev(button3, "class", "svelte-7zofrj");
    			add_location(button3, file$1L, 67, 4, 1981);
    			attr_dev(input, "type", "color");
    			attr_dev(input, "id", "fontColor");
    			attr_dev(input, "class", "svelte-7zofrj");
    			add_location(input, file$1L, 69, 12, 2103);
    			attr_dev(div1, "id", "containFontColor");
    			attr_dev(div1, "class", "svelte-7zofrj");
    			add_location(div1, file$1L, 68, 8, 2060);
    			attr_dev(div2, "class", "group2 svelte-7zofrj");
    			add_location(div2, file$1L, 63, 4, 1764);
    			attr_dev(button4, "id", "more");
    			attr_dev(button4, "class", "svelte-7zofrj");
    			add_location(button4, file$1L, 79, 5, 2258);
    			attr_dev(div3, "class", "group3 svelte-7zofrj");
    			add_location(div3, file$1L, 77, 4, 2220);
    			attr_dev(div4, "class", "container svelte-7zofrj");
    			add_location(div4, file$1L, 40, 0, 978);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div0);
    			append_dev(div0, select0);
    			append_dev(select0, option0);
    			append_dev(select0, option1);
    			append_dev(select0, option2);
    			append_dev(select0, option3);
    			append_dev(select0, option4);
    			append_dev(div0, t5);
    			append_dev(div0, select1);
    			append_dev(select1, option5);
    			append_dev(select1, option6);
    			append_dev(select1, option7);
    			append_dev(select1, option8);
    			append_dev(select1, option9);
    			append_dev(select1, option10);
    			append_dev(select1, option11);
    			append_dev(div4, t13);
    			append_dev(div4, div2);
    			append_dev(div2, button0);
    			append_dev(div2, t15);
    			append_dev(div2, button1);
    			append_dev(div2, t17);
    			append_dev(div2, button2);
    			append_dev(div2, t19);
    			append_dev(div2, button3);
    			append_dev(div2, t21);
    			append_dev(div2, div1);
    			append_dev(div1, input);
    			append_dev(div4, t22);
    			append_dev(div4, div3);
    			append_dev(div3, button4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select0, "change", Font$1, false, false, false, false),
    					listen_dev(select1, "change", Size$1, false, false, false, false),
    					listen_dev(button0, "click", Bold, false, false, false, false),
    					listen_dev(button1, "click", Italic, false, false, false, false),
    					listen_dev(button2, "click", Underline, false, false, false, false),
    					listen_dev(button3, "click", ChangeFontColor, false, false, false, false),
    					listen_dev(input, "change", updatecolor, false, false, false, false),
    					listen_dev(button4, "click", /*click_handler*/ ctx[1], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (!div4_intro) {
    				add_render_callback(() => {
    					div4_intro = create_in_transition(div4, scale, { duration: 500 });
    					div4_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Bold() {
    	document.execCommand("bold", false, null);
    }

    function Italic() {
    	document.execCommand("italic", false, null);
    }

    function Underline() {
    	document.execCommand("underline", false, null);
    }

    function Font$1() {
    	document.execCommand("fontName", false, document.getElementById("font").value);
    }

    function Size$1() {
    	document.execCommand("fontSize", false, document.getElementById("size").value);
    }

    function ChangeFontColor() {
    	let color = document.getElementById('fontColor').value;
    	document.execCommand('foreColor', false, color);
    }

    function updatecolor() {
    	let color = document.getElementById('fontColor').value;
    	document.getElementById('containFontColor').style.backgroundColor = color;
    }

    function instance$1P($$self, $$props, $$invalidate) {
    	let $moreless;
    	validate_store(moreless, 'moreless');
    	component_subscribe($$self, moreless, $$value => $$invalidate(0, $moreless = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextTask', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TextTask> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		set_store_value(moreless, $moreless = "less", $moreless);
    	};

    	$$self.$capture_state = () => ({
    		moreless,
    		scale,
    		Bold,
    		Italic,
    		Underline,
    		Font: Font$1,
    		Size: Size$1,
    		ChangeFontColor,
    		updatecolor,
    		$moreless
    	});

    	return [$moreless, click_handler];
    }

    class TextTask extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1P, create_fragment$1P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextTask",
    			options,
    			id: create_fragment$1P.name
    		});
    	}
    }

    /* srcReading\TextTask\ExtraTextTask.svelte generated by Svelte v3.59.2 */
    const file$1K = "srcReading\\TextTask\\ExtraTextTask.svelte";

    function create_fragment$1O(ctx) {
    	let div0;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let button2;
    	let t5;
    	let button3;
    	let div0_intro;
    	let t7;
    	let div1;
    	let button4;
    	let t9;
    	let button5;
    	let div1_intro;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "left";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "center";
    			t3 = space();
    			button2 = element("button");
    			button2.textContent = "right";
    			t5 = space();
    			button3 = element("button");
    			button3.textContent = "justify";
    			t7 = space();
    			div1 = element("div");
    			button4 = element("button");
    			button4.textContent = "dictionary";
    			t9 = space();
    			button5 = element("button");
    			button5.textContent = "return";
    			attr_dev(button0, "id", "left");
    			attr_dev(button0, "class", "svelte-5uam8m");
    			add_location(button0, file$1K, 29, 4, 775);
    			attr_dev(button1, "id", "center");
    			attr_dev(button1, "class", "svelte-5uam8m");
    			add_location(button1, file$1K, 30, 4, 831);
    			attr_dev(button2, "id", "right");
    			attr_dev(button2, "class", "svelte-5uam8m");
    			add_location(button2, file$1K, 31, 4, 893);
    			attr_dev(button3, "id", "justify");
    			attr_dev(button3, "class", "svelte-5uam8m");
    			add_location(button3, file$1K, 32, 4, 952);
    			attr_dev(div0, "class", "group3 svelte-5uam8m");
    			add_location(div0, file$1K, 28, 0, 721);
    			attr_dev(button4, "id", "dic");
    			attr_dev(button4, "class", "extrabut svelte-5uam8m");
    			add_location(button4, file$1K, 38, 0, 1083);
    			attr_dev(button5, "id", "return");
    			attr_dev(button5, "class", "extrabut svelte-5uam8m");
    			add_location(button5, file$1K, 39, 0, 1162);
    			attr_dev(div1, "class", "container svelte-5uam8m");
    			add_location(div1, file$1K, 36, 0, 1027);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, button0);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			append_dev(div0, t3);
    			append_dev(div0, button2);
    			append_dev(div0, t5);
    			append_dev(div0, button3);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button4);
    			append_dev(div1, t9);
    			append_dev(div1, button5);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", Left, false, false, false, false),
    					listen_dev(button1, "click", Center, false, false, false, false),
    					listen_dev(button2, "click", Right, false, false, false, false),
    					listen_dev(button3, "click", Full, false, false, false, false),
    					listen_dev(button4, "click", /*Dictest*/ ctx[1], false, false, false, false),
    					listen_dev(button5, "click", /*click_handler*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (!div0_intro) {
    				add_render_callback(() => {
    					div0_intro = create_in_transition(div0, scale, { duration: 500 });
    					div0_intro.start();
    				});
    			}

    			if (!div1_intro) {
    				add_render_callback(() => {
    					div1_intro = create_in_transition(div1, scale, { duration: 1000 });
    					div1_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Right() {
    	document.execCommand("justifyRight", false, null);
    }

    function Left() {
    	document.execCommand("justifyLeft", false, null);
    }

    function Center() {
    	document.execCommand("justifyCenter", false, null);
    }

    function Full() {
    	document.execCommand("justifyFull", false, null);
    }

    function instance$1O($$self, $$props, $$invalidate) {
    	let $convertedTextTess;
    	let $isConvertingTess;
    	let $dictionaryDS;
    	let $moreless;
    	validate_store(convertedTextTess, 'convertedTextTess');
    	component_subscribe($$self, convertedTextTess, $$value => $$invalidate(3, $convertedTextTess = $$value));
    	validate_store(isConvertingTess, 'isConvertingTess');
    	component_subscribe($$self, isConvertingTess, $$value => $$invalidate(4, $isConvertingTess = $$value));
    	validate_store(dictionaryDS$2, 'dictionaryDS');
    	component_subscribe($$self, dictionaryDS$2, $$value => $$invalidate(5, $dictionaryDS = $$value));
    	validate_store(moreless, 'moreless');
    	component_subscribe($$self, moreless, $$value => $$invalidate(0, $moreless = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ExtraTextTask', slots, []);

    	function Dictest() {
    		set_store_value(dictionaryDS$2, $dictionaryDS = !$dictionaryDS, $dictionaryDS);

    		if ($dictionaryDS == true) {
    			set_store_value(isConvertingTess, $isConvertingTess = false, $isConvertingTess);
    			set_store_value(convertedTextTess, $convertedTextTess = '', $convertedTextTess);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ExtraTextTask> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		set_store_value(moreless, $moreless = "more", $moreless);
    	};

    	$$self.$capture_state = () => ({
    		moreless,
    		dictionaryDS: dictionaryDS$2,
    		isConvertingTess,
    		convertedTextTess,
    		noteTF,
    		scale,
    		Right,
    		Left,
    		Center,
    		Full,
    		Dictest,
    		$convertedTextTess,
    		$isConvertingTess,
    		$dictionaryDS,
    		$moreless
    	});

    	return [$moreless, Dictest, click_handler];
    }

    class ExtraTextTask extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1O, create_fragment$1O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ExtraTextTask",
    			options,
    			id: create_fragment$1O.name
    		});
    	}
    }

    /* srcReading\Tab\Tab.svelte generated by Svelte v3.59.2 */

    const { console: console_1$F } = globals;
    const file$1J = "srcReading\\Tab\\Tab.svelte";

    function create_fragment$1N(ctx) {
    	let div;
    	let button0;
    	let t0;
    	let t1;
    	let button1;
    	let div_style_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			t0 = text(/*numtab*/ ctx[0]);
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "X";
    			attr_dev(button0, "id", "tab");
    			attr_dev(button0, "class", "svelte-1wufzhj");
    			add_location(button0, file$1J, 33, 0, 844);
    			attr_dev(button1, "id", "close");
    			attr_dev(button1, "class", "svelte-1wufzhj");
    			add_location(button1, file$1J, 34, 0, 900);
    			attr_dev(div, "class", "container svelte-1wufzhj");
    			attr_dev(div, "id", /*containerTab*/ ctx[1]);
    			attr_dev(div, "style", div_style_value = `background-color:${/*backcolor*/ ctx[2]}`);
    			add_location(div, file$1J, 32, 0, 756);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(button0, t0);
    			append_dev(div, t1);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*change*/ ctx[3], false, false, false, false),
    					listen_dev(button1, "click", /*Closing*/ ctx[4], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*numtab*/ 1) set_data_dev(t0, /*numtab*/ ctx[0]);

    			if (dirty & /*containerTab*/ 2) {
    				attr_dev(div, "id", /*containerTab*/ ctx[1]);
    			}

    			if (dirty & /*backcolor*/ 4 && div_style_value !== (div_style_value = `background-color:${/*backcolor*/ ctx[2]}`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1N($$self, $$props, $$invalidate) {
    	let $onTab;
    	let $typesFile;
    	let $taskbar;
    	let $isOning;
    	validate_store(onTab, 'onTab');
    	component_subscribe($$self, onTab, $$value => $$invalidate(6, $onTab = $$value));
    	validate_store(typesFile, 'typesFile');
    	component_subscribe($$self, typesFile, $$value => $$invalidate(7, $typesFile = $$value));
    	validate_store(taskbar, 'taskbar');
    	component_subscribe($$self, taskbar, $$value => $$invalidate(8, $taskbar = $$value));
    	validate_store(isOning, 'isOning');
    	component_subscribe($$self, isOning, $$value => $$invalidate(9, $isOning = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Tab', slots, []);
    	let { numtab = 0 } = $$props; //này là draft
    	let containerTab;
    	let { pagenum = 0 } = $$props; // này là trang thứ
    	let backcolor = 'transparent';

    	function change() {
    		set_store_value(onTab, $onTab = pagenum, $onTab);
    		console.log(pagenum);
    		set_store_value(taskbar, $taskbar = $typesFile[pagenum - 1], $taskbar);
    	}

    	function Closing() {
    		set_store_value(isOning, $isOning[pagenum - 1] = false, $isOning);
    		set_store_value(taskbar, $taskbar = $typesFile[pagenum - 2], $taskbar);
    	}

    	onMount(() => {
    		$$invalidate(1, containerTab = "containerTab" + pagenum.toString());

    		if (pagenum == $onTab) {
    			$$invalidate(2, backcolor = '#535353');
    			console.log(backcolor);
    		}
    	});

    	const writable_props = ['numtab', 'pagenum'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$F.warn(`<Tab> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('numtab' in $$props) $$invalidate(0, numtab = $$props.numtab);
    		if ('pagenum' in $$props) $$invalidate(5, pagenum = $$props.pagenum);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		onTab,
    		typesFile,
    		taskbar,
    		tab,
    		isOning,
    		numtab,
    		containerTab,
    		pagenum,
    		backcolor,
    		change,
    		Closing,
    		$onTab,
    		$typesFile,
    		$taskbar,
    		$isOning
    	});

    	$$self.$inject_state = $$props => {
    		if ('numtab' in $$props) $$invalidate(0, numtab = $$props.numtab);
    		if ('containerTab' in $$props) $$invalidate(1, containerTab = $$props.containerTab);
    		if ('pagenum' in $$props) $$invalidate(5, pagenum = $$props.pagenum);
    		if ('backcolor' in $$props) $$invalidate(2, backcolor = $$props.backcolor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [numtab, containerTab, backcolor, change, Closing, pagenum];
    }

    class Tab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1N, create_fragment$1N, safe_not_equal, { numtab: 0, pagenum: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tab",
    			options,
    			id: create_fragment$1N.name
    		});
    	}

    	get numtab() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set numtab(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get pagenum() {
    		throw new Error("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set pagenum(value) {
    		throw new Error("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReading\UpFile\UpFile.svelte generated by Svelte v3.59.2 */

    const { console: console_1$E } = globals;
    const file$1I = "srcReading\\UpFile\\UpFile.svelte";

    function create_fragment$1M(ctx) {
    	let div;
    	let button0;
    	let button0_intro;
    	let t1;
    	let button1;
    	let button1_intro;
    	let t3;
    	let button2;
    	let button2_intro;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "text";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "pdf";
    			t3 = space();
    			button2 = element("button");
    			button2.textContent = "image";
    			attr_dev(button0, "id", "text");
    			attr_dev(button0, "class", "svelte-9f0zze");
    			add_location(button0, file$1I, 13, 0, 371);
    			attr_dev(button1, "id", "pdf");
    			attr_dev(button1, "class", "svelte-9f0zze");
    			add_location(button1, file$1I, 15, 0, 469);
    			attr_dev(button2, "id", "image");
    			attr_dev(button2, "class", "svelte-9f0zze");
    			add_location(button2, file$1I, 17, 0, 568);
    			attr_dev(div, "class", "container svelte-9f0zze");
    			add_location(div, file$1I, 12, 0, 344);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, button1);
    			append_dev(div, t3);
    			append_dev(div, button2);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[1], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (!button0_intro) {
    				add_render_callback(() => {
    					button0_intro = create_in_transition(button0, scale, { duration: 500 });
    					button0_intro.start();
    				});
    			}

    			if (!button1_intro) {
    				add_render_callback(() => {
    					button1_intro = create_in_transition(button1, scale, { duration: 500 });
    					button1_intro.start();
    				});
    			}

    			if (!button2_intro) {
    				add_render_callback(() => {
    					button2_intro = create_in_transition(button2, scale, { duration: 500 });
    					button2_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1M($$self, $$props, $$invalidate) {
    	let $onTab;
    	let $step;
    	let $typesFile;
    	validate_store(onTab, 'onTab');
    	component_subscribe($$self, onTab, $$value => $$invalidate(4, $onTab = $$value));
    	validate_store(step, 'step');
    	component_subscribe($$self, step, $$value => $$invalidate(5, $step = $$value));
    	validate_store(typesFile, 'typesFile');
    	component_subscribe($$self, typesFile, $$value => $$invalidate(6, $typesFile = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UpFile', slots, []);

    	function Compare(types) {
    		// Xem thử chọn text,pdf hay images
    		set_store_value(step, $step[$onTab - 1] = "enterName", $step);

    		set_store_value(typesFile, $typesFile[$onTab - 1] = types, $typesFile);
    		console.log($step[$onTab - 1]);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$E.warn(`<UpFile> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		Compare("text");
    	};

    	const click_handler_1 = () => {
    		Compare("pdf");
    	};

    	const click_handler_2 = () => {
    		Compare("image");
    	};

    	$$self.$capture_state = () => ({
    		onTab,
    		step,
    		taskbar,
    		typesFile,
    		scale,
    		Compare,
    		$onTab,
    		$step,
    		$typesFile
    	});

    	return [Compare, click_handler, click_handler_1, click_handler_2];
    }

    class UpFile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1M, create_fragment$1M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UpFile",
    			options,
    			id: create_fragment$1M.name
    		});
    	}
    }

    /* srcReading\Textarea\EnterNameFile.svelte generated by Svelte v3.59.2 */
    const file$1H = "srcReading\\Textarea\\EnterNameFile.svelte";

    function create_fragment$1L(ctx) {
    	let div;
    	let input;
    	let t0;
    	let button0;
    	let t2;
    	let button1;
    	let div_intro;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			input = element("input");
    			t0 = space();
    			button0 = element("button");
    			button0.textContent = "cancel";
    			t2 = space();
    			button1 = element("button");
    			button1.textContent = "next";
    			attr_dev(input, "placeholder", "Enter the name's tab");
    			attr_dev(input, "spellcheck", "false");
    			attr_dev(input, "class", "svelte-1wcqtiw");
    			add_location(input, file$1H, 24, 4, 768);
    			attr_dev(button0, "id", "cancel");
    			attr_dev(button0, "class", "svelte-1wcqtiw");
    			add_location(button0, file$1H, 25, 4, 857);
    			attr_dev(button1, "id", "next");
    			attr_dev(button1, "class", "svelte-1wcqtiw");
    			add_location(button1, file$1H, 26, 4, 950);
    			attr_dev(div, "id", "container");
    			attr_dev(div, "class", "svelte-1wcqtiw");
    			add_location(div, file$1H, 23, 0, 713);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input);
    			set_input_value(input, /*dataName*/ ctx[0]);
    			append_dev(div, t0);
    			append_dev(div, button0);
    			append_dev(div, t2);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[4]),
    					listen_dev(button0, "click", /*click_handler*/ ctx[5], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[6], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*dataName*/ 1 && input.value !== /*dataName*/ ctx[0]) {
    				set_input_value(input, /*dataName*/ ctx[0]);
    			}
    		},
    		i: function intro(local) {
    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, slide, { duration: 1000 });
    					div_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1L($$self, $$props, $$invalidate) {
    	let $onTab;
    	let $step;
    	let $typesFile;
    	let $taskbar;
    	let $tab;
    	validate_store(onTab, 'onTab');
    	component_subscribe($$self, onTab, $$value => $$invalidate(1, $onTab = $$value));
    	validate_store(step, 'step');
    	component_subscribe($$self, step, $$value => $$invalidate(2, $step = $$value));
    	validate_store(typesFile, 'typesFile');
    	component_subscribe($$self, typesFile, $$value => $$invalidate(7, $typesFile = $$value));
    	validate_store(taskbar, 'taskbar');
    	component_subscribe($$self, taskbar, $$value => $$invalidate(8, $taskbar = $$value));
    	validate_store(tab, 'tab');
    	component_subscribe($$self, tab, $$value => $$invalidate(9, $tab = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EnterNameFile', slots, []);
    	let dataName = "";

    	function updateNameFile() {
    		set_store_value(tab, $tab[$onTab - 1] = dataName, $tab);
    		set_store_value(taskbar, $taskbar = $typesFile[$onTab - 1], $taskbar);

    		if ($typesFile[$onTab - 1] == "text") {
    			set_store_value(step, $step[$onTab - 1] = "RunText", $step); //hidden the input name
    		} else if ($typesFile[$onTab - 1] == "pdf") {
    			set_store_value(step, $step[$onTab - 1] = "RunPDF", $step); // RUN PDF VIEWER
    		} else if ($typesFile[$onTab - 1] == "image") {
    			set_store_value(step, $step[$onTab - 1] = "RunImage", $step); // RUN PDF VIEWER
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EnterNameFile> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		dataName = this.value;
    		$$invalidate(0, dataName);
    	}

    	const click_handler = () => {
    		set_store_value(step, $step[$onTab - 1] = "selectfile", $step);
    	};

    	const click_handler_1 = () => {
    		updateNameFile();
    	};

    	$$self.$capture_state = () => ({
    		onTab,
    		step,
    		tab,
    		typesFile,
    		preventReloadFile,
    		taskbar,
    		dataName,
    		slide,
    		updateNameFile,
    		$onTab,
    		$step,
    		$typesFile,
    		$taskbar,
    		$tab
    	});

    	$$self.$inject_state = $$props => {
    		if ('dataName' in $$props) $$invalidate(0, dataName = $$props.dataName);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		dataName,
    		$onTab,
    		$step,
    		updateNameFile,
    		input_input_handler,
    		click_handler,
    		click_handler_1
    	];
    }

    class EnterNameFile extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1L, create_fragment$1L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EnterNameFile",
    			options,
    			id: create_fragment$1L.name
    		});
    	}
    }

    /* srcReading\PDFviewer\Viewer.svelte generated by Svelte v3.59.2 */

    const { console: console_1$D } = globals;

    const file$1G = "srcReading\\PDFviewer\\Viewer.svelte";

    function create_fragment$1K(ctx) {
    	let main;
    	let iframe;
    	let iframe_src_value;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			main = element("main");
    			iframe = element("iframe");
    			if (!src_url_equal(iframe.src, iframe_src_value = "../lib/PDFviewer/web/viewer.html")) attr_dev(iframe, "src", iframe_src_value);
    			attr_dev(iframe, "title", "nothing");
    			attr_dev(iframe, "id", "PDFviewer");
    			attr_dev(iframe, "class", "svelte-16c5yyp");
    			add_location(iframe, file$1G, 1, 1, 9);
    			attr_dev(main, "class", "svelte-16c5yyp");
    			add_location(main, file$1G, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, iframe);

    			if (!mounted) {
    				dispose = listen_dev(iframe, "load", /*Run*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1K($$self, $$props, $$invalidate) {
    	let $selectedText;
    	let $selectedTextForQuickTaskPDF;
    	let $coordinateMouse;
    	let $choseText;
    	validate_store(selectedText, 'selectedText');
    	component_subscribe($$self, selectedText, $$value => $$invalidate(1, $selectedText = $$value));
    	validate_store(selectedTextForQuickTaskPDF, 'selectedTextForQuickTaskPDF');
    	component_subscribe($$self, selectedTextForQuickTaskPDF, $$value => $$invalidate(2, $selectedTextForQuickTaskPDF = $$value));
    	validate_store(coordinateMouse, 'coordinateMouse');
    	component_subscribe($$self, coordinateMouse, $$value => $$invalidate(3, $coordinateMouse = $$value));
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(4, $choseText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Viewer', slots, []);

    	function Run() {
    		const iframe = document.getElementById('PDFviewer');
    		const iframeWindow = iframe.contentWindow.document;

    		// iframeWindow.getElementById("PDFviewer")
    		// The iframe has finished loading, so you can now access its contentWindow property
    		iframeWindow.getElementById('viewerContainer').addEventListener('mouseup', Systematize);

    		iframeWindow.getElementById('viewerContainer').addEventListener('mousedown', Delte);
    		let prevText = '';
    		let text = '';

    		function Systematize(event) {
    			console.log("bug here");
    			prevText = text;
    			text = iframeWindow.getSelection().toString();

    			//SỬ LÝ ĐẦU VÀO Ở ĐÂY
    			if (text != "" && text != prevText) {
    				console.log(text);
    				set_store_value(choseText, $choseText = text, $choseText);

    				coordinateMouse.update(() => {
    					console.log(event.clientX, event.clientY);
    					return [event.clientX, event.clientY];
    				});

    				console.log($coordinateMouse[0], $coordinateMouse[1]);
    				set_store_value(selectedTextForQuickTaskPDF, $selectedTextForQuickTaskPDF = true, $selectedTextForQuickTaskPDF);
    			} else {
    				set_store_value(selectedTextForQuickTaskPDF, $selectedTextForQuickTaskPDF = false, $selectedTextForQuickTaskPDF);
    			}
    		}

    		function Delte() {
    			set_store_value(selectedTextForQuickTaskPDF, $selectedTextForQuickTaskPDF = false, $selectedTextForQuickTaskPDF);
    			set_store_value(selectedText, $selectedText = '', $selectedText);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$D.warn(`<Viewer> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		choseText,
    		coordinateMouse,
    		selectedText,
    		selectedTextForQuickTaskPDF,
    		Run,
    		$selectedText,
    		$selectedTextForQuickTaskPDF,
    		$coordinateMouse,
    		$choseText
    	});

    	return [Run];
    }

    let Viewer$1 = class Viewer extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1K, create_fragment$1K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Viewer",
    			options,
    			id: create_fragment$1K.name
    		});
    	}
    };

    var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var viewer = {exports: {}};

    /*!
     * Viewer.js v1.11.6
     * https://fengyuanchen.github.io/viewerjs
     *
     * Copyright 2015-present Chen Fengyuan
     * Released under the MIT license
     *
     * Date: 2023-09-17T03:16:38.052Z
     */

    (function (module, exports) {
    	(function (global, factory) {
    	  module.exports = factory() ;
    	})(commonjsGlobal, (function () {
    	  function ownKeys(e, r) {
    	    var t = Object.keys(e);
    	    if (Object.getOwnPropertySymbols) {
    	      var o = Object.getOwnPropertySymbols(e);
    	      r && (o = o.filter(function (r) {
    	        return Object.getOwnPropertyDescriptor(e, r).enumerable;
    	      })), t.push.apply(t, o);
    	    }
    	    return t;
    	  }
    	  function _objectSpread2(e) {
    	    for (var r = 1; r < arguments.length; r++) {
    	      var t = null != arguments[r] ? arguments[r] : {};
    	      r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {
    	        _defineProperty(e, r, t[r]);
    	      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
    	        Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
    	      });
    	    }
    	    return e;
    	  }
    	  function _typeof(o) {
    	    "@babel/helpers - typeof";

    	    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
    	      return typeof o;
    	    } : function (o) {
    	      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    	    }, _typeof(o);
    	  }
    	  function _classCallCheck(instance, Constructor) {
    	    if (!(instance instanceof Constructor)) {
    	      throw new TypeError("Cannot call a class as a function");
    	    }
    	  }
    	  function _defineProperties(target, props) {
    	    for (var i = 0; i < props.length; i++) {
    	      var descriptor = props[i];
    	      descriptor.enumerable = descriptor.enumerable || false;
    	      descriptor.configurable = true;
    	      if ("value" in descriptor) descriptor.writable = true;
    	      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    	    }
    	  }
    	  function _createClass(Constructor, protoProps, staticProps) {
    	    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    	    if (staticProps) _defineProperties(Constructor, staticProps);
    	    Object.defineProperty(Constructor, "prototype", {
    	      writable: false
    	    });
    	    return Constructor;
    	  }
    	  function _defineProperty(obj, key, value) {
    	    key = _toPropertyKey(key);
    	    if (key in obj) {
    	      Object.defineProperty(obj, key, {
    	        value: value,
    	        enumerable: true,
    	        configurable: true,
    	        writable: true
    	      });
    	    } else {
    	      obj[key] = value;
    	    }
    	    return obj;
    	  }
    	  function _toPrimitive(input, hint) {
    	    if (typeof input !== "object" || input === null) return input;
    	    var prim = input[Symbol.toPrimitive];
    	    if (prim !== undefined) {
    	      var res = prim.call(input, hint || "default");
    	      if (typeof res !== "object") return res;
    	      throw new TypeError("@@toPrimitive must return a primitive value.");
    	    }
    	    return (hint === "string" ? String : Number)(input);
    	  }
    	  function _toPropertyKey(arg) {
    	    var key = _toPrimitive(arg, "string");
    	    return typeof key === "symbol" ? key : String(key);
    	  }

    	  var DEFAULTS = {
    	    /**
    	     * Enable a modal backdrop, specify `static` for a backdrop
    	     * which doesn't close the modal on click.
    	     * @type {boolean}
    	     */
    	    backdrop: true,
    	    /**
    	     * Show the button on the top-right of the viewer.
    	     * @type {boolean}
    	     */
    	    button: true,
    	    /**
    	     * Show the navbar.
    	     * @type {boolean | number}
    	     */
    	    navbar: true,
    	    /**
    	     * Specify the visibility and the content of the title.
    	     * @type {boolean | number | Function | Array}
    	     */
    	    title: true,
    	    /**
    	     * Show the toolbar.
    	     * @type {boolean | number | Object}
    	     */
    	    toolbar: true,
    	    /**
    	     * Custom class name(s) to add to the viewer's root element.
    	     * @type {string}
    	     */
    	    className: '',
    	    /**
    	     * Define where to put the viewer in modal mode.
    	     * @type {string | Element}
    	     */
    	    container: 'body',
    	    /**
    	     * Filter the images for viewing. Return true if the image is viewable.
    	     * @type {Function}
    	     */
    	    filter: null,
    	    /**
    	     * Enable to request fullscreen when play.
    	     * {@link https://developer.mozilla.org/en-US/docs/Web/API/FullscreenOptions}
    	     * @type {boolean|FullscreenOptions}
    	     */
    	    fullscreen: true,
    	    /**
    	     * Define the extra attributes to inherit from the original image.
    	     * @type {Array}
    	     */
    	    inheritedAttributes: ['crossOrigin', 'decoding', 'isMap', 'loading', 'referrerPolicy', 'sizes', 'srcset', 'useMap'],
    	    /**
    	     * Define the initial coverage of the viewing image.
    	     * @type {number}
    	     */
    	    initialCoverage: 0.9,
    	    /**
    	     * Define the initial index of the image for viewing.
    	     * @type {number}
    	     */
    	    initialViewIndex: 0,
    	    /**
    	     * Enable inline mode.
    	     * @type {boolean}
    	     */
    	    inline: false,
    	    /**
    	     * The amount of time to delay between automatically cycling an image when playing.
    	     * @type {number}
    	     */
    	    interval: 5000,
    	    /**
    	     * Enable keyboard support.
    	     * @type {boolean}
    	     */
    	    keyboard: true,
    	    /**
    	     * Focus the viewer when initialized.
    	     * @type {boolean}
    	     */
    	    focus: true,
    	    /**
    	     * Indicate if show a loading spinner when load image or not.
    	     * @type {boolean}
    	     */
    	    loading: true,
    	    /**
    	     * Indicate if enable loop viewing or not.
    	     * @type {boolean}
    	     */
    	    loop: true,
    	    /**
    	     * Min width of the viewer in inline mode.
    	     * @type {number}
    	     */
    	    minWidth: 200,
    	    /**
    	     * Min height of the viewer in inline mode.
    	     * @type {number}
    	     */
    	    minHeight: 100,
    	    /**
    	     * Enable to move the image.
    	     * @type {boolean}
    	     */
    	    movable: true,
    	    /**
    	     * Enable to rotate the image.
    	     * @type {boolean}
    	     */
    	    rotatable: true,
    	    /**
    	     * Enable to scale the image.
    	     * @type {boolean}
    	     */
    	    scalable: true,
    	    /**
    	     * Enable to zoom the image.
    	     * @type {boolean}
    	     */
    	    zoomable: true,
    	    /**
    	     * Enable to zoom the current image by dragging on the touch screen.
    	     * @type {boolean}
    	     */
    	    zoomOnTouch: true,
    	    /**
    	     * Enable to zoom the image by wheeling mouse.
    	     * @type {boolean}
    	     */
    	    zoomOnWheel: true,
    	    /**
    	     * Enable to slide to the next or previous image by swiping on the touch screen.
    	     * @type {boolean}
    	     */
    	    slideOnTouch: true,
    	    /**
    	     * Indicate if toggle the image size between its natural size
    	     * and initial size when double click on the image or not.
    	     * @type {boolean}
    	     */
    	    toggleOnDblclick: true,
    	    /**
    	     * Show the tooltip with image ratio (percentage) when zoom in or zoom out.
    	     * @type {boolean}
    	     */
    	    tooltip: true,
    	    /**
    	     * Enable CSS3 Transition for some special elements.
    	     * @type {boolean}
    	     */
    	    transition: true,
    	    /**
    	     * Define the CSS `z-index` value of viewer in modal mode.
    	     * @type {number}
    	     */
    	    zIndex: 2015,
    	    /**
    	     * Define the CSS `z-index` value of viewer in inline mode.
    	     * @type {number}
    	     */
    	    zIndexInline: 0,
    	    /**
    	     * Define the ratio when zoom the image by wheeling mouse.
    	     * @type {number}
    	     */
    	    zoomRatio: 0.1,
    	    /**
    	     * Define the min ratio of the image when zoom out.
    	     * @type {number}
    	     */
    	    minZoomRatio: 0.01,
    	    /**
    	     * Define the max ratio of the image when zoom in.
    	     * @type {number}
    	     */
    	    maxZoomRatio: 100,
    	    /**
    	     * Define where to get the original image URL for viewing.
    	     * @type {string | Function}
    	     */
    	    url: 'src',
    	    /**
    	     * Event shortcuts.
    	     * @type {Function}
    	     */
    	    ready: null,
    	    show: null,
    	    shown: null,
    	    hide: null,
    	    hidden: null,
    	    view: null,
    	    viewed: null,
    	    move: null,
    	    moved: null,
    	    rotate: null,
    	    rotated: null,
    	    scale: null,
    	    scaled: null,
    	    zoom: null,
    	    zoomed: null,
    	    play: null,
    	    stop: null
    	  };

    	  var TEMPLATE = '<div class="viewer-container" tabindex="-1" touch-action="none">' + '<div class="viewer-canvas"></div>' + '<div class="viewer-footer">' + '<div class="viewer-title"></div>' + '<div class="viewer-toolbar"></div>' + '<div class="viewer-navbar">' + '<ul class="viewer-list" role="navigation"></ul>' + '</div>' + '</div>' + '<div class="viewer-tooltip" role="alert" aria-hidden="true"></div>' + '<div class="viewer-button" data-viewer-action="mix" role="button"></div>' + '<div class="viewer-player"></div>' + '</div>';

    	  var IS_BROWSER = typeof window !== 'undefined' && typeof window.document !== 'undefined';
    	  var WINDOW = IS_BROWSER ? window : {};
    	  var IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? 'ontouchstart' in WINDOW.document.documentElement : false;
    	  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;
    	  var NAMESPACE = 'viewer';

    	  // Actions
    	  var ACTION_MOVE = 'move';
    	  var ACTION_SWITCH = 'switch';
    	  var ACTION_ZOOM = 'zoom';

    	  // Classes
    	  var CLASS_ACTIVE = "".concat(NAMESPACE, "-active");
    	  var CLASS_CLOSE = "".concat(NAMESPACE, "-close");
    	  var CLASS_FADE = "".concat(NAMESPACE, "-fade");
    	  var CLASS_FIXED = "".concat(NAMESPACE, "-fixed");
    	  var CLASS_FULLSCREEN = "".concat(NAMESPACE, "-fullscreen");
    	  var CLASS_FULLSCREEN_EXIT = "".concat(NAMESPACE, "-fullscreen-exit");
    	  var CLASS_HIDE = "".concat(NAMESPACE, "-hide");
    	  var CLASS_HIDE_MD_DOWN = "".concat(NAMESPACE, "-hide-md-down");
    	  var CLASS_HIDE_SM_DOWN = "".concat(NAMESPACE, "-hide-sm-down");
    	  var CLASS_HIDE_XS_DOWN = "".concat(NAMESPACE, "-hide-xs-down");
    	  var CLASS_IN = "".concat(NAMESPACE, "-in");
    	  var CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible");
    	  var CLASS_LOADING = "".concat(NAMESPACE, "-loading");
    	  var CLASS_MOVE = "".concat(NAMESPACE, "-move");
    	  var CLASS_OPEN = "".concat(NAMESPACE, "-open");
    	  var CLASS_SHOW = "".concat(NAMESPACE, "-show");
    	  var CLASS_TRANSITION = "".concat(NAMESPACE, "-transition");

    	  // Native events
    	  var EVENT_CLICK = 'click';
    	  var EVENT_DBLCLICK = 'dblclick';
    	  var EVENT_DRAG_START = 'dragstart';
    	  var EVENT_FOCUSIN = 'focusin';
    	  var EVENT_KEY_DOWN = 'keydown';
    	  var EVENT_LOAD = 'load';
    	  var EVENT_ERROR = 'error';
    	  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';
    	  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';
    	  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';
    	  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;
    	  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;
    	  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;
    	  var EVENT_RESIZE = 'resize';
    	  var EVENT_TRANSITION_END = 'transitionend';
    	  var EVENT_WHEEL = 'wheel';

    	  // Custom events
    	  var EVENT_READY = 'ready';
    	  var EVENT_SHOW = 'show';
    	  var EVENT_SHOWN = 'shown';
    	  var EVENT_HIDE = 'hide';
    	  var EVENT_HIDDEN = 'hidden';
    	  var EVENT_VIEW = 'view';
    	  var EVENT_VIEWED = 'viewed';
    	  var EVENT_MOVE = 'move';
    	  var EVENT_MOVED = 'moved';
    	  var EVENT_ROTATE = 'rotate';
    	  var EVENT_ROTATED = 'rotated';
    	  var EVENT_SCALE = 'scale';
    	  var EVENT_SCALED = 'scaled';
    	  var EVENT_ZOOM = 'zoom';
    	  var EVENT_ZOOMED = 'zoomed';
    	  var EVENT_PLAY = 'play';
    	  var EVENT_STOP = 'stop';

    	  // Data keys
    	  var DATA_ACTION = "".concat(NAMESPACE, "Action");

    	  // RegExps
    	  var REGEXP_SPACES = /\s\s*/;

    	  // Misc
    	  var BUTTONS = ['zoom-in', 'zoom-out', 'one-to-one', 'reset', 'prev', 'play', 'next', 'rotate-left', 'rotate-right', 'flip-horizontal', 'flip-vertical'];

    	  /**
    	   * Check if the given value is a string.
    	   * @param {*} value - The value to check.
    	   * @returns {boolean} Returns `true` if the given value is a string, else `false`.
    	   */
    	  function isString(value) {
    	    return typeof value === 'string';
    	  }

    	  /**
    	   * Check if the given value is not a number.
    	   */
    	  var isNaN = Number.isNaN || WINDOW.isNaN;

    	  /**
    	   * Check if the given value is a number.
    	   * @param {*} value - The value to check.
    	   * @returns {boolean} Returns `true` if the given value is a number, else `false`.
    	   */
    	  function isNumber(value) {
    	    return typeof value === 'number' && !isNaN(value);
    	  }

    	  /**
    	   * Check if the given value is undefined.
    	   * @param {*} value - The value to check.
    	   * @returns {boolean} Returns `true` if the given value is undefined, else `false`.
    	   */
    	  function isUndefined(value) {
    	    return typeof value === 'undefined';
    	  }

    	  /**
    	   * Check if the given value is an object.
    	   * @param {*} value - The value to check.
    	   * @returns {boolean} Returns `true` if the given value is an object, else `false`.
    	   */
    	  function isObject(value) {
    	    return _typeof(value) === 'object' && value !== null;
    	  }
    	  var hasOwnProperty = Object.prototype.hasOwnProperty;

    	  /**
    	   * Check if the given value is a plain object.
    	   * @param {*} value - The value to check.
    	   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.
    	   */
    	  function isPlainObject(value) {
    	    if (!isObject(value)) {
    	      return false;
    	    }
    	    try {
    	      var _constructor = value.constructor;
    	      var prototype = _constructor.prototype;
    	      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');
    	    } catch (error) {
    	      return false;
    	    }
    	  }

    	  /**
    	   * Check if the given value is a function.
    	   * @param {*} value - The value to check.
    	   * @returns {boolean} Returns `true` if the given value is a function, else `false`.
    	   */
    	  function isFunction(value) {
    	    return typeof value === 'function';
    	  }

    	  /**
    	   * Iterate the given data.
    	   * @param {*} data - The data to iterate.
    	   * @param {Function} callback - The process function for each element.
    	   * @returns {*} The original data.
    	   */
    	  function forEach(data, callback) {
    	    if (data && isFunction(callback)) {
    	      if (Array.isArray(data) || isNumber(data.length) /* array-like */) {
    	        var length = data.length;
    	        var i;
    	        for (i = 0; i < length; i += 1) {
    	          if (callback.call(data, data[i], i, data) === false) {
    	            break;
    	          }
    	        }
    	      } else if (isObject(data)) {
    	        Object.keys(data).forEach(function (key) {
    	          callback.call(data, data[key], key, data);
    	        });
    	      }
    	    }
    	    return data;
    	  }

    	  /**
    	   * Extend the given object.
    	   * @param {*} obj - The object to be extended.
    	   * @param {*} args - The rest objects which will be merged to the first object.
    	   * @returns {Object} The extended object.
    	   */
    	  var assign = Object.assign || function assign(obj) {
    	    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    	      args[_key - 1] = arguments[_key];
    	    }
    	    if (isObject(obj) && args.length > 0) {
    	      args.forEach(function (arg) {
    	        if (isObject(arg)) {
    	          Object.keys(arg).forEach(function (key) {
    	            obj[key] = arg[key];
    	          });
    	        }
    	      });
    	    }
    	    return obj;
    	  };
    	  var REGEXP_SUFFIX = /^(?:width|height|left|top|marginLeft|marginTop)$/;

    	  /**
    	   * Apply styles to the given element.
    	   * @param {Element} element - The target element.
    	   * @param {Object} styles - The styles for applying.
    	   */
    	  function setStyle(element, styles) {
    	    var style = element.style;
    	    forEach(styles, function (value, property) {
    	      if (REGEXP_SUFFIX.test(property) && isNumber(value)) {
    	        value += 'px';
    	      }
    	      style[property] = value;
    	    });
    	  }

    	  /**
    	   * Escape a string for using in HTML.
    	   * @param {String} value - The string to escape.
    	   * @returns {String} Returns the escaped string.
    	   */
    	  function escapeHTMLEntities(value) {
    	    return isString(value) ? value.replace(/&(?!amp;|quot;|#39;|lt;|gt;)/g, '&amp;').replace(/"/g, '&quot;').replace(/'/g, '&#39;').replace(/</g, '&lt;').replace(/>/g, '&gt;') : value;
    	  }

    	  /**
    	   * Check if the given element has a special class.
    	   * @param {Element} element - The element to check.
    	   * @param {string} value - The class to search.
    	   * @returns {boolean} Returns `true` if the special class was found.
    	   */
    	  function hasClass(element, value) {
    	    if (!element || !value) {
    	      return false;
    	    }
    	    return element.classList ? element.classList.contains(value) : element.className.indexOf(value) > -1;
    	  }

    	  /**
    	   * Add classes to the given element.
    	   * @param {Element} element - The target element.
    	   * @param {string} value - The classes to be added.
    	   */
    	  function addClass(element, value) {
    	    if (!element || !value) {
    	      return;
    	    }
    	    if (isNumber(element.length)) {
    	      forEach(element, function (elem) {
    	        addClass(elem, value);
    	      });
    	      return;
    	    }
    	    if (element.classList) {
    	      element.classList.add(value);
    	      return;
    	    }
    	    var className = element.className.trim();
    	    if (!className) {
    	      element.className = value;
    	    } else if (className.indexOf(value) < 0) {
    	      element.className = "".concat(className, " ").concat(value);
    	    }
    	  }

    	  /**
    	   * Remove classes from the given element.
    	   * @param {Element} element - The target element.
    	   * @param {string} value - The classes to be removed.
    	   */
    	  function removeClass(element, value) {
    	    if (!element || !value) {
    	      return;
    	    }
    	    if (isNumber(element.length)) {
    	      forEach(element, function (elem) {
    	        removeClass(elem, value);
    	      });
    	      return;
    	    }
    	    if (element.classList) {
    	      element.classList.remove(value);
    	      return;
    	    }
    	    if (element.className.indexOf(value) >= 0) {
    	      element.className = element.className.replace(value, '');
    	    }
    	  }

    	  /**
    	   * Add or remove classes from the given element.
    	   * @param {Element} element - The target element.
    	   * @param {string} value - The classes to be toggled.
    	   * @param {boolean} added - Add only.
    	   */
    	  function toggleClass(element, value, added) {
    	    if (!value) {
    	      return;
    	    }
    	    if (isNumber(element.length)) {
    	      forEach(element, function (elem) {
    	        toggleClass(elem, value, added);
    	      });
    	      return;
    	    }

    	    // IE10-11 doesn't support the second parameter of `classList.toggle`
    	    if (added) {
    	      addClass(element, value);
    	    } else {
    	      removeClass(element, value);
    	    }
    	  }
    	  var REGEXP_HYPHENATE = /([a-z\d])([A-Z])/g;

    	  /**
    	   * Transform the given string from camelCase to kebab-case
    	   * @param {string} value - The value to transform.
    	   * @returns {string} The transformed value.
    	   */
    	  function hyphenate(value) {
    	    return value.replace(REGEXP_HYPHENATE, '$1-$2').toLowerCase();
    	  }

    	  /**
    	   * Get data from the given element.
    	   * @param {Element} element - The target element.
    	   * @param {string} name - The data key to get.
    	   * @returns {string} The data value.
    	   */
    	  function getData(element, name) {
    	    if (isObject(element[name])) {
    	      return element[name];
    	    }
    	    if (element.dataset) {
    	      return element.dataset[name];
    	    }
    	    return element.getAttribute("data-".concat(hyphenate(name)));
    	  }

    	  /**
    	   * Set data to the given element.
    	   * @param {Element} element - The target element.
    	   * @param {string} name - The data key to set.
    	   * @param {string} data - The data value.
    	   */
    	  function setData(element, name, data) {
    	    if (isObject(data)) {
    	      element[name] = data;
    	    } else if (element.dataset) {
    	      element.dataset[name] = data;
    	    } else {
    	      element.setAttribute("data-".concat(hyphenate(name)), data);
    	    }
    	  }
    	  var onceSupported = function () {
    	    var supported = false;
    	    if (IS_BROWSER) {
    	      var once = false;
    	      var listener = function listener() {};
    	      var options = Object.defineProperty({}, 'once', {
    	        get: function get() {
    	          supported = true;
    	          return once;
    	        },
    	        /**
    	         * This setter can fix a `TypeError` in strict mode
    	         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}
    	         * @param {boolean} value - The value to set
    	         */
    	        set: function set(value) {
    	          once = value;
    	        }
    	      });
    	      WINDOW.addEventListener('test', listener, options);
    	      WINDOW.removeEventListener('test', listener, options);
    	    }
    	    return supported;
    	  }();

    	  /**
    	   * Remove event listener from the target element.
    	   * @param {Element} element - The event target.
    	   * @param {string} type - The event type(s).
    	   * @param {Function} listener - The event listener.
    	   * @param {Object} options - The event options.
    	   */
    	  function removeListener(element, type, listener) {
    	    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    	    var handler = listener;
    	    type.trim().split(REGEXP_SPACES).forEach(function (event) {
    	      if (!onceSupported) {
    	        var listeners = element.listeners;
    	        if (listeners && listeners[event] && listeners[event][listener]) {
    	          handler = listeners[event][listener];
    	          delete listeners[event][listener];
    	          if (Object.keys(listeners[event]).length === 0) {
    	            delete listeners[event];
    	          }
    	          if (Object.keys(listeners).length === 0) {
    	            delete element.listeners;
    	          }
    	        }
    	      }
    	      element.removeEventListener(event, handler, options);
    	    });
    	  }

    	  /**
    	   * Add event listener to the target element.
    	   * @param {Element} element - The event target.
    	   * @param {string} type - The event type(s).
    	   * @param {Function} listener - The event listener.
    	   * @param {Object} options - The event options.
    	   */
    	  function addListener(element, type, listener) {
    	    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    	    var _handler = listener;
    	    type.trim().split(REGEXP_SPACES).forEach(function (event) {
    	      if (options.once && !onceSupported) {
    	        var _element$listeners = element.listeners,
    	          listeners = _element$listeners === void 0 ? {} : _element$listeners;
    	        _handler = function handler() {
    	          delete listeners[event][listener];
    	          element.removeEventListener(event, _handler, options);
    	          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    	            args[_key2] = arguments[_key2];
    	          }
    	          listener.apply(element, args);
    	        };
    	        if (!listeners[event]) {
    	          listeners[event] = {};
    	        }
    	        if (listeners[event][listener]) {
    	          element.removeEventListener(event, listeners[event][listener], options);
    	        }
    	        listeners[event][listener] = _handler;
    	        element.listeners = listeners;
    	      }
    	      element.addEventListener(event, _handler, options);
    	    });
    	  }

    	  /**
    	   * Dispatch event on the target element.
    	   * @param {Element} element - The event target.
    	   * @param {string} type - The event type(s).
    	   * @param {Object} data - The additional event data.
    	   * @param {Object} options - The additional event options.
    	   * @returns {boolean} Indicate if the event is default prevented or not.
    	   */
    	  function dispatchEvent(element, type, data, options) {
    	    var event;

    	    // Event and CustomEvent on IE9-11 are global objects, not constructors
    	    if (isFunction(Event) && isFunction(CustomEvent)) {
    	      event = new CustomEvent(type, _objectSpread2({
    	        bubbles: true,
    	        cancelable: true,
    	        detail: data
    	      }, options));
    	    } else {
    	      event = document.createEvent('CustomEvent');
    	      event.initCustomEvent(type, true, true, data);
    	    }
    	    return element.dispatchEvent(event);
    	  }

    	  /**
    	   * Get the offset base on the document.
    	   * @param {Element} element - The target element.
    	   * @returns {Object} The offset data.
    	   */
    	  function getOffset(element) {
    	    var box = element.getBoundingClientRect();
    	    return {
    	      left: box.left + (window.pageXOffset - document.documentElement.clientLeft),
    	      top: box.top + (window.pageYOffset - document.documentElement.clientTop)
    	    };
    	  }

    	  /**
    	   * Get transforms base on the given object.
    	   * @param {Object} obj - The target object.
    	   * @returns {string} A string contains transform values.
    	   */
    	  function getTransforms(_ref) {
    	    var rotate = _ref.rotate,
    	      scaleX = _ref.scaleX,
    	      scaleY = _ref.scaleY,
    	      translateX = _ref.translateX,
    	      translateY = _ref.translateY;
    	    var values = [];
    	    if (isNumber(translateX) && translateX !== 0) {
    	      values.push("translateX(".concat(translateX, "px)"));
    	    }
    	    if (isNumber(translateY) && translateY !== 0) {
    	      values.push("translateY(".concat(translateY, "px)"));
    	    }

    	    // Rotate should come first before scale to match orientation transform
    	    if (isNumber(rotate) && rotate !== 0) {
    	      values.push("rotate(".concat(rotate, "deg)"));
    	    }
    	    if (isNumber(scaleX) && scaleX !== 1) {
    	      values.push("scaleX(".concat(scaleX, ")"));
    	    }
    	    if (isNumber(scaleY) && scaleY !== 1) {
    	      values.push("scaleY(".concat(scaleY, ")"));
    	    }
    	    var transform = values.length ? values.join(' ') : 'none';
    	    return {
    	      WebkitTransform: transform,
    	      msTransform: transform,
    	      transform: transform
    	    };
    	  }

    	  /**
    	   * Get an image name from an image url.
    	   * @param {string} url - The target url.
    	   * @example
    	   * // picture.jpg
    	   * getImageNameFromURL('https://domain.com/path/to/picture.jpg?size=1280×960')
    	   * @returns {string} A string contains the image name.
    	   */
    	  function getImageNameFromURL(url) {
    	    return isString(url) ? decodeURIComponent(url.replace(/^.*\//, '').replace(/[?&#].*$/, '')) : '';
    	  }
    	  var IS_SAFARI = WINDOW.navigator && /Version\/\d+(\.\d+)+?\s+Safari/i.test(WINDOW.navigator.userAgent);

    	  /**
    	   * Get an image's natural sizes.
    	   * @param {string} image - The target image.
    	   * @param {Object} options - The viewer options.
    	   * @param {Function} callback - The callback function.
    	   * @returns {HTMLImageElement} The new image.
    	   */
    	  function getImageNaturalSizes(image, options, callback) {
    	    var newImage = document.createElement('img');

    	    // Modern browsers (except Safari)
    	    if (image.naturalWidth && !IS_SAFARI) {
    	      callback(image.naturalWidth, image.naturalHeight);
    	      return newImage;
    	    }
    	    var body = document.body || document.documentElement;
    	    newImage.onload = function () {
    	      callback(newImage.width, newImage.height);
    	      if (!IS_SAFARI) {
    	        body.removeChild(newImage);
    	      }
    	    };
    	    forEach(options.inheritedAttributes, function (name) {
    	      var value = image.getAttribute(name);
    	      if (value !== null) {
    	        newImage.setAttribute(name, value);
    	      }
    	    });
    	    newImage.src = image.src;

    	    // iOS Safari will convert the image automatically
    	    // with its orientation once append it into DOM
    	    if (!IS_SAFARI) {
    	      newImage.style.cssText = 'left:0;' + 'max-height:none!important;' + 'max-width:none!important;' + 'min-height:0!important;' + 'min-width:0!important;' + 'opacity:0;' + 'position:absolute;' + 'top:0;' + 'z-index:-1;';
    	      body.appendChild(newImage);
    	    }
    	    return newImage;
    	  }

    	  /**
    	   * Get the related class name of a responsive type number.
    	   * @param {string} type - The responsive type.
    	   * @returns {string} The related class name.
    	   */
    	  function getResponsiveClass(type) {
    	    switch (type) {
    	      case 2:
    	        return CLASS_HIDE_XS_DOWN;
    	      case 3:
    	        return CLASS_HIDE_SM_DOWN;
    	      case 4:
    	        return CLASS_HIDE_MD_DOWN;
    	      default:
    	        return '';
    	    }
    	  }

    	  /**
    	   * Get the max ratio of a group of pointers.
    	   * @param {string} pointers - The target pointers.
    	   * @returns {number} The result ratio.
    	   */
    	  function getMaxZoomRatio(pointers) {
    	    var pointers2 = _objectSpread2({}, pointers);
    	    var ratios = [];
    	    forEach(pointers, function (pointer, pointerId) {
    	      delete pointers2[pointerId];
    	      forEach(pointers2, function (pointer2) {
    	        var x1 = Math.abs(pointer.startX - pointer2.startX);
    	        var y1 = Math.abs(pointer.startY - pointer2.startY);
    	        var x2 = Math.abs(pointer.endX - pointer2.endX);
    	        var y2 = Math.abs(pointer.endY - pointer2.endY);
    	        var z1 = Math.sqrt(x1 * x1 + y1 * y1);
    	        var z2 = Math.sqrt(x2 * x2 + y2 * y2);
    	        var ratio = (z2 - z1) / z1;
    	        ratios.push(ratio);
    	      });
    	    });
    	    ratios.sort(function (a, b) {
    	      return Math.abs(a) < Math.abs(b);
    	    });
    	    return ratios[0];
    	  }

    	  /**
    	   * Get a pointer from an event object.
    	   * @param {Object} event - The target event object.
    	   * @param {boolean} endOnly - Indicates if only returns the end point coordinate or not.
    	   * @returns {Object} The result pointer contains start and/or end point coordinates.
    	   */
    	  function getPointer(_ref2, endOnly) {
    	    var pageX = _ref2.pageX,
    	      pageY = _ref2.pageY;
    	    var end = {
    	      endX: pageX,
    	      endY: pageY
    	    };
    	    return endOnly ? end : _objectSpread2({
    	      timeStamp: Date.now(),
    	      startX: pageX,
    	      startY: pageY
    	    }, end);
    	  }

    	  /**
    	   * Get the center point coordinate of a group of pointers.
    	   * @param {Object} pointers - The target pointers.
    	   * @returns {Object} The center point coordinate.
    	   */
    	  function getPointersCenter(pointers) {
    	    var pageX = 0;
    	    var pageY = 0;
    	    var count = 0;
    	    forEach(pointers, function (_ref3) {
    	      var startX = _ref3.startX,
    	        startY = _ref3.startY;
    	      pageX += startX;
    	      pageY += startY;
    	      count += 1;
    	    });
    	    pageX /= count;
    	    pageY /= count;
    	    return {
    	      pageX: pageX,
    	      pageY: pageY
    	    };
    	  }

    	  var render = {
    	    render: function render() {
    	      this.initContainer();
    	      this.initViewer();
    	      this.initList();
    	      this.renderViewer();
    	    },
    	    initBody: function initBody() {
    	      var ownerDocument = this.element.ownerDocument;
    	      var body = ownerDocument.body || ownerDocument.documentElement;
    	      this.body = body;
    	      this.scrollbarWidth = window.innerWidth - ownerDocument.documentElement.clientWidth;
    	      this.initialBodyPaddingRight = body.style.paddingRight;
    	      this.initialBodyComputedPaddingRight = window.getComputedStyle(body).paddingRight;
    	    },
    	    initContainer: function initContainer() {
    	      this.containerData = {
    	        width: window.innerWidth,
    	        height: window.innerHeight
    	      };
    	    },
    	    initViewer: function initViewer() {
    	      var options = this.options,
    	        parent = this.parent;
    	      var viewerData;
    	      if (options.inline) {
    	        viewerData = {
    	          width: Math.max(parent.offsetWidth, options.minWidth),
    	          height: Math.max(parent.offsetHeight, options.minHeight)
    	        };
    	        this.parentData = viewerData;
    	      }
    	      if (this.fulled || !viewerData) {
    	        viewerData = this.containerData;
    	      }
    	      this.viewerData = assign({}, viewerData);
    	    },
    	    renderViewer: function renderViewer() {
    	      if (this.options.inline && !this.fulled) {
    	        setStyle(this.viewer, this.viewerData);
    	      }
    	    },
    	    initList: function initList() {
    	      var _this = this;
    	      var element = this.element,
    	        options = this.options,
    	        list = this.list;
    	      var items = [];

    	      // initList may be called in this.update, so should keep idempotent
    	      list.innerHTML = '';
    	      forEach(this.images, function (image, index) {
    	        var src = image.src;
    	        var alt = image.alt || getImageNameFromURL(src);
    	        var url = _this.getImageURL(image);
    	        if (src || url) {
    	          var item = document.createElement('li');
    	          var img = document.createElement('img');
    	          forEach(options.inheritedAttributes, function (name) {
    	            var value = image.getAttribute(name);
    	            if (value !== null) {
    	              img.setAttribute(name, value);
    	            }
    	          });
    	          if (options.navbar) {
    	            img.src = src || url;
    	          }
    	          img.alt = alt;
    	          img.setAttribute('data-original-url', url || src);
    	          item.setAttribute('data-index', index);
    	          item.setAttribute('data-viewer-action', 'view');
    	          item.setAttribute('role', 'button');
    	          if (options.keyboard) {
    	            item.setAttribute('tabindex', 0);
    	          }
    	          item.appendChild(img);
    	          list.appendChild(item);
    	          items.push(item);
    	        }
    	      });
    	      this.items = items;
    	      forEach(items, function (item) {
    	        var image = item.firstElementChild;
    	        var onLoad;
    	        var onError;
    	        setData(image, 'filled', true);
    	        if (options.loading) {
    	          addClass(item, CLASS_LOADING);
    	        }
    	        addListener(image, EVENT_LOAD, onLoad = function onLoad(event) {
    	          removeListener(image, EVENT_ERROR, onError);
    	          if (options.loading) {
    	            removeClass(item, CLASS_LOADING);
    	          }
    	          _this.loadImage(event);
    	        }, {
    	          once: true
    	        });
    	        addListener(image, EVENT_ERROR, onError = function onError() {
    	          removeListener(image, EVENT_LOAD, onLoad);
    	          if (options.loading) {
    	            removeClass(item, CLASS_LOADING);
    	          }
    	        }, {
    	          once: true
    	        });
    	      });
    	      if (options.transition) {
    	        addListener(element, EVENT_VIEWED, function () {
    	          addClass(list, CLASS_TRANSITION);
    	        }, {
    	          once: true
    	        });
    	      }
    	    },
    	    renderList: function renderList() {
    	      var index = this.index;
    	      var item = this.items[index];
    	      if (!item) {
    	        return;
    	      }
    	      var next = item.nextElementSibling;
    	      var gutter = parseInt(window.getComputedStyle(next || item).marginLeft, 10);
    	      var offsetWidth = item.offsetWidth;
    	      var outerWidth = offsetWidth + gutter;

    	      // Place the active item in the center of the screen
    	      setStyle(this.list, assign({
    	        width: outerWidth * this.length - gutter
    	      }, getTransforms({
    	        translateX: (this.viewerData.width - offsetWidth) / 2 - outerWidth * index
    	      })));
    	    },
    	    resetList: function resetList() {
    	      var list = this.list;
    	      list.innerHTML = '';
    	      removeClass(list, CLASS_TRANSITION);
    	      setStyle(list, getTransforms({
    	        translateX: 0
    	      }));
    	    },
    	    initImage: function initImage(done) {
    	      var _this2 = this;
    	      var options = this.options,
    	        image = this.image,
    	        viewerData = this.viewerData;
    	      var footerHeight = this.footer.offsetHeight;
    	      var viewerWidth = viewerData.width;
    	      var viewerHeight = Math.max(viewerData.height - footerHeight, footerHeight);
    	      var oldImageData = this.imageData || {};
    	      var sizingImage;
    	      this.imageInitializing = {
    	        abort: function abort() {
    	          sizingImage.onload = null;
    	        }
    	      };
    	      sizingImage = getImageNaturalSizes(image, options, function (naturalWidth, naturalHeight) {
    	        var aspectRatio = naturalWidth / naturalHeight;
    	        var initialCoverage = Math.max(0, Math.min(1, options.initialCoverage));
    	        var width = viewerWidth;
    	        var height = viewerHeight;
    	        _this2.imageInitializing = false;
    	        if (viewerHeight * aspectRatio > viewerWidth) {
    	          height = viewerWidth / aspectRatio;
    	        } else {
    	          width = viewerHeight * aspectRatio;
    	        }
    	        initialCoverage = isNumber(initialCoverage) ? initialCoverage : 0.9;
    	        width = Math.min(width * initialCoverage, naturalWidth);
    	        height = Math.min(height * initialCoverage, naturalHeight);
    	        var left = (viewerWidth - width) / 2;
    	        var top = (viewerHeight - height) / 2;
    	        var imageData = {
    	          left: left,
    	          top: top,
    	          x: left,
    	          y: top,
    	          width: width,
    	          height: height,
    	          oldRatio: 1,
    	          ratio: width / naturalWidth,
    	          aspectRatio: aspectRatio,
    	          naturalWidth: naturalWidth,
    	          naturalHeight: naturalHeight
    	        };
    	        var initialImageData = assign({}, imageData);
    	        if (options.rotatable) {
    	          imageData.rotate = oldImageData.rotate || 0;
    	          initialImageData.rotate = 0;
    	        }
    	        if (options.scalable) {
    	          imageData.scaleX = oldImageData.scaleX || 1;
    	          imageData.scaleY = oldImageData.scaleY || 1;
    	          initialImageData.scaleX = 1;
    	          initialImageData.scaleY = 1;
    	        }
    	        _this2.imageData = imageData;
    	        _this2.initialImageData = initialImageData;
    	        if (done) {
    	          done();
    	        }
    	      });
    	    },
    	    renderImage: function renderImage(done) {
    	      var _this3 = this;
    	      var image = this.image,
    	        imageData = this.imageData;
    	      setStyle(image, assign({
    	        width: imageData.width,
    	        height: imageData.height,
    	        // XXX: Not to use translateX/Y to avoid image shaking when zooming
    	        marginLeft: imageData.x,
    	        marginTop: imageData.y
    	      }, getTransforms(imageData)));
    	      if (done) {
    	        if ((this.viewing || this.moving || this.rotating || this.scaling || this.zooming) && this.options.transition && hasClass(image, CLASS_TRANSITION)) {
    	          var onTransitionEnd = function onTransitionEnd() {
    	            _this3.imageRendering = false;
    	            done();
    	          };
    	          this.imageRendering = {
    	            abort: function abort() {
    	              removeListener(image, EVENT_TRANSITION_END, onTransitionEnd);
    	            }
    	          };
    	          addListener(image, EVENT_TRANSITION_END, onTransitionEnd, {
    	            once: true
    	          });
    	        } else {
    	          done();
    	        }
    	      }
    	    },
    	    resetImage: function resetImage() {
    	      var image = this.image;
    	      if (image) {
    	        if (this.viewing) {
    	          this.viewing.abort();
    	        }
    	        image.parentNode.removeChild(image);
    	        this.image = null;
    	        this.title.innerHTML = '';
    	      }
    	    }
    	  };

    	  var events = {
    	    bind: function bind() {
    	      var options = this.options,
    	        viewer = this.viewer,
    	        canvas = this.canvas;
    	      var document = this.element.ownerDocument;
    	      addListener(viewer, EVENT_CLICK, this.onClick = this.click.bind(this));
    	      addListener(viewer, EVENT_DRAG_START, this.onDragStart = this.dragstart.bind(this));
    	      addListener(canvas, EVENT_POINTER_DOWN, this.onPointerDown = this.pointerdown.bind(this));
    	      addListener(document, EVENT_POINTER_MOVE, this.onPointerMove = this.pointermove.bind(this));
    	      addListener(document, EVENT_POINTER_UP, this.onPointerUp = this.pointerup.bind(this));
    	      addListener(document, EVENT_KEY_DOWN, this.onKeyDown = this.keydown.bind(this));
    	      addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this));
    	      if (options.zoomable && options.zoomOnWheel) {
    	        addListener(viewer, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), {
    	          passive: false,
    	          capture: true
    	        });
    	      }
    	      if (options.toggleOnDblclick) {
    	        addListener(canvas, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this));
    	      }
    	    },
    	    unbind: function unbind() {
    	      var options = this.options,
    	        viewer = this.viewer,
    	        canvas = this.canvas;
    	      var document = this.element.ownerDocument;
    	      removeListener(viewer, EVENT_CLICK, this.onClick);
    	      removeListener(viewer, EVENT_DRAG_START, this.onDragStart);
    	      removeListener(canvas, EVENT_POINTER_DOWN, this.onPointerDown);
    	      removeListener(document, EVENT_POINTER_MOVE, this.onPointerMove);
    	      removeListener(document, EVENT_POINTER_UP, this.onPointerUp);
    	      removeListener(document, EVENT_KEY_DOWN, this.onKeyDown);
    	      removeListener(window, EVENT_RESIZE, this.onResize);
    	      if (options.zoomable && options.zoomOnWheel) {
    	        removeListener(viewer, EVENT_WHEEL, this.onWheel, {
    	          passive: false,
    	          capture: true
    	        });
    	      }
    	      if (options.toggleOnDblclick) {
    	        removeListener(canvas, EVENT_DBLCLICK, this.onDblclick);
    	      }
    	    }
    	  };

    	  var handlers = {
    	    click: function click(event) {
    	      var options = this.options,
    	        imageData = this.imageData;
    	      var target = event.target;
    	      var action = getData(target, DATA_ACTION);
    	      if (!action && target.localName === 'img' && target.parentElement.localName === 'li') {
    	        target = target.parentElement;
    	        action = getData(target, DATA_ACTION);
    	      }

    	      // Cancel the emulated click when the native click event was triggered.
    	      if (IS_TOUCH_DEVICE && event.isTrusted && target === this.canvas) {
    	        clearTimeout(this.clickCanvasTimeout);
    	      }
    	      switch (action) {
    	        case 'mix':
    	          if (this.played) {
    	            this.stop();
    	          } else if (options.inline) {
    	            if (this.fulled) {
    	              this.exit();
    	            } else {
    	              this.full();
    	            }
    	          } else {
    	            this.hide();
    	          }
    	          break;
    	        case 'hide':
    	          if (!this.pointerMoved) {
    	            this.hide();
    	          }
    	          break;
    	        case 'view':
    	          this.view(getData(target, 'index'));
    	          break;
    	        case 'zoom-in':
    	          this.zoom(0.1, true);
    	          break;
    	        case 'zoom-out':
    	          this.zoom(-0.1, true);
    	          break;
    	        case 'one-to-one':
    	          this.toggle();
    	          break;
    	        case 'reset':
    	          this.reset();
    	          break;
    	        case 'prev':
    	          this.prev(options.loop);
    	          break;
    	        case 'play':
    	          this.play(options.fullscreen);
    	          break;
    	        case 'next':
    	          this.next(options.loop);
    	          break;
    	        case 'rotate-left':
    	          this.rotate(-90);
    	          break;
    	        case 'rotate-right':
    	          this.rotate(90);
    	          break;
    	        case 'flip-horizontal':
    	          this.scaleX(-imageData.scaleX || -1);
    	          break;
    	        case 'flip-vertical':
    	          this.scaleY(-imageData.scaleY || -1);
    	          break;
    	        default:
    	          if (this.played) {
    	            this.stop();
    	          }
    	      }
    	    },
    	    dblclick: function dblclick(event) {
    	      event.preventDefault();
    	      if (this.viewed && event.target === this.image) {
    	        // Cancel the emulated double click when the native dblclick event was triggered.
    	        if (IS_TOUCH_DEVICE && event.isTrusted) {
    	          clearTimeout(this.doubleClickImageTimeout);
    	        }

    	        // XXX: No pageX/Y properties in custom event, fallback to the original event.
    	        this.toggle(event.isTrusted ? event : event.detail && event.detail.originalEvent);
    	      }
    	    },
    	    load: function load() {
    	      var _this = this;
    	      if (this.timeout) {
    	        clearTimeout(this.timeout);
    	        this.timeout = false;
    	      }
    	      var element = this.element,
    	        options = this.options,
    	        image = this.image,
    	        index = this.index,
    	        viewerData = this.viewerData;
    	      removeClass(image, CLASS_INVISIBLE);
    	      if (options.loading) {
    	        removeClass(this.canvas, CLASS_LOADING);
    	      }
    	      image.style.cssText = 'height:0;' + "margin-left:".concat(viewerData.width / 2, "px;") + "margin-top:".concat(viewerData.height / 2, "px;") + 'max-width:none!important;' + 'position:relative;' + 'width:0;';
    	      this.initImage(function () {
    	        toggleClass(image, CLASS_MOVE, options.movable);
    	        toggleClass(image, CLASS_TRANSITION, options.transition);
    	        _this.renderImage(function () {
    	          _this.viewed = true;
    	          _this.viewing = false;
    	          if (isFunction(options.viewed)) {
    	            addListener(element, EVENT_VIEWED, options.viewed, {
    	              once: true
    	            });
    	          }
    	          dispatchEvent(element, EVENT_VIEWED, {
    	            originalImage: _this.images[index],
    	            index: index,
    	            image: image
    	          }, {
    	            cancelable: false
    	          });
    	        });
    	      });
    	    },
    	    loadImage: function loadImage(event) {
    	      var image = event.target;
    	      var parent = image.parentNode;
    	      var parentWidth = parent.offsetWidth || 30;
    	      var parentHeight = parent.offsetHeight || 50;
    	      var filled = !!getData(image, 'filled');
    	      getImageNaturalSizes(image, this.options, function (naturalWidth, naturalHeight) {
    	        var aspectRatio = naturalWidth / naturalHeight;
    	        var width = parentWidth;
    	        var height = parentHeight;
    	        if (parentHeight * aspectRatio > parentWidth) {
    	          if (filled) {
    	            width = parentHeight * aspectRatio;
    	          } else {
    	            height = parentWidth / aspectRatio;
    	          }
    	        } else if (filled) {
    	          height = parentWidth / aspectRatio;
    	        } else {
    	          width = parentHeight * aspectRatio;
    	        }
    	        setStyle(image, assign({
    	          width: width,
    	          height: height
    	        }, getTransforms({
    	          translateX: (parentWidth - width) / 2,
    	          translateY: (parentHeight - height) / 2
    	        })));
    	      });
    	    },
    	    keydown: function keydown(event) {
    	      var options = this.options;
    	      if (!options.keyboard) {
    	        return;
    	      }
    	      var keyCode = event.keyCode || event.which || event.charCode;
    	      switch (keyCode) {
    	        // Enter
    	        case 13:
    	          if (this.viewer.contains(event.target)) {
    	            this.click(event);
    	          }
    	          break;
    	      }
    	      if (!this.fulled) {
    	        return;
    	      }
    	      switch (keyCode) {
    	        // Escape
    	        case 27:
    	          if (this.played) {
    	            this.stop();
    	          } else if (options.inline) {
    	            if (this.fulled) {
    	              this.exit();
    	            }
    	          } else {
    	            this.hide();
    	          }
    	          break;

    	        // Space
    	        case 32:
    	          if (this.played) {
    	            this.stop();
    	          }
    	          break;

    	        // ArrowLeft
    	        case 37:
    	          if (this.played && this.playing) {
    	            this.playing.prev();
    	          } else {
    	            this.prev(options.loop);
    	          }
    	          break;

    	        // ArrowUp
    	        case 38:
    	          // Prevent scroll on Firefox
    	          event.preventDefault();

    	          // Zoom in
    	          this.zoom(options.zoomRatio, true);
    	          break;

    	        // ArrowRight
    	        case 39:
    	          if (this.played && this.playing) {
    	            this.playing.next();
    	          } else {
    	            this.next(options.loop);
    	          }
    	          break;

    	        // ArrowDown
    	        case 40:
    	          // Prevent scroll on Firefox
    	          event.preventDefault();

    	          // Zoom out
    	          this.zoom(-options.zoomRatio, true);
    	          break;

    	        // Ctrl + 0
    	        case 48:
    	        // Fall through

    	        // Ctrl + 1
    	        // eslint-disable-next-line no-fallthrough
    	        case 49:
    	          if (event.ctrlKey) {
    	            event.preventDefault();
    	            this.toggle();
    	          }
    	          break;
    	      }
    	    },
    	    dragstart: function dragstart(event) {
    	      if (event.target.localName === 'img') {
    	        event.preventDefault();
    	      }
    	    },
    	    pointerdown: function pointerdown(event) {
    	      var options = this.options,
    	        pointers = this.pointers;
    	      var buttons = event.buttons,
    	        button = event.button;
    	      this.pointerMoved = false;
    	      if (!this.viewed || this.showing || this.viewing || this.hiding

    	      // Handle mouse event and pointer event and ignore touch event
    	      || (event.type === 'mousedown' || event.type === 'pointerdown' && event.pointerType === 'mouse') && (
    	      // No primary button (Usually the left button)
    	      isNumber(buttons) && buttons !== 1 || isNumber(button) && button !== 0

    	      // Open context menu
    	      || event.ctrlKey)) {
    	        return;
    	      }

    	      // Prevent default behaviours as page zooming in touch devices.
    	      event.preventDefault();
    	      if (event.changedTouches) {
    	        forEach(event.changedTouches, function (touch) {
    	          pointers[touch.identifier] = getPointer(touch);
    	        });
    	      } else {
    	        pointers[event.pointerId || 0] = getPointer(event);
    	      }
    	      var action = options.movable ? ACTION_MOVE : false;
    	      if (options.zoomOnTouch && options.zoomable && Object.keys(pointers).length > 1) {
    	        action = ACTION_ZOOM;
    	      } else if (options.slideOnTouch && (event.pointerType === 'touch' || event.type === 'touchstart') && this.isSwitchable()) {
    	        action = ACTION_SWITCH;
    	      }
    	      if (options.transition && (action === ACTION_MOVE || action === ACTION_ZOOM)) {
    	        removeClass(this.image, CLASS_TRANSITION);
    	      }
    	      this.action = action;
    	    },
    	    pointermove: function pointermove(event) {
    	      var pointers = this.pointers,
    	        action = this.action;
    	      if (!this.viewed || !action) {
    	        return;
    	      }
    	      event.preventDefault();
    	      if (event.changedTouches) {
    	        forEach(event.changedTouches, function (touch) {
    	          assign(pointers[touch.identifier] || {}, getPointer(touch, true));
    	        });
    	      } else {
    	        assign(pointers[event.pointerId || 0] || {}, getPointer(event, true));
    	      }
    	      this.change(event);
    	    },
    	    pointerup: function pointerup(event) {
    	      var _this2 = this;
    	      var options = this.options,
    	        action = this.action,
    	        pointers = this.pointers;
    	      var pointer;
    	      if (event.changedTouches) {
    	        forEach(event.changedTouches, function (touch) {
    	          pointer = pointers[touch.identifier];
    	          delete pointers[touch.identifier];
    	        });
    	      } else {
    	        pointer = pointers[event.pointerId || 0];
    	        delete pointers[event.pointerId || 0];
    	      }
    	      if (!action) {
    	        return;
    	      }
    	      event.preventDefault();
    	      if (options.transition && (action === ACTION_MOVE || action === ACTION_ZOOM)) {
    	        addClass(this.image, CLASS_TRANSITION);
    	      }
    	      this.action = false;

    	      // Emulate click and double click in touch devices to support backdrop and image zooming (#210).
    	      if (IS_TOUCH_DEVICE && action !== ACTION_ZOOM && pointer && Date.now() - pointer.timeStamp < 500) {
    	        clearTimeout(this.clickCanvasTimeout);
    	        clearTimeout(this.doubleClickImageTimeout);
    	        if (options.toggleOnDblclick && this.viewed && event.target === this.image) {
    	          if (this.imageClicked) {
    	            this.imageClicked = false;

    	            // This timeout will be cleared later when a native dblclick event is triggering
    	            this.doubleClickImageTimeout = setTimeout(function () {
    	              dispatchEvent(_this2.image, EVENT_DBLCLICK, {
    	                originalEvent: event
    	              });
    	            }, 50);
    	          } else {
    	            this.imageClicked = true;

    	            // The default timing of a double click in Windows is 500 ms
    	            this.doubleClickImageTimeout = setTimeout(function () {
    	              _this2.imageClicked = false;
    	            }, 500);
    	          }
    	        } else {
    	          this.imageClicked = false;
    	          if (options.backdrop && options.backdrop !== 'static' && event.target === this.canvas) {
    	            // This timeout will be cleared later when a native click event is triggering
    	            this.clickCanvasTimeout = setTimeout(function () {
    	              dispatchEvent(_this2.canvas, EVENT_CLICK, {
    	                originalEvent: event
    	              });
    	            }, 50);
    	          }
    	        }
    	      }
    	    },
    	    resize: function resize() {
    	      var _this3 = this;
    	      if (!this.isShown || this.hiding) {
    	        return;
    	      }
    	      if (this.fulled) {
    	        this.close();
    	        this.initBody();
    	        this.open();
    	      }
    	      this.initContainer();
    	      this.initViewer();
    	      this.renderViewer();
    	      this.renderList();
    	      if (this.viewed) {
    	        this.initImage(function () {
    	          _this3.renderImage();
    	        });
    	      }
    	      if (this.played) {
    	        if (this.options.fullscreen && this.fulled && !(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
    	          this.stop();
    	          return;
    	        }
    	        forEach(this.player.getElementsByTagName('img'), function (image) {
    	          addListener(image, EVENT_LOAD, _this3.loadImage.bind(_this3), {
    	            once: true
    	          });
    	          dispatchEvent(image, EVENT_LOAD);
    	        });
    	      }
    	    },
    	    wheel: function wheel(event) {
    	      var _this4 = this;
    	      if (!this.viewed) {
    	        return;
    	      }
    	      event.preventDefault();

    	      // Limit wheel speed to prevent zoom too fast
    	      if (this.wheeling) {
    	        return;
    	      }
    	      this.wheeling = true;
    	      setTimeout(function () {
    	        _this4.wheeling = false;
    	      }, 50);
    	      var ratio = Number(this.options.zoomRatio) || 0.1;
    	      var delta = 1;
    	      if (event.deltaY) {
    	        delta = event.deltaY > 0 ? 1 : -1;
    	      } else if (event.wheelDelta) {
    	        delta = -event.wheelDelta / 120;
    	      } else if (event.detail) {
    	        delta = event.detail > 0 ? 1 : -1;
    	      }
    	      this.zoom(-delta * ratio, true, null, event);
    	    }
    	  };

    	  var methods = {
    	    /** Show the viewer (only available in modal mode)
    	     * @param {boolean} [immediate=false] - Indicates if show the viewer immediately or not.
    	     * @returns {Viewer} this
    	     */
    	    show: function show() {
    	      var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    	      var element = this.element,
    	        options = this.options;
    	      if (options.inline || this.showing || this.isShown || this.showing) {
    	        return this;
    	      }
    	      if (!this.ready) {
    	        this.build();
    	        if (this.ready) {
    	          this.show(immediate);
    	        }
    	        return this;
    	      }
    	      if (isFunction(options.show)) {
    	        addListener(element, EVENT_SHOW, options.show, {
    	          once: true
    	        });
    	      }
    	      if (dispatchEvent(element, EVENT_SHOW) === false || !this.ready) {
    	        return this;
    	      }
    	      if (this.hiding) {
    	        this.transitioning.abort();
    	      }
    	      this.showing = true;
    	      this.open();
    	      var viewer = this.viewer;
    	      removeClass(viewer, CLASS_HIDE);
    	      viewer.setAttribute('role', 'dialog');
    	      viewer.setAttribute('aria-labelledby', this.title.id);
    	      viewer.setAttribute('aria-modal', true);
    	      viewer.removeAttribute('aria-hidden');
    	      if (options.transition && !immediate) {
    	        var shown = this.shown.bind(this);
    	        this.transitioning = {
    	          abort: function abort() {
    	            removeListener(viewer, EVENT_TRANSITION_END, shown);
    	            removeClass(viewer, CLASS_IN);
    	          }
    	        };
    	        addClass(viewer, CLASS_TRANSITION);

    	        // Force reflow to enable CSS3 transition
    	        viewer.initialOffsetWidth = viewer.offsetWidth;
    	        addListener(viewer, EVENT_TRANSITION_END, shown, {
    	          once: true
    	        });
    	        addClass(viewer, CLASS_IN);
    	      } else {
    	        addClass(viewer, CLASS_IN);
    	        this.shown();
    	      }
    	      return this;
    	    },
    	    /**
    	     * Hide the viewer (only available in modal mode)
    	     * @param {boolean} [immediate=false] - Indicates if hide the viewer immediately or not.
    	     * @returns {Viewer} this
    	     */
    	    hide: function hide() {
    	      var _this = this;
    	      var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    	      var element = this.element,
    	        options = this.options;
    	      if (options.inline || this.hiding || !(this.isShown || this.showing)) {
    	        return this;
    	      }
    	      if (isFunction(options.hide)) {
    	        addListener(element, EVENT_HIDE, options.hide, {
    	          once: true
    	        });
    	      }
    	      if (dispatchEvent(element, EVENT_HIDE) === false) {
    	        return this;
    	      }
    	      if (this.showing) {
    	        this.transitioning.abort();
    	      }
    	      this.hiding = true;
    	      if (this.played) {
    	        this.stop();
    	      } else if (this.viewing) {
    	        this.viewing.abort();
    	      }
    	      var viewer = this.viewer,
    	        image = this.image;
    	      var hideImmediately = function hideImmediately() {
    	        removeClass(viewer, CLASS_IN);
    	        _this.hidden();
    	      };
    	      if (options.transition && !immediate) {
    	        var onViewerTransitionEnd = function onViewerTransitionEnd(event) {
    	          // Ignore all propagating `transitionend` events (#275).
    	          if (event && event.target === viewer) {
    	            removeListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);
    	            _this.hidden();
    	          }
    	        };
    	        var onImageTransitionEnd = function onImageTransitionEnd() {
    	          // In case of show the viewer by `viewer.show(true)` previously (#407).
    	          if (hasClass(viewer, CLASS_TRANSITION)) {
    	            addListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);
    	            removeClass(viewer, CLASS_IN);
    	          } else {
    	            hideImmediately();
    	          }
    	        };
    	        this.transitioning = {
    	          abort: function abort() {
    	            if (_this.viewed && hasClass(image, CLASS_TRANSITION)) {
    	              removeListener(image, EVENT_TRANSITION_END, onImageTransitionEnd);
    	            } else if (hasClass(viewer, CLASS_TRANSITION)) {
    	              removeListener(viewer, EVENT_TRANSITION_END, onViewerTransitionEnd);
    	            }
    	          }
    	        };

    	        // In case of hiding the viewer when holding on the image (#255),
    	        // note that the `CLASS_TRANSITION` class will be removed on pointer down.
    	        if (this.viewed && hasClass(image, CLASS_TRANSITION)) {
    	          addListener(image, EVENT_TRANSITION_END, onImageTransitionEnd, {
    	            once: true
    	          });
    	          this.zoomTo(0, false, null, null, true);
    	        } else {
    	          onImageTransitionEnd();
    	        }
    	      } else {
    	        hideImmediately();
    	      }
    	      return this;
    	    },
    	    /**
    	     * View one of the images with image's index
    	     * @param {number} index - The index of the image to view.
    	     * @returns {Viewer} this
    	     */
    	    view: function view() {
    	      var _this2 = this;
    	      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.options.initialViewIndex;
    	      index = Number(index) || 0;
    	      if (this.hiding || this.played || index < 0 || index >= this.length || this.viewed && index === this.index) {
    	        return this;
    	      }
    	      if (!this.isShown) {
    	        this.index = index;
    	        return this.show();
    	      }
    	      if (this.viewing) {
    	        this.viewing.abort();
    	      }
    	      var element = this.element,
    	        options = this.options,
    	        title = this.title,
    	        canvas = this.canvas;
    	      var item = this.items[index];
    	      var img = item.querySelector('img');
    	      var url = getData(img, 'originalUrl');
    	      var alt = img.getAttribute('alt');
    	      var image = document.createElement('img');
    	      forEach(options.inheritedAttributes, function (name) {
    	        var value = img.getAttribute(name);
    	        if (value !== null) {
    	          image.setAttribute(name, value);
    	        }
    	      });
    	      image.src = url;
    	      image.alt = alt;
    	      if (isFunction(options.view)) {
    	        addListener(element, EVENT_VIEW, options.view, {
    	          once: true
    	        });
    	      }
    	      if (dispatchEvent(element, EVENT_VIEW, {
    	        originalImage: this.images[index],
    	        index: index,
    	        image: image
    	      }) === false || !this.isShown || this.hiding || this.played) {
    	        return this;
    	      }
    	      var activeItem = this.items[this.index];
    	      if (activeItem) {
    	        removeClass(activeItem, CLASS_ACTIVE);
    	        activeItem.removeAttribute('aria-selected');
    	      }
    	      addClass(item, CLASS_ACTIVE);
    	      item.setAttribute('aria-selected', true);
    	      if (options.focus) {
    	        item.focus();
    	      }
    	      this.image = image;
    	      this.viewed = false;
    	      this.index = index;
    	      this.imageData = {};
    	      addClass(image, CLASS_INVISIBLE);
    	      if (options.loading) {
    	        addClass(canvas, CLASS_LOADING);
    	      }
    	      canvas.innerHTML = '';
    	      canvas.appendChild(image);

    	      // Center current item
    	      this.renderList();

    	      // Clear title
    	      title.innerHTML = '';

    	      // Generate title after viewed
    	      var onViewed = function onViewed() {
    	        var imageData = _this2.imageData;
    	        var render = Array.isArray(options.title) ? options.title[1] : options.title;
    	        title.innerHTML = escapeHTMLEntities(isFunction(render) ? render.call(_this2, image, imageData) : "".concat(alt, " (").concat(imageData.naturalWidth, " \xD7 ").concat(imageData.naturalHeight, ")"));
    	      };
    	      var onLoad;
    	      var onError;
    	      addListener(element, EVENT_VIEWED, onViewed, {
    	        once: true
    	      });
    	      this.viewing = {
    	        abort: function abort() {
    	          removeListener(element, EVENT_VIEWED, onViewed);
    	          if (image.complete) {
    	            if (_this2.imageRendering) {
    	              _this2.imageRendering.abort();
    	            } else if (_this2.imageInitializing) {
    	              _this2.imageInitializing.abort();
    	            }
    	          } else {
    	            // Cancel download to save bandwidth.
    	            image.src = '';
    	            removeListener(image, EVENT_LOAD, onLoad);
    	            if (_this2.timeout) {
    	              clearTimeout(_this2.timeout);
    	            }
    	          }
    	        }
    	      };
    	      if (image.complete) {
    	        this.load();
    	      } else {
    	        addListener(image, EVENT_LOAD, onLoad = function onLoad() {
    	          removeListener(image, EVENT_ERROR, onError);
    	          _this2.load();
    	        }, {
    	          once: true
    	        });
    	        addListener(image, EVENT_ERROR, onError = function onError() {
    	          removeListener(image, EVENT_LOAD, onLoad);
    	          if (_this2.timeout) {
    	            clearTimeout(_this2.timeout);
    	            _this2.timeout = false;
    	          }
    	          removeClass(image, CLASS_INVISIBLE);
    	          if (options.loading) {
    	            removeClass(_this2.canvas, CLASS_LOADING);
    	          }
    	        }, {
    	          once: true
    	        });
    	        if (this.timeout) {
    	          clearTimeout(this.timeout);
    	        }

    	        // Make the image visible if it fails to load within 1s
    	        this.timeout = setTimeout(function () {
    	          removeClass(image, CLASS_INVISIBLE);
    	          _this2.timeout = false;
    	        }, 1000);
    	      }
    	      return this;
    	    },
    	    /**
    	     * View the previous image
    	     * @param {boolean} [loop=false] - Indicate if view the last one
    	     * when it is the first one at present.
    	     * @returns {Viewer} this
    	     */
    	    prev: function prev() {
    	      var loop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    	      var index = this.index - 1;
    	      if (index < 0) {
    	        index = loop ? this.length - 1 : 0;
    	      }
    	      this.view(index);
    	      return this;
    	    },
    	    /**
    	     * View the next image
    	     * @param {boolean} [loop=false] - Indicate if view the first one
    	     * when it is the last one at present.
    	     * @returns {Viewer} this
    	     */
    	    next: function next() {
    	      var loop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    	      var maxIndex = this.length - 1;
    	      var index = this.index + 1;
    	      if (index > maxIndex) {
    	        index = loop ? 0 : maxIndex;
    	      }
    	      this.view(index);
    	      return this;
    	    },
    	    /**
    	     * Move the image with relative offsets.
    	     * @param {number} x - The moving distance in the horizontal direction.
    	     * @param {number} [y=x] The moving distance in the vertical direction.
    	     * @returns {Viewer} this
    	     */
    	    move: function move(x) {
    	      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
    	      var imageData = this.imageData;
    	      this.moveTo(isUndefined(x) ? x : imageData.x + Number(x), isUndefined(y) ? y : imageData.y + Number(y));
    	      return this;
    	    },
    	    /**
    	     * Move the image to an absolute point.
    	     * @param {number} x - The new position in the horizontal direction.
    	     * @param {number} [y=x] - The new position in the vertical direction.
    	     * @param {Event} [_originalEvent=null] - The original event if any.
    	     * @returns {Viewer} this
    	     */
    	    moveTo: function moveTo(x) {
    	      var _this3 = this;
    	      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;
    	      var _originalEvent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    	      var element = this.element,
    	        options = this.options,
    	        imageData = this.imageData;
    	      x = Number(x);
    	      y = Number(y);
    	      if (this.viewed && !this.played && options.movable) {
    	        var oldX = imageData.x;
    	        var oldY = imageData.y;
    	        var changed = false;
    	        if (isNumber(x)) {
    	          changed = true;
    	        } else {
    	          x = oldX;
    	        }
    	        if (isNumber(y)) {
    	          changed = true;
    	        } else {
    	          y = oldY;
    	        }
    	        if (changed) {
    	          if (isFunction(options.move)) {
    	            addListener(element, EVENT_MOVE, options.move, {
    	              once: true
    	            });
    	          }
    	          if (dispatchEvent(element, EVENT_MOVE, {
    	            x: x,
    	            y: y,
    	            oldX: oldX,
    	            oldY: oldY,
    	            originalEvent: _originalEvent
    	          }) === false) {
    	            return this;
    	          }
    	          imageData.x = x;
    	          imageData.y = y;
    	          imageData.left = x;
    	          imageData.top = y;
    	          this.moving = true;
    	          this.renderImage(function () {
    	            _this3.moving = false;
    	            if (isFunction(options.moved)) {
    	              addListener(element, EVENT_MOVED, options.moved, {
    	                once: true
    	              });
    	            }
    	            dispatchEvent(element, EVENT_MOVED, {
    	              x: x,
    	              y: y,
    	              oldX: oldX,
    	              oldY: oldY,
    	              originalEvent: _originalEvent
    	            }, {
    	              cancelable: false
    	            });
    	          });
    	        }
    	      }
    	      return this;
    	    },
    	    /**
    	     * Rotate the image with a relative degree.
    	     * @param {number} degree - The rotate degree.
    	     * @returns {Viewer} this
    	     */
    	    rotate: function rotate(degree) {
    	      this.rotateTo((this.imageData.rotate || 0) + Number(degree));
    	      return this;
    	    },
    	    /**
    	     * Rotate the image to an absolute degree.
    	     * @param {number} degree - The rotate degree.
    	     * @returns {Viewer} this
    	     */
    	    rotateTo: function rotateTo(degree) {
    	      var _this4 = this;
    	      var element = this.element,
    	        options = this.options,
    	        imageData = this.imageData;
    	      degree = Number(degree);
    	      if (isNumber(degree) && this.viewed && !this.played && options.rotatable) {
    	        var oldDegree = imageData.rotate;
    	        if (isFunction(options.rotate)) {
    	          addListener(element, EVENT_ROTATE, options.rotate, {
    	            once: true
    	          });
    	        }
    	        if (dispatchEvent(element, EVENT_ROTATE, {
    	          degree: degree,
    	          oldDegree: oldDegree
    	        }) === false) {
    	          return this;
    	        }
    	        imageData.rotate = degree;
    	        this.rotating = true;
    	        this.renderImage(function () {
    	          _this4.rotating = false;
    	          if (isFunction(options.rotated)) {
    	            addListener(element, EVENT_ROTATED, options.rotated, {
    	              once: true
    	            });
    	          }
    	          dispatchEvent(element, EVENT_ROTATED, {
    	            degree: degree,
    	            oldDegree: oldDegree
    	          }, {
    	            cancelable: false
    	          });
    	        });
    	      }
    	      return this;
    	    },
    	    /**
    	     * Scale the image on the x-axis.
    	     * @param {number} scaleX - The scale ratio on the x-axis.
    	     * @returns {Viewer} this
    	     */
    	    scaleX: function scaleX(_scaleX) {
    	      this.scale(_scaleX, this.imageData.scaleY);
    	      return this;
    	    },
    	    /**
    	     * Scale the image on the y-axis.
    	     * @param {number} scaleY - The scale ratio on the y-axis.
    	     * @returns {Viewer} this
    	     */
    	    scaleY: function scaleY(_scaleY) {
    	      this.scale(this.imageData.scaleX, _scaleY);
    	      return this;
    	    },
    	    /**
    	     * Scale the image.
    	     * @param {number} scaleX - The scale ratio on the x-axis.
    	     * @param {number} [scaleY=scaleX] - The scale ratio on the y-axis.
    	     * @returns {Viewer} this
    	     */
    	    scale: function scale(scaleX) {
    	      var _this5 = this;
    	      var scaleY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : scaleX;
    	      var element = this.element,
    	        options = this.options,
    	        imageData = this.imageData;
    	      scaleX = Number(scaleX);
    	      scaleY = Number(scaleY);
    	      if (this.viewed && !this.played && options.scalable) {
    	        var oldScaleX = imageData.scaleX;
    	        var oldScaleY = imageData.scaleY;
    	        var changed = false;
    	        if (isNumber(scaleX)) {
    	          changed = true;
    	        } else {
    	          scaleX = oldScaleX;
    	        }
    	        if (isNumber(scaleY)) {
    	          changed = true;
    	        } else {
    	          scaleY = oldScaleY;
    	        }
    	        if (changed) {
    	          if (isFunction(options.scale)) {
    	            addListener(element, EVENT_SCALE, options.scale, {
    	              once: true
    	            });
    	          }
    	          if (dispatchEvent(element, EVENT_SCALE, {
    	            scaleX: scaleX,
    	            scaleY: scaleY,
    	            oldScaleX: oldScaleX,
    	            oldScaleY: oldScaleY
    	          }) === false) {
    	            return this;
    	          }
    	          imageData.scaleX = scaleX;
    	          imageData.scaleY = scaleY;
    	          this.scaling = true;
    	          this.renderImage(function () {
    	            _this5.scaling = false;
    	            if (isFunction(options.scaled)) {
    	              addListener(element, EVENT_SCALED, options.scaled, {
    	                once: true
    	              });
    	            }
    	            dispatchEvent(element, EVENT_SCALED, {
    	              scaleX: scaleX,
    	              scaleY: scaleY,
    	              oldScaleX: oldScaleX,
    	              oldScaleY: oldScaleY
    	            }, {
    	              cancelable: false
    	            });
    	          });
    	        }
    	      }
    	      return this;
    	    },
    	    /**
    	     * Zoom the image with a relative ratio.
    	     * @param {number} ratio - The target ratio.
    	     * @param {boolean} [showTooltip=false] - Indicates whether to show the tooltip.
    	     * @param {Object} [pivot] - The pivot point coordinate for zooming.
    	     * @param {Event} [_originalEvent=null] - The original event if any.
    	     * @returns {Viewer} this
    	     */
    	    zoom: function zoom(ratio) {
    	      var showTooltip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    	      var pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    	      var _originalEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    	      var imageData = this.imageData;
    	      ratio = Number(ratio);
    	      if (ratio < 0) {
    	        ratio = 1 / (1 - ratio);
    	      } else {
    	        ratio = 1 + ratio;
    	      }
    	      this.zoomTo(imageData.width * ratio / imageData.naturalWidth, showTooltip, pivot, _originalEvent);
    	      return this;
    	    },
    	    /**
    	     * Zoom the image to an absolute ratio.
    	     * @param {number} ratio - The target ratio.
    	     * @param {boolean} [showTooltip] - Indicates whether to show the tooltip.
    	     * @param {Object} [pivot] - The pivot point coordinate for zooming.
    	     * @param {Event} [_originalEvent=null] - The original event if any.
    	     * @param {Event} [_zoomable=false] - Indicates if the current zoom is available or not.
    	     * @returns {Viewer} this
    	     */
    	    zoomTo: function zoomTo(ratio) {
    	      var _this6 = this;
    	      var showTooltip = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    	      var pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    	      var _originalEvent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    	      var _zoomable = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    	      var element = this.element,
    	        options = this.options,
    	        pointers = this.pointers,
    	        imageData = this.imageData;
    	      var x = imageData.x,
    	        y = imageData.y,
    	        width = imageData.width,
    	        height = imageData.height,
    	        naturalWidth = imageData.naturalWidth,
    	        naturalHeight = imageData.naturalHeight;
    	      ratio = Math.max(0, ratio);
    	      if (isNumber(ratio) && this.viewed && !this.played && (_zoomable || options.zoomable)) {
    	        if (!_zoomable) {
    	          var minZoomRatio = Math.max(0.01, options.minZoomRatio);
    	          var maxZoomRatio = Math.min(100, options.maxZoomRatio);
    	          ratio = Math.min(Math.max(ratio, minZoomRatio), maxZoomRatio);
    	        }
    	        if (_originalEvent) {
    	          switch (_originalEvent.type) {
    	            case 'wheel':
    	              if (options.zoomRatio >= 0.055 && ratio > 0.95 && ratio < 1.05) {
    	                ratio = 1;
    	              }
    	              break;
    	            case 'pointermove':
    	            case 'touchmove':
    	            case 'mousemove':
    	              if (ratio > 0.99 && ratio < 1.01) {
    	                ratio = 1;
    	              }
    	              break;
    	          }
    	        }
    	        var newWidth = naturalWidth * ratio;
    	        var newHeight = naturalHeight * ratio;
    	        var offsetWidth = newWidth - width;
    	        var offsetHeight = newHeight - height;
    	        var oldRatio = imageData.ratio;
    	        if (isFunction(options.zoom)) {
    	          addListener(element, EVENT_ZOOM, options.zoom, {
    	            once: true
    	          });
    	        }
    	        if (dispatchEvent(element, EVENT_ZOOM, {
    	          ratio: ratio,
    	          oldRatio: oldRatio,
    	          originalEvent: _originalEvent
    	        }) === false) {
    	          return this;
    	        }
    	        this.zooming = true;
    	        if (_originalEvent) {
    	          var offset = getOffset(this.viewer);
    	          var center = pointers && Object.keys(pointers).length > 0 ? getPointersCenter(pointers) : {
    	            pageX: _originalEvent.pageX,
    	            pageY: _originalEvent.pageY
    	          };

    	          // Zoom from the triggering point of the event
    	          imageData.x -= offsetWidth * ((center.pageX - offset.left - x) / width);
    	          imageData.y -= offsetHeight * ((center.pageY - offset.top - y) / height);
    	        } else if (isPlainObject(pivot) && isNumber(pivot.x) && isNumber(pivot.y)) {
    	          imageData.x -= offsetWidth * ((pivot.x - x) / width);
    	          imageData.y -= offsetHeight * ((pivot.y - y) / height);
    	        } else {
    	          // Zoom from the center of the image
    	          imageData.x -= offsetWidth / 2;
    	          imageData.y -= offsetHeight / 2;
    	        }
    	        imageData.left = imageData.x;
    	        imageData.top = imageData.y;
    	        imageData.width = newWidth;
    	        imageData.height = newHeight;
    	        imageData.oldRatio = oldRatio;
    	        imageData.ratio = ratio;
    	        this.renderImage(function () {
    	          _this6.zooming = false;
    	          if (isFunction(options.zoomed)) {
    	            addListener(element, EVENT_ZOOMED, options.zoomed, {
    	              once: true
    	            });
    	          }
    	          dispatchEvent(element, EVENT_ZOOMED, {
    	            ratio: ratio,
    	            oldRatio: oldRatio,
    	            originalEvent: _originalEvent
    	          }, {
    	            cancelable: false
    	          });
    	        });
    	        if (showTooltip) {
    	          this.tooltip();
    	        }
    	      }
    	      return this;
    	    },
    	    /**
    	     * Play the images
    	     * @param {boolean|FullscreenOptions} [fullscreen=false] - Indicate if request fullscreen or not.
    	     * @returns {Viewer} this
    	     */
    	    play: function play() {
    	      var _this7 = this;
    	      var fullscreen = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    	      if (!this.isShown || this.played) {
    	        return this;
    	      }
    	      var element = this.element,
    	        options = this.options;
    	      if (isFunction(options.play)) {
    	        addListener(element, EVENT_PLAY, options.play, {
    	          once: true
    	        });
    	      }
    	      if (dispatchEvent(element, EVENT_PLAY) === false) {
    	        return this;
    	      }
    	      var player = this.player;
    	      var onLoad = this.loadImage.bind(this);
    	      var list = [];
    	      var total = 0;
    	      var index = 0;
    	      this.played = true;
    	      this.onLoadWhenPlay = onLoad;
    	      if (fullscreen) {
    	        this.requestFullscreen(fullscreen);
    	      }
    	      addClass(player, CLASS_SHOW);
    	      forEach(this.items, function (item, i) {
    	        var img = item.querySelector('img');
    	        var image = document.createElement('img');
    	        image.src = getData(img, 'originalUrl');
    	        image.alt = img.getAttribute('alt');
    	        image.referrerPolicy = img.referrerPolicy;
    	        total += 1;
    	        addClass(image, CLASS_FADE);
    	        toggleClass(image, CLASS_TRANSITION, options.transition);
    	        if (hasClass(item, CLASS_ACTIVE)) {
    	          addClass(image, CLASS_IN);
    	          index = i;
    	        }
    	        list.push(image);
    	        addListener(image, EVENT_LOAD, onLoad, {
    	          once: true
    	        });
    	        player.appendChild(image);
    	      });
    	      if (isNumber(options.interval) && options.interval > 0) {
    	        var prev = function prev() {
    	          clearTimeout(_this7.playing.timeout);
    	          removeClass(list[index], CLASS_IN);
    	          index -= 1;
    	          index = index >= 0 ? index : total - 1;
    	          addClass(list[index], CLASS_IN);
    	          _this7.playing.timeout = setTimeout(prev, options.interval);
    	        };
    	        var next = function next() {
    	          clearTimeout(_this7.playing.timeout);
    	          removeClass(list[index], CLASS_IN);
    	          index += 1;
    	          index = index < total ? index : 0;
    	          addClass(list[index], CLASS_IN);
    	          _this7.playing.timeout = setTimeout(next, options.interval);
    	        };
    	        if (total > 1) {
    	          this.playing = {
    	            prev: prev,
    	            next: next,
    	            timeout: setTimeout(next, options.interval)
    	          };
    	        }
    	      }
    	      return this;
    	    },
    	    // Stop play
    	    stop: function stop() {
    	      var _this8 = this;
    	      if (!this.played) {
    	        return this;
    	      }
    	      var element = this.element,
    	        options = this.options;
    	      if (isFunction(options.stop)) {
    	        addListener(element, EVENT_STOP, options.stop, {
    	          once: true
    	        });
    	      }
    	      if (dispatchEvent(element, EVENT_STOP) === false) {
    	        return this;
    	      }
    	      var player = this.player;
    	      clearTimeout(this.playing.timeout);
    	      this.playing = false;
    	      this.played = false;
    	      forEach(player.getElementsByTagName('img'), function (image) {
    	        removeListener(image, EVENT_LOAD, _this8.onLoadWhenPlay);
    	      });
    	      removeClass(player, CLASS_SHOW);
    	      player.innerHTML = '';
    	      this.exitFullscreen();
    	      return this;
    	    },
    	    // Enter modal mode (only available in inline mode)
    	    full: function full() {
    	      var _this9 = this;
    	      var options = this.options,
    	        viewer = this.viewer,
    	        image = this.image,
    	        list = this.list;
    	      if (!this.isShown || this.played || this.fulled || !options.inline) {
    	        return this;
    	      }
    	      this.fulled = true;
    	      this.open();
    	      addClass(this.button, CLASS_FULLSCREEN_EXIT);
    	      if (options.transition) {
    	        removeClass(list, CLASS_TRANSITION);
    	        if (this.viewed) {
    	          removeClass(image, CLASS_TRANSITION);
    	        }
    	      }
    	      addClass(viewer, CLASS_FIXED);
    	      viewer.setAttribute('role', 'dialog');
    	      viewer.setAttribute('aria-labelledby', this.title.id);
    	      viewer.setAttribute('aria-modal', true);
    	      viewer.removeAttribute('style');
    	      setStyle(viewer, {
    	        zIndex: options.zIndex
    	      });
    	      if (options.focus) {
    	        this.enforceFocus();
    	      }
    	      this.initContainer();
    	      this.viewerData = assign({}, this.containerData);
    	      this.renderList();
    	      if (this.viewed) {
    	        this.initImage(function () {
    	          _this9.renderImage(function () {
    	            if (options.transition) {
    	              setTimeout(function () {
    	                addClass(image, CLASS_TRANSITION);
    	                addClass(list, CLASS_TRANSITION);
    	              }, 0);
    	            }
    	          });
    	        });
    	      }
    	      return this;
    	    },
    	    // Exit modal mode (only available in inline mode)
    	    exit: function exit() {
    	      var _this10 = this;
    	      var options = this.options,
    	        viewer = this.viewer,
    	        image = this.image,
    	        list = this.list;
    	      if (!this.isShown || this.played || !this.fulled || !options.inline) {
    	        return this;
    	      }
    	      this.fulled = false;
    	      this.close();
    	      removeClass(this.button, CLASS_FULLSCREEN_EXIT);
    	      if (options.transition) {
    	        removeClass(list, CLASS_TRANSITION);
    	        if (this.viewed) {
    	          removeClass(image, CLASS_TRANSITION);
    	        }
    	      }
    	      if (options.focus) {
    	        this.clearEnforceFocus();
    	      }
    	      viewer.removeAttribute('role');
    	      viewer.removeAttribute('aria-labelledby');
    	      viewer.removeAttribute('aria-modal');
    	      removeClass(viewer, CLASS_FIXED);
    	      setStyle(viewer, {
    	        zIndex: options.zIndexInline
    	      });
    	      this.viewerData = assign({}, this.parentData);
    	      this.renderViewer();
    	      this.renderList();
    	      if (this.viewed) {
    	        this.initImage(function () {
    	          _this10.renderImage(function () {
    	            if (options.transition) {
    	              setTimeout(function () {
    	                addClass(image, CLASS_TRANSITION);
    	                addClass(list, CLASS_TRANSITION);
    	              }, 0);
    	            }
    	          });
    	        });
    	      }
    	      return this;
    	    },
    	    // Show the current ratio of the image with percentage
    	    tooltip: function tooltip() {
    	      var _this11 = this;
    	      var options = this.options,
    	        tooltipBox = this.tooltipBox,
    	        imageData = this.imageData;
    	      if (!this.viewed || this.played || !options.tooltip) {
    	        return this;
    	      }
    	      tooltipBox.textContent = "".concat(Math.round(imageData.ratio * 100), "%");
    	      if (!this.tooltipping) {
    	        if (options.transition) {
    	          if (this.fading) {
    	            dispatchEvent(tooltipBox, EVENT_TRANSITION_END);
    	          }
    	          addClass(tooltipBox, CLASS_SHOW);
    	          addClass(tooltipBox, CLASS_FADE);
    	          addClass(tooltipBox, CLASS_TRANSITION);
    	          tooltipBox.removeAttribute('aria-hidden');

    	          // Force reflow to enable CSS3 transition
    	          tooltipBox.initialOffsetWidth = tooltipBox.offsetWidth;
    	          addClass(tooltipBox, CLASS_IN);
    	        } else {
    	          addClass(tooltipBox, CLASS_SHOW);
    	          tooltipBox.removeAttribute('aria-hidden');
    	        }
    	      } else {
    	        clearTimeout(this.tooltipping);
    	      }
    	      this.tooltipping = setTimeout(function () {
    	        if (options.transition) {
    	          addListener(tooltipBox, EVENT_TRANSITION_END, function () {
    	            removeClass(tooltipBox, CLASS_SHOW);
    	            removeClass(tooltipBox, CLASS_FADE);
    	            removeClass(tooltipBox, CLASS_TRANSITION);
    	            tooltipBox.setAttribute('aria-hidden', true);
    	            _this11.fading = false;
    	          }, {
    	            once: true
    	          });
    	          removeClass(tooltipBox, CLASS_IN);
    	          _this11.fading = true;
    	        } else {
    	          removeClass(tooltipBox, CLASS_SHOW);
    	          tooltipBox.setAttribute('aria-hidden', true);
    	        }
    	        _this11.tooltipping = false;
    	      }, 1000);
    	      return this;
    	    },
    	    /**
    	     * Toggle the image size between its current size and natural size
    	     * @param {Event} [_originalEvent=null] - The original event if any.
    	     * @returns {Viewer} this
    	     */
    	    toggle: function toggle() {
    	      var _originalEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    	      if (this.imageData.ratio === 1) {
    	        this.zoomTo(this.imageData.oldRatio, true, null, _originalEvent);
    	      } else {
    	        this.zoomTo(1, true, null, _originalEvent);
    	      }
    	      return this;
    	    },
    	    // Reset the image to its initial state
    	    reset: function reset() {
    	      if (this.viewed && !this.played) {
    	        this.imageData = assign({}, this.initialImageData);
    	        this.renderImage();
    	      }
    	      return this;
    	    },
    	    // Update viewer when images changed
    	    update: function update() {
    	      var _this12 = this;
    	      var element = this.element,
    	        options = this.options,
    	        isImg = this.isImg;

    	      // Destroy viewer if the target image was deleted
    	      if (isImg && !element.parentNode) {
    	        return this.destroy();
    	      }
    	      var images = [];
    	      forEach(isImg ? [element] : element.querySelectorAll('img'), function (image) {
    	        if (isFunction(options.filter)) {
    	          if (options.filter.call(_this12, image)) {
    	            images.push(image);
    	          }
    	        } else if (_this12.getImageURL(image)) {
    	          images.push(image);
    	        }
    	      });
    	      if (!images.length) {
    	        return this;
    	      }
    	      this.images = images;
    	      this.length = images.length;
    	      if (this.ready) {
    	        var changedIndexes = [];
    	        forEach(this.items, function (item, i) {
    	          var img = item.querySelector('img');
    	          var image = images[i];
    	          if (image && img) {
    	            if (image.src !== img.src

    	            // Title changed (#408)
    	            || image.alt !== img.alt) {
    	              changedIndexes.push(i);
    	            }
    	          } else {
    	            changedIndexes.push(i);
    	          }
    	        });
    	        setStyle(this.list, {
    	          width: 'auto'
    	        });
    	        this.initList();
    	        if (this.isShown) {
    	          if (this.length) {
    	            if (this.viewed) {
    	              var changedIndex = changedIndexes.indexOf(this.index);
    	              if (changedIndex >= 0) {
    	                this.viewed = false;
    	                this.view(Math.max(Math.min(this.index - changedIndex, this.length - 1), 0));
    	              } else {
    	                var activeItem = this.items[this.index];

    	                // Reactivate the current viewing item after reset the list.
    	                addClass(activeItem, CLASS_ACTIVE);
    	                activeItem.setAttribute('aria-selected', true);
    	              }
    	            }
    	          } else {
    	            this.image = null;
    	            this.viewed = false;
    	            this.index = 0;
    	            this.imageData = {};
    	            this.canvas.innerHTML = '';
    	            this.title.innerHTML = '';
    	          }
    	        }
    	      } else {
    	        this.build();
    	      }
    	      return this;
    	    },
    	    // Destroy the viewer
    	    destroy: function destroy() {
    	      var element = this.element,
    	        options = this.options;
    	      if (!element[NAMESPACE]) {
    	        return this;
    	      }
    	      this.destroyed = true;
    	      if (this.ready) {
    	        if (this.played) {
    	          this.stop();
    	        }
    	        if (options.inline) {
    	          if (this.fulled) {
    	            this.exit();
    	          }
    	          this.unbind();
    	        } else if (this.isShown) {
    	          if (this.viewing) {
    	            if (this.imageRendering) {
    	              this.imageRendering.abort();
    	            } else if (this.imageInitializing) {
    	              this.imageInitializing.abort();
    	            }
    	          }
    	          if (this.hiding) {
    	            this.transitioning.abort();
    	          }
    	          this.hidden();
    	        } else if (this.showing) {
    	          this.transitioning.abort();
    	          this.hidden();
    	        }
    	        this.ready = false;
    	        this.viewer.parentNode.removeChild(this.viewer);
    	      } else if (options.inline) {
    	        if (this.delaying) {
    	          this.delaying.abort();
    	        } else if (this.initializing) {
    	          this.initializing.abort();
    	        }
    	      }
    	      if (!options.inline) {
    	        removeListener(element, EVENT_CLICK, this.onStart);
    	      }
    	      element[NAMESPACE] = undefined;
    	      return this;
    	    }
    	  };

    	  var others = {
    	    getImageURL: function getImageURL(image) {
    	      var url = this.options.url;
    	      if (isString(url)) {
    	        url = image.getAttribute(url);
    	      } else if (isFunction(url)) {
    	        url = url.call(this, image);
    	      } else {
    	        url = '';
    	      }
    	      return url;
    	    },
    	    enforceFocus: function enforceFocus() {
    	      var _this = this;
    	      this.clearEnforceFocus();
    	      addListener(document, EVENT_FOCUSIN, this.onFocusin = function (event) {
    	        var viewer = _this.viewer;
    	        var target = event.target;
    	        if (target === document || target === viewer || viewer.contains(target)) {
    	          return;
    	        }
    	        while (target) {
    	          // Avoid conflicts with other modals (#474, #540)
    	          if (target.getAttribute('tabindex') !== null || target.getAttribute('aria-modal') === 'true') {
    	            return;
    	          }
    	          target = target.parentElement;
    	        }
    	        viewer.focus();
    	      });
    	    },
    	    clearEnforceFocus: function clearEnforceFocus() {
    	      if (this.onFocusin) {
    	        removeListener(document, EVENT_FOCUSIN, this.onFocusin);
    	        this.onFocusin = null;
    	      }
    	    },
    	    open: function open() {
    	      var body = this.body;
    	      addClass(body, CLASS_OPEN);
    	      if (this.scrollbarWidth > 0) {
    	        body.style.paddingRight = "".concat(this.scrollbarWidth + (parseFloat(this.initialBodyComputedPaddingRight) || 0), "px");
    	      }
    	    },
    	    close: function close() {
    	      var body = this.body;
    	      removeClass(body, CLASS_OPEN);
    	      if (this.scrollbarWidth > 0) {
    	        body.style.paddingRight = this.initialBodyPaddingRight;
    	      }
    	    },
    	    shown: function shown() {
    	      var element = this.element,
    	        options = this.options,
    	        viewer = this.viewer;
    	      this.fulled = true;
    	      this.isShown = true;
    	      this.render();
    	      this.bind();
    	      this.showing = false;
    	      if (options.focus) {
    	        viewer.focus();
    	        this.enforceFocus();
    	      }
    	      if (isFunction(options.shown)) {
    	        addListener(element, EVENT_SHOWN, options.shown, {
    	          once: true
    	        });
    	      }
    	      if (dispatchEvent(element, EVENT_SHOWN) === false) {
    	        return;
    	      }
    	      if (this.ready && this.isShown && !this.hiding) {
    	        this.view(this.index);
    	      }
    	    },
    	    hidden: function hidden() {
    	      var element = this.element,
    	        options = this.options,
    	        viewer = this.viewer;
    	      if (options.fucus) {
    	        this.clearEnforceFocus();
    	      }
    	      this.close();
    	      this.unbind();
    	      addClass(viewer, CLASS_HIDE);
    	      viewer.removeAttribute('role');
    	      viewer.removeAttribute('aria-labelledby');
    	      viewer.removeAttribute('aria-modal');
    	      viewer.setAttribute('aria-hidden', true);
    	      this.resetList();
    	      this.resetImage();
    	      this.fulled = false;
    	      this.viewed = false;
    	      this.isShown = false;
    	      this.hiding = false;
    	      if (!this.destroyed) {
    	        if (isFunction(options.hidden)) {
    	          addListener(element, EVENT_HIDDEN, options.hidden, {
    	            once: true
    	          });
    	        }
    	        dispatchEvent(element, EVENT_HIDDEN, null, {
    	          cancelable: false
    	        });
    	      }
    	    },
    	    requestFullscreen: function requestFullscreen(options) {
    	      var document = this.element.ownerDocument;
    	      if (this.fulled && !(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
    	        var documentElement = document.documentElement;

    	        // Element.requestFullscreen()
    	        if (documentElement.requestFullscreen) {
    	          // Avoid TypeError when convert `options` to dictionary
    	          if (isPlainObject(options)) {
    	            documentElement.requestFullscreen(options);
    	          } else {
    	            documentElement.requestFullscreen();
    	          }
    	        } else if (documentElement.webkitRequestFullscreen) {
    	          documentElement.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT);
    	        } else if (documentElement.mozRequestFullScreen) {
    	          documentElement.mozRequestFullScreen();
    	        } else if (documentElement.msRequestFullscreen) {
    	          documentElement.msRequestFullscreen();
    	        }
    	      }
    	    },
    	    exitFullscreen: function exitFullscreen() {
    	      var document = this.element.ownerDocument;
    	      if (this.fulled && (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)) {
    	        // Document.exitFullscreen()
    	        if (document.exitFullscreen) {
    	          document.exitFullscreen();
    	        } else if (document.webkitExitFullscreen) {
    	          document.webkitExitFullscreen();
    	        } else if (document.mozCancelFullScreen) {
    	          document.mozCancelFullScreen();
    	        } else if (document.msExitFullscreen) {
    	          document.msExitFullscreen();
    	        }
    	      }
    	    },
    	    change: function change(event) {
    	      var options = this.options,
    	        pointers = this.pointers;
    	      var pointer = pointers[Object.keys(pointers)[0]];

    	      // In the case of the `pointers` object is empty (#421)
    	      if (!pointer) {
    	        return;
    	      }
    	      var offsetX = pointer.endX - pointer.startX;
    	      var offsetY = pointer.endY - pointer.startY;
    	      switch (this.action) {
    	        // Move the current image
    	        case ACTION_MOVE:
    	          if (offsetX !== 0 || offsetY !== 0) {
    	            this.pointerMoved = true;
    	            this.move(offsetX, offsetY, event);
    	          }
    	          break;

    	        // Zoom the current image
    	        case ACTION_ZOOM:
    	          this.zoom(getMaxZoomRatio(pointers), false, null, event);
    	          break;
    	        case ACTION_SWITCH:
    	          {
    	            this.action = 'switched';
    	            var absoluteOffsetX = Math.abs(offsetX);
    	            if (absoluteOffsetX > 1 && absoluteOffsetX > Math.abs(offsetY)) {
    	              // Empty `pointers` as `touchend` event will not be fired after swiped in iOS browsers.
    	              this.pointers = {};
    	              if (offsetX > 1) {
    	                this.prev(options.loop);
    	              } else if (offsetX < -1) {
    	                this.next(options.loop);
    	              }
    	            }
    	            break;
    	          }
    	      }

    	      // Override
    	      forEach(pointers, function (p) {
    	        p.startX = p.endX;
    	        p.startY = p.endY;
    	      });
    	    },
    	    isSwitchable: function isSwitchable() {
    	      var imageData = this.imageData,
    	        viewerData = this.viewerData;
    	      return this.length > 1 && imageData.x >= 0 && imageData.y >= 0 && imageData.width <= viewerData.width && imageData.height <= viewerData.height;
    	    }
    	  };

    	  var AnotherViewer = WINDOW.Viewer;
    	  var getUniqueID = function (id) {
    	    return function () {
    	      id += 1;
    	      return id;
    	    };
    	  }(-1);
    	  var Viewer = /*#__PURE__*/function () {
    	    /**
    	     * Create a new Viewer.
    	     * @param {Element} element - The target element for viewing.
    	     * @param {Object} [options={}] - The configuration options.
    	     */
    	    function Viewer(element) {
    	      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    	      _classCallCheck(this, Viewer);
    	      if (!element || element.nodeType !== 1) {
    	        throw new Error('The first argument is required and must be an element.');
    	      }
    	      this.element = element;
    	      this.options = assign({}, DEFAULTS, isPlainObject(options) && options);
    	      this.action = false;
    	      this.fading = false;
    	      this.fulled = false;
    	      this.hiding = false;
    	      this.imageClicked = false;
    	      this.imageData = {};
    	      this.index = this.options.initialViewIndex;
    	      this.isImg = false;
    	      this.isShown = false;
    	      this.length = 0;
    	      this.moving = false;
    	      this.played = false;
    	      this.playing = false;
    	      this.pointers = {};
    	      this.ready = false;
    	      this.rotating = false;
    	      this.scaling = false;
    	      this.showing = false;
    	      this.timeout = false;
    	      this.tooltipping = false;
    	      this.viewed = false;
    	      this.viewing = false;
    	      this.wheeling = false;
    	      this.zooming = false;
    	      this.pointerMoved = false;
    	      this.id = getUniqueID();
    	      this.init();
    	    }
    	    _createClass(Viewer, [{
    	      key: "init",
    	      value: function init() {
    	        var _this = this;
    	        var element = this.element,
    	          options = this.options;
    	        if (element[NAMESPACE]) {
    	          return;
    	        }
    	        element[NAMESPACE] = this;

    	        // The `focus` option requires the `keyboard` option set to `true`.
    	        if (options.focus && !options.keyboard) {
    	          options.focus = false;
    	        }
    	        var isImg = element.localName === 'img';
    	        var images = [];
    	        forEach(isImg ? [element] : element.querySelectorAll('img'), function (image) {
    	          if (isFunction(options.filter)) {
    	            if (options.filter.call(_this, image)) {
    	              images.push(image);
    	            }
    	          } else if (_this.getImageURL(image)) {
    	            images.push(image);
    	          }
    	        });
    	        this.isImg = isImg;
    	        this.length = images.length;
    	        this.images = images;
    	        this.initBody();

    	        // Override `transition` option if it is not supported
    	        if (isUndefined(document.createElement(NAMESPACE).style.transition)) {
    	          options.transition = false;
    	        }
    	        if (options.inline) {
    	          var count = 0;
    	          var progress = function progress() {
    	            count += 1;
    	            if (count === _this.length) {
    	              var timeout;
    	              _this.initializing = false;
    	              _this.delaying = {
    	                abort: function abort() {
    	                  clearTimeout(timeout);
    	                }
    	              };

    	              // build asynchronously to keep `this.viewer` is accessible in `ready` event handler.
    	              timeout = setTimeout(function () {
    	                _this.delaying = false;
    	                _this.build();
    	              }, 0);
    	            }
    	          };
    	          this.initializing = {
    	            abort: function abort() {
    	              forEach(images, function (image) {
    	                if (!image.complete) {
    	                  removeListener(image, EVENT_LOAD, progress);
    	                  removeListener(image, EVENT_ERROR, progress);
    	                }
    	              });
    	            }
    	          };
    	          forEach(images, function (image) {
    	            if (image.complete) {
    	              progress();
    	            } else {
    	              var onLoad;
    	              var onError;
    	              addListener(image, EVENT_LOAD, onLoad = function onLoad() {
    	                removeListener(image, EVENT_ERROR, onError);
    	                progress();
    	              }, {
    	                once: true
    	              });
    	              addListener(image, EVENT_ERROR, onError = function onError() {
    	                removeListener(image, EVENT_LOAD, onLoad);
    	                progress();
    	              }, {
    	                once: true
    	              });
    	            }
    	          });
    	        } else {
    	          addListener(element, EVENT_CLICK, this.onStart = function (_ref) {
    	            var target = _ref.target;
    	            if (target.localName === 'img' && (!isFunction(options.filter) || options.filter.call(_this, target))) {
    	              _this.view(_this.images.indexOf(target));
    	            }
    	          });
    	        }
    	      }
    	    }, {
    	      key: "build",
    	      value: function build() {
    	        if (this.ready) {
    	          return;
    	        }
    	        var element = this.element,
    	          options = this.options;
    	        var parent = element.parentNode;
    	        var template = document.createElement('div');
    	        template.innerHTML = TEMPLATE;
    	        var viewer = template.querySelector(".".concat(NAMESPACE, "-container"));
    	        var title = viewer.querySelector(".".concat(NAMESPACE, "-title"));
    	        var toolbar = viewer.querySelector(".".concat(NAMESPACE, "-toolbar"));
    	        var navbar = viewer.querySelector(".".concat(NAMESPACE, "-navbar"));
    	        var button = viewer.querySelector(".".concat(NAMESPACE, "-button"));
    	        var canvas = viewer.querySelector(".".concat(NAMESPACE, "-canvas"));
    	        this.parent = parent;
    	        this.viewer = viewer;
    	        this.title = title;
    	        this.toolbar = toolbar;
    	        this.navbar = navbar;
    	        this.button = button;
    	        this.canvas = canvas;
    	        this.footer = viewer.querySelector(".".concat(NAMESPACE, "-footer"));
    	        this.tooltipBox = viewer.querySelector(".".concat(NAMESPACE, "-tooltip"));
    	        this.player = viewer.querySelector(".".concat(NAMESPACE, "-player"));
    	        this.list = viewer.querySelector(".".concat(NAMESPACE, "-list"));
    	        viewer.id = "".concat(NAMESPACE).concat(this.id);
    	        title.id = "".concat(NAMESPACE, "Title").concat(this.id);
    	        addClass(title, !options.title ? CLASS_HIDE : getResponsiveClass(Array.isArray(options.title) ? options.title[0] : options.title));
    	        addClass(navbar, !options.navbar ? CLASS_HIDE : getResponsiveClass(options.navbar));
    	        toggleClass(button, CLASS_HIDE, !options.button);
    	        if (options.keyboard) {
    	          button.setAttribute('tabindex', 0);
    	        }
    	        if (options.backdrop) {
    	          addClass(viewer, "".concat(NAMESPACE, "-backdrop"));
    	          if (!options.inline && options.backdrop !== 'static') {
    	            setData(canvas, DATA_ACTION, 'hide');
    	          }
    	        }
    	        if (isString(options.className) && options.className) {
    	          // In case there are multiple class names
    	          options.className.split(REGEXP_SPACES).forEach(function (className) {
    	            addClass(viewer, className);
    	          });
    	        }
    	        if (options.toolbar) {
    	          var list = document.createElement('ul');
    	          var custom = isPlainObject(options.toolbar);
    	          var zoomButtons = BUTTONS.slice(0, 3);
    	          var rotateButtons = BUTTONS.slice(7, 9);
    	          var scaleButtons = BUTTONS.slice(9);
    	          if (!custom) {
    	            addClass(toolbar, getResponsiveClass(options.toolbar));
    	          }
    	          forEach(custom ? options.toolbar : BUTTONS, function (value, index) {
    	            var deep = custom && isPlainObject(value);
    	            var name = custom ? hyphenate(index) : value;
    	            var show = deep && !isUndefined(value.show) ? value.show : value;
    	            if (!show || !options.zoomable && zoomButtons.indexOf(name) !== -1 || !options.rotatable && rotateButtons.indexOf(name) !== -1 || !options.scalable && scaleButtons.indexOf(name) !== -1) {
    	              return;
    	            }
    	            var size = deep && !isUndefined(value.size) ? value.size : value;
    	            var click = deep && !isUndefined(value.click) ? value.click : value;
    	            var item = document.createElement('li');
    	            if (options.keyboard) {
    	              item.setAttribute('tabindex', 0);
    	            }
    	            item.setAttribute('role', 'button');
    	            addClass(item, "".concat(NAMESPACE, "-").concat(name));
    	            if (!isFunction(click)) {
    	              setData(item, DATA_ACTION, name);
    	            }
    	            if (isNumber(show)) {
    	              addClass(item, getResponsiveClass(show));
    	            }
    	            if (['small', 'large'].indexOf(size) !== -1) {
    	              addClass(item, "".concat(NAMESPACE, "-").concat(size));
    	            } else if (name === 'play') {
    	              addClass(item, "".concat(NAMESPACE, "-large"));
    	            }
    	            if (isFunction(click)) {
    	              addListener(item, EVENT_CLICK, click);
    	            }
    	            list.appendChild(item);
    	          });
    	          toolbar.appendChild(list);
    	        } else {
    	          addClass(toolbar, CLASS_HIDE);
    	        }
    	        if (!options.rotatable) {
    	          var rotates = toolbar.querySelectorAll('li[class*="rotate"]');
    	          addClass(rotates, CLASS_INVISIBLE);
    	          forEach(rotates, function (rotate) {
    	            toolbar.appendChild(rotate);
    	          });
    	        }
    	        if (options.inline) {
    	          addClass(button, CLASS_FULLSCREEN);
    	          setStyle(viewer, {
    	            zIndex: options.zIndexInline
    	          });
    	          if (window.getComputedStyle(parent).position === 'static') {
    	            setStyle(parent, {
    	              position: 'relative'
    	            });
    	          }
    	          parent.insertBefore(viewer, element.nextSibling);
    	        } else {
    	          addClass(button, CLASS_CLOSE);
    	          addClass(viewer, CLASS_FIXED);
    	          addClass(viewer, CLASS_FADE);
    	          addClass(viewer, CLASS_HIDE);
    	          setStyle(viewer, {
    	            zIndex: options.zIndex
    	          });
    	          var container = options.container;
    	          if (isString(container)) {
    	            container = element.ownerDocument.querySelector(container);
    	          }
    	          if (!container) {
    	            container = this.body;
    	          }
    	          container.appendChild(viewer);
    	        }
    	        if (options.inline) {
    	          this.render();
    	          this.bind();
    	          this.isShown = true;
    	        }
    	        this.ready = true;
    	        if (isFunction(options.ready)) {
    	          addListener(element, EVENT_READY, options.ready, {
    	            once: true
    	          });
    	        }
    	        if (dispatchEvent(element, EVENT_READY) === false) {
    	          this.ready = false;
    	          return;
    	        }
    	        if (this.ready && options.inline) {
    	          this.view(this.index);
    	        }
    	      }

    	      /**
    	       * Get the no conflict viewer class.
    	       * @returns {Viewer} The viewer class.
    	       */
    	    }], [{
    	      key: "noConflict",
    	      value: function noConflict() {
    	        window.Viewer = AnotherViewer;
    	        return Viewer;
    	      }

    	      /**
    	       * Change the default options.
    	       * @param {Object} options - The new default options.
    	       */
    	    }, {
    	      key: "setDefaults",
    	      value: function setDefaults(options) {
    	        assign(DEFAULTS, isPlainObject(options) && options);
    	      }
    	    }]);
    	    return Viewer;
    	  }();
    	  assign(Viewer.prototype, render, events, handlers, methods, others);

    	  return Viewer;

    	})); 
    } (viewer));

    var viewerExports = viewer.exports;
    var Viewer = /*@__PURE__*/getDefaultExportFromCjs(viewerExports);

    /* srcReading\Imagearea\ImageArea.svelte generated by Svelte v3.59.2 */

    const { console: console_1$C } = globals;
    const file$1F = "srcReading\\Imagearea\\ImageArea.svelte";

    function get_each_context$z(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[12] = i;
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (66:2) {#if i==pageimagehere-1}
    function create_if_block$F(ctx) {
    	let each_1_anchor;
    	let each_value_1 = /*images*/ ctx[10];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$imageListTab*/ 2) {
    				each_value_1 = /*images*/ ctx[10];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$5(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$F.name,
    		type: "if",
    		source: "(66:2) {#if i==pageimagehere-1}",
    		ctx
    	});

    	return block;
    }

    // (67:4) {#each images as image}
    function create_each_block_1$5(ctx) {
    	let img;
    	let img_src_value;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[13])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "sdsd");
    			attr_dev(img, "class", "svelte-qy97ju");
    			add_location(img, file$1F, 67, 5, 1794);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$imageListTab*/ 2 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[13])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(67:4) {#each images as image}",
    		ctx
    	});

    	return block;
    }

    // (65:2) {#each $imageListTab as images,i}
    function create_each_block$z(ctx) {
    	let if_block_anchor;
    	let if_block = /*i*/ ctx[12] == /*pageimagehere*/ ctx[0] - 1 && create_if_block$F(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (/*i*/ ctx[12] == /*pageimagehere*/ ctx[0] - 1) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$F(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$z.name,
    		type: "each",
    		source: "(65:2) {#each $imageListTab as images,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1J(ctx) {
    	let div0;
    	let t;
    	let div1;
    	let each_value = /*$imageListTab*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$z(get_each_context$z(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "id", /*idhere*/ ctx[2]);
    			attr_dev(div0, "class", "idImageClass svelte-qy97ju");
    			add_location(div0, file$1F, 63, 0, 1655);
    			attr_dev(div1, "id", /*idcontai*/ ctx[3]);
    			attr_dev(div1, "class", "idcontainCLass svelte-qy97ju");
    			add_location(div1, file$1F, 73, 1, 1874);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			insert_dev(target, t, anchor);
    			insert_dev(target, div1, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$imageListTab, pageimagehere*/ 3) {
    				each_value = /*$imageListTab*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$z(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$z(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(div1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1J($$self, $$props, $$invalidate) {
    	let $onTabImage;
    	let $onTab;
    	let $imageListTab;
    	let $imageTF;
    	validate_store(onTabImage, 'onTabImage');
    	component_subscribe($$self, onTabImage, $$value => $$invalidate(7, $onTabImage = $$value));
    	validate_store(onTab, 'onTab');
    	component_subscribe($$self, onTab, $$value => $$invalidate(8, $onTab = $$value));
    	validate_store(imageListTab, 'imageListTab');
    	component_subscribe($$self, imageListTab, $$value => $$invalidate(1, $imageListTab = $$value));
    	validate_store(imageTF, 'imageTF');
    	component_subscribe($$self, imageTF, $$value => $$invalidate(9, $imageTF = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ImageArea', slots, []);
    	let { numpage } = $$props;
    	let idhere = "images" + ($onTab - 1).toString();
    	let idcontai = "contai" + ($onTab - 1).toString();
    	let viewer;
    	let pageimagehere;
    	let numImageTab;

    	onTab.subscribe(value => {
    		if (value - 1 == numpage) {
    			set_store_value(onTabImage, $onTabImage = pageimagehere, $onTabImage);
    			console.log($onTabImage, "wdrw");
    		}
    	});

    	onMount(() => {
    		set_store_value(imageTF, $imageTF = true, $imageTF);

    		imageListTab.update(value => {
    			let prev = [...value];
    			numImageTab = prev.length;
    			prev.push([]);
    			return prev;
    		});

    		$$invalidate(0, pageimagehere = $imageListTab.length);

    		viewer = new Viewer(document.getElementById(idhere),
    		{
    				inline: true,
    				ready() {
    					let ue = document.getElementsByClassName('viewer-container');

    					for (let element of ue) {
    						element.style.position = 'absolute';
    						element.style.top = '0';
    						element.style.left = '0';
    						element.style.right = '0';
    						element.style.bottom = '0';
    						element.style.display = 'flex';
    					}
    				}
    			});

    		document.getElementById(idcontai).appendChild(viewer.element);
    	});

    	afterUpdate(() => {
    		if ($onTab - 1 == numpage) {
    			set_store_value(onTabImage, $onTabImage = pageimagehere, $onTabImage);

    			imageListTab.subscribe(newList => {
    				viewer.update(newList[pageimagehere - 1].map(image => {
    					return { src: image };
    				}));
    			});
    		}
    	});

    	$$self.$$.on_mount.push(function () {
    		if (numpage === undefined && !('numpage' in $$props || $$self.$$.bound[$$self.$$.props['numpage']])) {
    			console_1$C.warn("<ImageArea> was created without expected prop 'numpage'");
    		}
    	});

    	const writable_props = ['numpage'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$C.warn(`<ImageArea> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('numpage' in $$props) $$invalidate(4, numpage = $$props.numpage);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		afterUpdate,
    		DisplayImageList,
    		imageListTab,
    		imageTF,
    		onTab,
    		onTabImage,
    		Viewer,
    		numpage,
    		idhere,
    		idcontai,
    		viewer,
    		pageimagehere,
    		numImageTab,
    		$onTabImage,
    		$onTab,
    		$imageListTab,
    		$imageTF
    	});

    	$$self.$inject_state = $$props => {
    		if ('numpage' in $$props) $$invalidate(4, numpage = $$props.numpage);
    		if ('idhere' in $$props) $$invalidate(2, idhere = $$props.idhere);
    		if ('idcontai' in $$props) $$invalidate(3, idcontai = $$props.idcontai);
    		if ('viewer' in $$props) viewer = $$props.viewer;
    		if ('pageimagehere' in $$props) $$invalidate(0, pageimagehere = $$props.pageimagehere);
    		if ('numImageTab' in $$props) numImageTab = $$props.numImageTab;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [pageimagehere, $imageListTab, idhere, idcontai, numpage];
    }

    class ImageArea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1J, create_fragment$1J, safe_not_equal, { numpage: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImageArea",
    			options,
    			id: create_fragment$1J.name
    		});
    	}

    	get numpage() {
    		throw new Error("<ImageArea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set numpage(value) {
    		throw new Error("<ImageArea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReading\TextWord\TextWord.svelte generated by Svelte v3.59.2 */

    const { console: console_1$B } = globals;

    const file$1E = "srcReading\\TextWord\\TextWord.svelte";

    function create_fragment$1I(ctx) {
    	let div;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "contenteditable", "true");
    			attr_dev(div, "id", /*pagenow*/ ctx[0]);
    			attr_dev(div, "class", "textwrite svelte-ipbryp");
    			attr_dev(div, "spellcheck", "false");
    			add_location(div, file$1E, 43, 0, 1412);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseup", /*TestSelection*/ ctx[1], false, false, false, false),
    					listen_dev(div, "mousedown", /*Delte*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1I($$self, $$props, $$invalidate) {
    	let $selectedTextForQuickTask;
    	let $selectedText;
    	let $coordinateMouse;
    	let $choseText;
    	let $onTab;
    	validate_store(selectedTextForQuickTask, 'selectedTextForQuickTask');
    	component_subscribe($$self, selectedTextForQuickTask, $$value => $$invalidate(5, $selectedTextForQuickTask = $$value));
    	validate_store(selectedText, 'selectedText');
    	component_subscribe($$self, selectedText, $$value => $$invalidate(6, $selectedText = $$value));
    	validate_store(coordinateMouse, 'coordinateMouse');
    	component_subscribe($$self, coordinateMouse, $$value => $$invalidate(7, $coordinateMouse = $$value));
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(8, $choseText = $$value));
    	validate_store(onTab, 'onTab');
    	component_subscribe($$self, onTab, $$value => $$invalidate(9, $onTab = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TextWord', slots, []);
    	let pagenow = 'textword' + ($onTab - 1).toString();

    	onMount(() => {
    		document.getElementById(pagenow).addEventListener("click", () => {
    			console.log(document.queryCommandValue("fontName"));
    			document.getElementById("font").value = document.queryCommandValue("fontName");
    			document.getElementById("size").value = document.queryCommandValue("fontSize");
    		});
    	});

    	let prevText = '';
    	let text = '';

    	function TestSelection(event) {
    		console.log("bug here");
    		prevText = text;
    		text = document.getSelection().toString();

    		//SỬ LÝ ĐẦU VÀO Ở ĐÂY
    		if (text != "" && text != prevText) {
    			console.log(text);
    			set_store_value(choseText, $choseText = text, $choseText);

    			coordinateMouse.update(() => {
    				console.log(event.clientX, event.clientY);
    				return [event.clientX, event.clientY];
    			});

    			console.log($coordinateMouse[0], $coordinateMouse[1]);
    			set_store_value(selectedTextForQuickTask, $selectedTextForQuickTask = true, $selectedTextForQuickTask);
    		} else {
    			set_store_value(selectedTextForQuickTask, $selectedTextForQuickTask = false, $selectedTextForQuickTask);
    			set_store_value(selectedText, $selectedText = false, $selectedText);
    		}
    	}

    	function Delte() {
    		set_store_value(selectedTextForQuickTask, $selectedTextForQuickTask = false, $selectedTextForQuickTask);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$B.warn(`<TextWord> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		choseText,
    		coordinateMouse,
    		onTab,
    		selectedText,
    		selectedTextForQuickTask,
    		pagenow,
    		prevText,
    		text,
    		TestSelection,
    		Delte,
    		$selectedTextForQuickTask,
    		$selectedText,
    		$coordinateMouse,
    		$choseText,
    		$onTab
    	});

    	$$self.$inject_state = $$props => {
    		if ('pagenow' in $$props) $$invalidate(0, pagenow = $$props.pagenow);
    		if ('prevText' in $$props) prevText = $$props.prevText;
    		if ('text' in $$props) text = $$props.text;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [pagenow, TestSelection, Delte];
    }

    class TextWord extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1I, create_fragment$1I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TextWord",
    			options,
    			id: create_fragment$1I.name
    		});
    	}
    }

    /* srcReading\PDFviewer\ConvertedText.svelte generated by Svelte v3.59.2 */

    const { console: console_1$A } = globals;

    const file$1D = "srcReading\\PDFviewer\\ConvertedText.svelte";

    function create_fragment$1H(ctx) {
    	let div;
    	let t;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*$convertedTextTess*/ ctx[0]);
    			attr_dev(div, "id", "contaiTextConverted");
    			attr_dev(div, "contenteditable", "true");
    			attr_dev(div, "spellcheck", "false");
    			attr_dev(div, "class", "svelte-1mtkb58");
    			add_location(div, file$1D, 37, 0, 1131);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div, "mouseup", /*TestSelection*/ ctx[1], false, false, false, false),
    					listen_dev(div, "mousedown", /*Delte*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$convertedTextTess*/ 1) set_data_contenteditable_dev(t, /*$convertedTextTess*/ ctx[0]);
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div_transition) div_transition = create_bidirectional_transition(div, blur, { duration: 500 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, blur, { duration: 500 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1H($$self, $$props, $$invalidate) {
    	let $selectedTextForQuickTask;
    	let $selectedText;
    	let $coordinateMouse;
    	let $choseText;
    	let $onTab;
    	let $convertedTextTess;
    	validate_store(selectedTextForQuickTask, 'selectedTextForQuickTask');
    	component_subscribe($$self, selectedTextForQuickTask, $$value => $$invalidate(5, $selectedTextForQuickTask = $$value));
    	validate_store(selectedText, 'selectedText');
    	component_subscribe($$self, selectedText, $$value => $$invalidate(6, $selectedText = $$value));
    	validate_store(coordinateMouse, 'coordinateMouse');
    	component_subscribe($$self, coordinateMouse, $$value => $$invalidate(7, $coordinateMouse = $$value));
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(8, $choseText = $$value));
    	validate_store(onTab, 'onTab');
    	component_subscribe($$self, onTab, $$value => $$invalidate(9, $onTab = $$value));
    	validate_store(convertedTextTess, 'convertedTextTess');
    	component_subscribe($$self, convertedTextTess, $$value => $$invalidate(0, $convertedTextTess = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ConvertedText', slots, []);
    	let pagenow = 'textword' + ($onTab - 1).toString();
    	let prevText = '';
    	let text = '';

    	function TestSelection(event) {
    		console.log("bug here");
    		prevText = text;
    		text = document.getSelection().toString();

    		//SỬ LÝ ĐẦU VÀO Ở ĐÂY
    		if (text != "" && text != prevText) {
    			console.log(text);
    			set_store_value(choseText, $choseText = text, $choseText);

    			coordinateMouse.update(() => {
    				console.log(event.clientX, event.clientY);
    				return [event.clientX, event.clientY];
    			});

    			console.log($coordinateMouse[0], $coordinateMouse[1]);
    			set_store_value(selectedTextForQuickTask, $selectedTextForQuickTask = true, $selectedTextForQuickTask);
    		} else {
    			set_store_value(selectedTextForQuickTask, $selectedTextForQuickTask = false, $selectedTextForQuickTask);
    			set_store_value(selectedText, $selectedText = false, $selectedText);
    		}
    	}

    	function Delte() {
    		set_store_value(selectedTextForQuickTask, $selectedTextForQuickTask = false, $selectedTextForQuickTask);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$A.warn(`<ConvertedText> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		blur,
    		convertedTextTess,
    		choseText,
    		coordinateMouse,
    		onTab,
    		selectedText,
    		selectedTextForQuickTask,
    		pagenow,
    		prevText,
    		text,
    		TestSelection,
    		Delte,
    		$selectedTextForQuickTask,
    		$selectedText,
    		$coordinateMouse,
    		$choseText,
    		$onTab,
    		$convertedTextTess
    	});

    	$$self.$inject_state = $$props => {
    		if ('pagenow' in $$props) pagenow = $$props.pagenow;
    		if ('prevText' in $$props) prevText = $$props.prevText;
    		if ('text' in $$props) text = $$props.text;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$convertedTextTess, TestSelection, Delte];
    }

    class ConvertedText extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1H, create_fragment$1H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ConvertedText",
    			options,
    			id: create_fragment$1H.name
    		});
    	}
    }

    /* srcReading\PDFviewer\Converting.svelte generated by Svelte v3.59.2 */

    const file$1C = "srcReading\\PDFviewer\\Converting.svelte";

    function create_fragment$1G(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			attr_dev(span, "class", "loader svelte-16vhh18");
    			add_location(span, file$1C, 2, 0, 36);
    			attr_dev(div, "id", "contaiCoverting");
    			attr_dev(div, "class", "svelte-16vhh18");
    			add_location(div, file$1C, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1G($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Converting', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Converting> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Converting extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1G, create_fragment$1G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Converting",
    			options,
    			id: create_fragment$1G.name
    		});
    	}
    }

    /* srcReading\PDFviewer\ContainCoverted.svelte generated by Svelte v3.59.2 */
    const file$1B = "srcReading\\PDFviewer\\ContainCoverted.svelte";

    // (33:4) {:else}
    function create_else_block$8(ctx) {
    	let converting;
    	let current;
    	converting = new Converting({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(converting.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(converting, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(converting.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(converting.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(converting, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(33:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (31:4) {#if $convertedTextTess}
    function create_if_block$E(ctx) {
    	let convertedtext;
    	let current;
    	convertedtext = new ConvertedText({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(convertedtext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(convertedtext, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(convertedtext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(convertedtext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(convertedtext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$E.name,
    		type: "if",
    		source: "(31:4) {#if $convertedTextTess}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1F(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let current_block_type_index;
    	let if_block;
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block$E, create_else_block$8];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$convertedTextTess*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "exit";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "copy";
    			t3 = space();
    			if_block.c();
    			attr_dev(button0, "class", "svelte-fmm70p");
    			add_location(button0, file$1B, 27, 8, 922);
    			attr_dev(button1, "id", "copycap");
    			attr_dev(button1, "class", "svelte-fmm70p");
    			add_location(button1, file$1B, 28, 8, 971);
    			attr_dev(div0, "id", "containCE");
    			attr_dev(div0, "class", "svelte-fmm70p");
    			add_location(div0, file$1B, 26, 4, 890);
    			attr_dev(div1, "id", "contaiconverted");
    			attr_dev(div1, "class", "svelte-fmm70p");
    			add_location(div1, file$1B, 25, 0, 856);
    			attr_dev(div2, "id", "containAllConverted");
    			attr_dev(div2, "class", "svelte-fmm70p");
    			add_location(div2, file$1B, 24, 0, 787);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, button0);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			append_dev(div1, t3);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*Exit*/ ctx[1], false, false, false, false),
    					listen_dev(button1, "click", Copy, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 1000 }, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 1000 }, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Copy() {
    	let copytext = document.getElementById('contaiTextConverted');
    	copytext.focus();
    	document.execCommand('selectAll');
    	document.execCommand("copy");
    	window.getSelection().removeAllRanges();
    	document.getElementById('copycap').innerText = "Copied";

    	setTimeout(
    		() => {
    			document.getElementById('copycap').innerText = "Copy";
    		},
    		2000
    	);
    }

    function instance$1F($$self, $$props, $$invalidate) {
    	let $convertedTextTess;
    	let $isConvertingTess;
    	validate_store(convertedTextTess, 'convertedTextTess');
    	component_subscribe($$self, convertedTextTess, $$value => $$invalidate(0, $convertedTextTess = $$value));
    	validate_store(isConvertingTess, 'isConvertingTess');
    	component_subscribe($$self, isConvertingTess, $$value => $$invalidate(2, $isConvertingTess = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ContainCoverted', slots, []);

    	function Exit() {
    		set_store_value(isConvertingTess, $isConvertingTess = false, $isConvertingTess);
    		set_store_value(convertedTextTess, $convertedTextTess = '', $convertedTextTess);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContainCoverted> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		ConvertedText,
    		convertedTextTess,
    		isConvertingTess,
    		Converting,
    		slide,
    		Exit,
    		Copy,
    		$convertedTextTess,
    		$isConvertingTess
    	});

    	return [$convertedTextTess, Exit];
    }

    class ContainCoverted extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1F, create_fragment$1F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContainCoverted",
    			options,
    			id: create_fragment$1F.name
    		});
    	}
    }

    /* srcReading\Textarea\Textarea.svelte generated by Svelte v3.59.2 */

    const { console: console_1$z } = globals;
    const file$1A = "srcReading\\Textarea\\Textarea.svelte";

    // (56:41) 
    function create_if_block_6$6(ctx) {
    	let textword;
    	let current;
    	textword = new TextWord({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(textword.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textword, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textword.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textword.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textword, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$6.name,
    		type: "if",
    		source: "(56:41) ",
    		ctx
    	});

    	return block;
    }

    // (49:43) 
    function create_if_block_4$7(ctx) {
    	let div;
    	let imagearea;
    	let t;
    	let current;

    	imagearea = new ImageArea({
    			props: { numpage: /*page*/ ctx[0] - 1 },
    			$$inline: true
    		});

    	let if_block = /*$isConvertingTess*/ ctx[3] && create_if_block_5$6(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(imagearea.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "id", "containerIMAGE");
    			attr_dev(div, "class", "svelte-ijax7k");
    			add_location(div, file$1A, 49, 5, 1743);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(imagearea, div, null);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const imagearea_changes = {};
    			if (dirty & /*page*/ 1) imagearea_changes.numpage = /*page*/ ctx[0] - 1;
    			imagearea.$set(imagearea_changes);

    			if (/*$isConvertingTess*/ ctx[3]) {
    				if (if_block) {
    					if (dirty & /*$isConvertingTess*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_5$6(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imagearea.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imagearea.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(imagearea);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$7.name,
    		type: "if",
    		source: "(49:43) ",
    		ctx
    	});

    	return block;
    }

    // (42:42) 
    function create_if_block_2$c(ctx) {
    	let div;
    	let viewer;
    	let t;
    	let current;
    	viewer = new Viewer$1({ $$inline: true });
    	let if_block = /*$isConvertingTess*/ ctx[3] && create_if_block_3$7(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(viewer.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			attr_dev(div, "id", "containPDF");
    			attr_dev(div, "class", "svelte-ijax7k");
    			add_location(div, file$1A, 42, 8, 1548);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(viewer, div, null);
    			append_dev(div, t);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$isConvertingTess*/ ctx[3]) {
    				if (if_block) {
    					if (dirty & /*$isConvertingTess*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$7(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(viewer.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(viewer.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(viewer);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(42:42) ",
    		ctx
    	});

    	return block;
    }

    // (40:45) 
    function create_if_block_1$g(ctx) {
    	let enternamefile;
    	let current;
    	enternamefile = new EnterNameFile({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(enternamefile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(enternamefile, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(enternamefile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(enternamefile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(enternamefile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(40:45) ",
    		ctx
    	});

    	return block;
    }

    // (38:6) {#if $step[page-1] == "selectfile"}
    function create_if_block$D(ctx) {
    	let upfile;
    	let current;
    	upfile = new UpFile({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(upfile.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(upfile, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(upfile.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(upfile.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(upfile, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$D.name,
    		type: "if",
    		source: "(38:6) {#if $step[page-1] == \\\"selectfile\\\"}",
    		ctx
    	});

    	return block;
    }

    // (52:12) {#if $isConvertingTess}
    function create_if_block_5$6(ctx) {
    	let containcoverted;
    	let current;
    	containcoverted = new ContainCoverted({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(containcoverted.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(containcoverted, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(containcoverted.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(containcoverted.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(containcoverted, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$6.name,
    		type: "if",
    		source: "(52:12) {#if $isConvertingTess}",
    		ctx
    	});

    	return block;
    }

    // (45:10) {#if $isConvertingTess}
    function create_if_block_3$7(ctx) {
    	let containcoverted;
    	let current;
    	containcoverted = new ContainCoverted({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(containcoverted.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(containcoverted, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(containcoverted.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(containcoverted.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(containcoverted, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(45:10) {#if $isConvertingTess}",
    		ctx
    	});

    	return block;
    }

    // (37:4) {#key $step[page-1]}
    function create_key_block$5(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;

    	const if_block_creators = [
    		create_if_block$D,
    		create_if_block_1$g,
    		create_if_block_2$c,
    		create_if_block_4$7,
    		create_if_block_6$6
    	];

    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$step*/ ctx[2][/*page*/ ctx[0] - 1] == "selectfile") return 0;
    		if (/*$step*/ ctx[2][/*page*/ ctx[0] - 1] == "enterName") return 1;
    		if (/*$step*/ ctx[2][/*page*/ ctx[0] - 1] == "RunPDF") return 2;
    		if (/*$step*/ ctx[2][/*page*/ ctx[0] - 1] == "RunImage") return 3;
    		if (/*$step*/ ctx[2][/*page*/ ctx[0] - 1] == "RunText") return 4;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$5.name,
    		type: "key",
    		source: "(37:4) {#key $step[page-1]}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1E(ctx) {
    	let div1;
    	let div0;
    	let previous_key = /*$step*/ ctx[2][/*page*/ ctx[0] - 1];
    	let div1_style_value;
    	let current;
    	let key_block = create_key_block$5(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			key_block.c();
    			attr_dev(div0, "id", "area");
    			attr_dev(div0, "class", "svelte-ijax7k");
    			add_location(div0, file$1A, 35, 4, 1315);
    			attr_dev(div1, "id", "containerArea");
    			attr_dev(div1, "style", div1_style_value = `z-index: ${/*zIndex*/ ctx[1]}; position: relative`);
    			add_location(div1, file$1A, 34, 0, 1233);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			key_block.m(div0, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$step, page*/ 5 && safe_not_equal(previous_key, previous_key = /*$step*/ ctx[2][/*page*/ ctx[0] - 1])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$5(ctx);
    				key_block.c();
    				transition_in(key_block, 1);
    				key_block.m(div0, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}

    			if (!current || dirty & /*zIndex*/ 2 && div1_style_value !== (div1_style_value = `z-index: ${/*zIndex*/ ctx[1]}; position: relative`)) {
    				attr_dev(div1, "style", div1_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1E($$self, $$props, $$invalidate) {
    	let $step;
    	let $isConvertingTess;
    	validate_store(step, 'step');
    	component_subscribe($$self, step, $$value => $$invalidate(2, $step = $$value));
    	validate_store(isConvertingTess, 'isConvertingTess');
    	component_subscribe($$self, isConvertingTess, $$value => $$invalidate(3, $isConvertingTess = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Textarea', slots, []);
    	let { page } = $$props;
    	let zIndex = 0;

    	onTab.subscribe(value => {
    		if (page == value) {
    			$$invalidate(1, zIndex = 1);
    			console.log(page);

    			if (document.getElementById("containerTab" + page.toString())) {
    				document.getElementById("containerTab" + page.toString()).style.backgroundColor = '#535353';
    			}
    		} else {
    			$$invalidate(1, zIndex = 0);

    			if (document.getElementById("containerTab" + page.toString())) {
    				document.getElementById("containerTab" + page.toString()).style.backgroundColor = '#1d1d1d';
    			}
    		}
    	});

    	onMount(() => {
    		set_store_value(step, $step[page - 1] = "selectfile", $step);
    		console.log("mounted");
    	});

    	$$self.$$.on_mount.push(function () {
    		if (page === undefined && !('page' in $$props || $$self.$$.bound[$$self.$$.props['page']])) {
    			console_1$z.warn("<Textarea> was created without expected prop 'page'");
    		}
    	});

    	const writable_props = ['page'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$z.warn(`<Textarea> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('page' in $$props) $$invalidate(0, page = $$props.page);
    	};

    	$$self.$capture_state = () => ({
    		Tab,
    		UpFile,
    		EnterNameFile,
    		page,
    		zIndex,
    		onTab,
    		step,
    		isConvertingTess,
    		Viewer: Viewer$1,
    		onMount,
    		ImageArea,
    		TextWord,
    		ContainCoverted,
    		$step,
    		$isConvertingTess
    	});

    	$$self.$inject_state = $$props => {
    		if ('page' in $$props) $$invalidate(0, page = $$props.page);
    		if ('zIndex' in $$props) $$invalidate(1, zIndex = $$props.zIndex);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [page, zIndex, $step, $isConvertingTess];
    }

    let Textarea$1 = class Textarea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1E, create_fragment$1E, safe_not_equal, { page: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Textarea",
    			options,
    			id: create_fragment$1E.name
    		});
    	}

    	get page() {
    		throw new Error("<Textarea>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set page(value) {
    		throw new Error("<Textarea>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    };

    /* srcReading\TaskBar\Nothing.svelte generated by Svelte v3.59.2 */
    const file$1z = "srcReading\\TaskBar\\Nothing.svelte";

    function create_fragment$1D(ctx) {
    	let img;
    	let img_src_value;
    	let img_intro;

    	const block = {
    		c: function create() {
    			img = element("img");
    			if (!src_url_equal(img.src, img_src_value = "../images/withoutunderwhite.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "class", "svelte-d5lgq7");
    			add_location(img, file$1z, 4, 0, 72);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    		},
    		p: noop,
    		i: function intro(local) {
    			if (!img_intro) {
    				add_render_callback(() => {
    					img_intro = create_in_transition(img, blur, { duration: 1000 });
    					img_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1D($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Nothing', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Nothing> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ blur });
    	return [];
    }

    class Nothing extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1D, create_fragment$1D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Nothing",
    			options,
    			id: create_fragment$1D.name
    		});
    	}
    }

    /* srcReading\PDFviewer\PDFtask.svelte generated by Svelte v3.59.2 */

    const { console: console_1$y } = globals;

    const file$1y = "srcReading\\PDFviewer\\PDFtask.svelte";

    function create_fragment$1C(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let button1;
    	let div_intro;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "dictionary";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "screensearch";
    			attr_dev(button0, "id", "dic");
    			attr_dev(button0, "class", "extrabut svelte-1glvapl");
    			add_location(button0, file$1y, 53, 0, 1384);
    			attr_dev(button1, "id", "ScreenCapture");
    			attr_dev(button1, "class", "svelte-1glvapl");
    			add_location(button1, file$1y, 54, 0, 1463);
    			attr_dev(div, "class", "svelte-1glvapl");
    			add_location(div, file$1y, 52, 0, 1351);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*Dictest*/ ctx[1], false, false, false, false),
    					listen_dev(button1, "click", /*Capture*/ ctx[0], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (!div_intro) {
    				add_render_callback(() => {
    					div_intro = create_in_transition(div, scale, { duration: 500 });
    					div_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1C($$self, $$props, $$invalidate) {
    	let $convertedTextTess;
    	let $isConvertingTess;
    	let $dictionaryDS;
    	let $captureLink;
    	let $captureTF;
    	validate_store(convertedTextTess, 'convertedTextTess');
    	component_subscribe($$self, convertedTextTess, $$value => $$invalidate(2, $convertedTextTess = $$value));
    	validate_store(isConvertingTess, 'isConvertingTess');
    	component_subscribe($$self, isConvertingTess, $$value => $$invalidate(3, $isConvertingTess = $$value));
    	validate_store(dictionaryDS$2, 'dictionaryDS');
    	component_subscribe($$self, dictionaryDS$2, $$value => $$invalidate(4, $dictionaryDS = $$value));
    	validate_store(captureLink, 'captureLink');
    	component_subscribe($$self, captureLink, $$value => $$invalidate(5, $captureLink = $$value));
    	validate_store(captureTF, 'captureTF');
    	component_subscribe($$self, captureTF, $$value => $$invalidate(6, $captureTF = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('PDFtask', slots, []);

    	const Capture = async () => {
    		set_store_value(isConvertingTess, $isConvertingTess = false, $isConvertingTess);
    		set_store_value(convertedTextTess, $convertedTextTess = '', $convertedTextTess);

    		try {
    			// asking permission
    			const stream = await navigator.mediaDevices.getDisplayMedia({ preferCurrentTab: true });

    			const video = document.createElement('video');
    			video.srcObject = stream; // Set the video source to the stream

    			video.onloadedmetadata = () => {
    				const canvas = document.createElement('canvas');
    				const ctx = canvas.getContext('2d');
    				canvas.height = video.videoHeight;
    				canvas.width = video.videoWidth;
    				video.play();
    				ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
    				stream.getVideoTracks()[0].stop();

    				//$captureLink = canvas.toDataURL();
    				canvas.toBlob(
    					blob => {
    						set_store_value(captureLink, $captureLink = URL.createObjectURL(blob), $captureLink);
    						set_store_value(captureTF, $captureTF = true, $captureTF);
    						console.log($captureLink.toString());
    					},
    					'image/jpg'
    				);
    			};
    		} catch(error) {
    			console.log(error);
    		}
    	};

    	function Dictest() {
    		set_store_value(dictionaryDS$2, $dictionaryDS = !$dictionaryDS, $dictionaryDS);

    		if ($dictionaryDS == true) {
    			set_store_value(isConvertingTess, $isConvertingTess = false, $isConvertingTess);
    			set_store_value(convertedTextTess, $convertedTextTess = '', $convertedTextTess);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$y.warn(`<PDFtask> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		scale,
    		captureLink,
    		captureTF,
    		isConvertingTess,
    		convertedTextTess,
    		dictionaryDS: dictionaryDS$2,
    		Capture,
    		Dictest,
    		$convertedTextTess,
    		$isConvertingTess,
    		$dictionaryDS,
    		$captureLink,
    		$captureTF
    	});

    	return [Capture, Dictest];
    }

    class PDFtask extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1C, create_fragment$1C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "PDFtask",
    			options,
    			id: create_fragment$1C.name
    		});
    	}
    }

    /* srcReading\ImageTask\ImageTask.svelte generated by Svelte v3.59.2 */
    const file$1x = "srcReading\\ImageTask\\ImageTask.svelte";

    function create_fragment$1B(ctx) {
    	let div;
    	let button;
    	let t1;
    	let pdftask;
    	let current;
    	let mounted;
    	let dispose;
    	pdftask = new PDFtask({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			button = element("button");
    			button.textContent = "add images";
    			t1 = space();
    			create_component(pdftask.$$.fragment);
    			attr_dev(button, "id", "uploadBoard");
    			attr_dev(button, "class", "svelte-17deot5");
    			add_location(button, file$1x, 12, 0, 243);
    			attr_dev(div, "class", "container svelte-17deot5");
    			add_location(div, file$1x, 10, 0, 214);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button);
    			insert_dev(target, t1, anchor);
    			mount_component(pdftask, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Change*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pdftask.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pdftask.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			destroy_component(pdftask, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1B($$self, $$props, $$invalidate) {
    	let $imageList;
    	let $imageTF;
    	validate_store(imageList, 'imageList');
    	component_subscribe($$self, imageList, $$value => $$invalidate(1, $imageList = $$value));
    	validate_store(imageTF, 'imageTF');
    	component_subscribe($$self, imageTF, $$value => $$invalidate(2, $imageTF = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ImageTask', slots, []);

    	function Change() {
    		set_store_value(imageTF, $imageTF = true, $imageTF);
    		set_store_value(imageList, $imageList = [], $imageList);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ImageTask> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		PdFtask: PDFtask,
    		imageList,
    		imageTF,
    		Change,
    		$imageList,
    		$imageTF
    	});

    	return [Change];
    }

    class ImageTask extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1B, create_fragment$1B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ImageTask",
    			options,
    			id: create_fragment$1B.name
    		});
    	}
    }

    /* srcReading\ChoicePanel\Definition.svelte generated by Svelte v3.59.2 */

    const { console: console_1$x } = globals;
    const file$1w = "srcReading\\ChoicePanel\\Definition.svelte";

    function get_each_context$y(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (125:36) 
    function create_if_block_7$4(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-148lq3u");
    			set_style(div, "background-color", "#c780e8");
    			add_location(div, file$1w, 125, 2, 3703);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$4.name,
    		type: "if",
    		source: "(125:36) ",
    		ctx
    	});

    	return block;
    }

    // (123:41) 
    function create_if_block_6$5(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-148lq3u");
    			set_style(div, "background-color", "#9d94ff");
    			add_location(div, file$1w, 123, 2, 3580);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$5.name,
    		type: "if",
    		source: "(123:41) ",
    		ctx
    	});

    	return block;
    }

    // (121:40) 
    function create_if_block_5$5(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-148lq3u");
    			set_style(div, "background-color", "#59adf6");
    			add_location(div, file$1w, 121, 2, 3452);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$5.name,
    		type: "if",
    		source: "(121:40) ",
    		ctx
    	});

    	return block;
    }

    // (119:40) 
    function create_if_block_4$6(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-148lq3u");
    			set_style(div, "background-color", "#08cad1");
    			add_location(div, file$1w, 119, 2, 3325);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(119:40) ",
    		ctx
    	});

    	return block;
    }

    // (117:35) 
    function create_if_block_3$6(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-148lq3u");
    			set_style(div, "background-color", "#42d6a4");
    			add_location(div, file$1w, 117, 2, 3198);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(117:35) ",
    		ctx
    	});

    	return block;
    }

    // (115:38) 
    function create_if_block_2$b(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-148lq3u");
    			set_style(div, "background-color", "#f8f38d");
    			add_location(div, file$1w, 115, 2, 3076);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(115:38) ",
    		ctx
    	});

    	return block;
    }

    // (113:33) 
    function create_if_block_1$f(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-148lq3u");
    			set_style(div, "background-color", "#ffb480");
    			add_location(div, file$1w, 113, 2, 2951);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(113:33) ",
    		ctx
    	});

    	return block;
    }

    // (111:2) {#if types.type== 'noun'}
    function create_if_block$C(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-148lq3u");
    			set_style(div, "background-color", "#ff6961");
    			add_location(div, file$1w, 111, 2, 2831);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$C.name,
    		type: "if",
    		source: "(111:2) {#if types.type== 'noun'}",
    		ctx
    	});

    	return block;
    }

    // (128:4) {#each types.deex as defiexam}
    function create_each_block_1$4(ctx) {
    	let div2;
    	let button;
    	let t1;
    	let div0;
    	let t2_value = /*defiexam*/ ctx[7].defi + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4_value = /*defiexam*/ ctx[7].exam + "";
    	let t4;
    	let t5;
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*defiexam*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "save";
    			t1 = space();
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(button, "class", "savevo svelte-148lq3u");
    			add_location(button, file$1w, 129, 8, 3905);
    			attr_dev(div0, "class", "DefiEng svelte-148lq3u");
    			add_location(div0, file$1w, 130, 8, 4005);
    			attr_dev(div1, "class", "ExEng svelte-148lq3u");
    			add_location(div1, file$1w, 131, 8, 4059);
    			attr_dev(div2, "class", "MeaningClass svelte-148lq3u");
    			add_location(div2, file$1w, 128, 4, 3835);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, t4);
    			append_dev(div2, t5);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*fetchValue*/ 2) && t2_value !== (t2_value = /*defiexam*/ ctx[7].defi + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*fetchValue*/ 2) && t4_value !== (t4_value = /*defiexam*/ ctx[7].exam + "")) set_data_dev(t4, t4_value);
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, blur, { duration: 500 }, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, blur, { duration: 500 }, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(128:4) {#each types.deex as defiexam}",
    		ctx
    	});

    	return block;
    }

    // (110:2) {#each fetchValue.board as types}
    function create_each_block$y(ctx) {
    	let t;
    	let each_1_anchor;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*types*/ ctx[4].type == 'noun') return create_if_block$C;
    		if (/*types*/ ctx[4].type == 'verb') return create_if_block_1$f;
    		if (/*types*/ ctx[4].type == 'adjective') return create_if_block_2$b;
    		if (/*types*/ ctx[4].type == 'adverb') return create_if_block_3$6;
    		if (/*types*/ ctx[4].type == 'preposition') return create_if_block_4$6;
    		if (/*types*/ ctx[4].type == 'conjunction') return create_if_block_5$5;
    		if (/*types*/ ctx[4].type == 'interjection') return create_if_block_6$5;
    		if (/*types*/ ctx[4].type == 'pronoun') return create_if_block_7$4;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);
    	let each_value_1 = /*types*/ ctx[4].deex;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			}

    			if (dirty & /*fetchValue, Saving, $choseText*/ 6) {
    				each_value_1 = /*types*/ ctx[4].deex;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$y.name,
    		type: "each",
    		source: "(110:2) {#each fetchValue.board as types}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1A(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let div2_style_value;
    	let current;
    	let each_value = /*fetchValue*/ ctx[1].board;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$y(get_each_context$y(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*$choseText*/ ctx[2]);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "word");
    			attr_dev(div0, "class", "svelte-148lq3u");
    			add_location(div0, file$1w, 105, 4, 2708);
    			attr_dev(div1, "id", "containerWord");
    			attr_dev(div1, "class", "svelte-148lq3u");
    			add_location(div1, file$1w, 104, 2, 2676);
    			attr_dev(div2, "class", "containerPath svelte-148lq3u");
    			attr_dev(div2, "style", div2_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div2, file$1w, 103, 0, 2612);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div2, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$choseText*/ 4) set_data_dev(t0, /*$choseText*/ ctx[2]);

    			if (dirty & /*fetchValue, Saving, $choseText*/ 6) {
    				each_value = /*fetchValue*/ ctx[1].board;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$y(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$y(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*zIndex*/ 1 && div2_style_value !== (div2_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div2, "style", div2_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Saving$4(definition, words) {
    	let vocData = JSON.parse(localStorage.getItem('vocabulary'));
    	let date = `${new Date().getUTCDate()} - ${new Date().getUTCMonth() + 1} - ${new Date().getUTCFullYear()}`;

    	if (vocData.length === 0 || vocData[0].day !== date) {
    		let newDay = {};
    		newDay["day"] = date;
    		newDay["content"] = [];
    		vocData.unshift(newDay);
    	}

    	let con = {};
    	con["word"] = words;
    	con["definition"] = definition;
    	vocData[0].content.push(con);
    	localStorage.setItem('vocabulary', JSON.stringify(vocData));
    }

    function instance$1A($$self, $$props, $$invalidate) {
    	let $choseText;
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(2, $choseText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Definition', slots, []);
    	let zIndex = 0;

    	stepDic.subscribe(value => {
    		if (value == 'defi') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let fetchValue = { "word": "", "pronon": "", "board": [] };

    	//API DÈINITION
    	onMount(() => {
    		let huptext = $choseText;
    		var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + `${huptext}`;
    		let contaiFile;

    		fetch(link).then(res => res.json()).then(result => {
    			result.map(run1);

    			function run1(resultNew) {
    				$$invalidate(1, fetchValue.word = resultNew.word, fetchValue);
    				$$invalidate(1, fetchValue.pronon = resultNew.phonetic, fetchValue);
    				resultNew.meanings.map(run2);

    				//phonetic vs word here
    				console.log(fetchValue);
    			}

    			function run2(meaningsNew) {
    				contaiFile = { "type": "", "deex": [] };
    				contaiFile.type = meaningsNew.partOfSpeech;
    				meaningsNew.definitions.map(run3);
    				console.log(contaiFile, "finishedrun2");
    				fetchValue.board.push(contaiFile);
    			}

    			function run3(definitionsNew) {
    				console.log(definitionsNew.definition + "run3");
    				let deSam = { "defi": "", "exam": "" };
    				deSam.defi = definitionsNew.definition;

    				if (definitionsNew.example != undefined) {
    					deSam.exam = "Ex: " + definitionsNew.example;
    				} else {
    					deSam.exam = '';
    				}

    				contaiFile.deex.push(deSam);
    			}
    		}).catch(error => {
    			document.write(error);
    		}).finally(() => {
    			
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$x.warn(`<Definition> was created with unknown prop '${key}'`);
    	});

    	const click_handler = defiexam => {
    		Saving$4(defiexam.defi, $choseText);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		blur,
    		choseText,
    		stepDic,
    		zIndex,
    		fetchValue,
    		Saving: Saving$4,
    		$choseText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('fetchValue' in $$props) $$invalidate(1, fetchValue = $$props.fetchValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, fetchValue, $choseText, click_handler];
    }

    class Definition extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1A, create_fragment$1A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Definition",
    			options,
    			id: create_fragment$1A.name
    		});
    	}
    }

    /* srcReading\ChoicePanel\Antonyms.svelte generated by Svelte v3.59.2 */
    const file$1v = "srcReading\\ChoicePanel\\Antonyms.svelte";

    function get_each_context$x(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:4) {#if loaded==true}
    function create_if_block$B(ctx) {
    	let each_1_anchor;
    	let each_value = /*antonymsList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$x(get_each_context$x(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*antonymsList*/ 4) {
    				each_value = /*antonymsList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$x(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$x(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$B.name,
    		type: "if",
    		source: "(36:4) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:4) {#each antonymsList as Ant}
    function create_each_block$x(ctx) {
    	let div;
    	let t_value = /*Ant*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "AntWord svelte-1dzd4ps");
    			add_location(div, file$1v, 37, 4, 817);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*antonymsList*/ 4 && t_value !== (t_value = /*Ant*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$x.name,
    		type: "each",
    		source: "(37:4) {#each antonymsList as Ant}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1z(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$B(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containerAnt svelte-1dzd4ps");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$1v, 34, 0, 694);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$B(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1z($$self, $$props, $$invalidate) {
    	let $choseText;
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(3, $choseText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Antonyms', slots, []);
    	let zIndex = 0;
    	let loaded;

    	stepDic.subscribe(value => {
    		if (value == 'ant') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let antonymsList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $choseText;
    		var urlant = "https://api.datamuse.com/words?rel_ant=" + huptext;

    		fetch(urlant).then(res => res.json()).then(result => {
    			$$invalidate(2, antonymsList = []);
    			result.map(createAnt);
    			$$invalidate(1, loaded = true);

    			function createAnt(Ant) {
    				antonymsList.push(Ant.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Antonyms> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDic,
    		choseText,
    		onMount,
    		zIndex,
    		loaded,
    		antonymsList,
    		$choseText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('antonymsList' in $$props) $$invalidate(2, antonymsList = $$props.antonymsList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, antonymsList];
    }

    class Antonyms extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1z, create_fragment$1z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Antonyms",
    			options,
    			id: create_fragment$1z.name
    		});
    	}
    }

    /* srcReading\ChoicePanel\Synonyms.svelte generated by Svelte v3.59.2 */
    const file$1u = "srcReading\\ChoicePanel\\Synonyms.svelte";

    function get_each_context$w(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:4) {#if loaded==true}
    function create_if_block$A(ctx) {
    	let each_1_anchor;
    	let each_value = /*synonymsList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$w(get_each_context$w(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*synonymsList*/ 4) {
    				each_value = /*synonymsList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$w(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$w(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$A.name,
    		type: "if",
    		source: "(36:4) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:4) {#each synonymsList as Syn}
    function create_each_block$w(ctx) {
    	let div;
    	let t_value = /*Syn*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "SynWord svelte-1ajjzg6");
    			add_location(div, file$1u, 37, 4, 843);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*synonymsList*/ 4 && t_value !== (t_value = /*Syn*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$w.name,
    		type: "each",
    		source: "(37:4) {#each synonymsList as Syn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1y(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$A(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containerSyn svelte-1ajjzg6");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$1u, 34, 0, 720);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$A(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1y($$self, $$props, $$invalidate) {
    	let $choseText;
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(3, $choseText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Synonyms', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDic.subscribe(value => {
    		if (value == 'syn') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let synonymsList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $choseText;
    		var urlsyn = "https://api.datamuse.com/words?rel_syn=" + huptext;

    		fetch(urlsyn).then(res => res.json()).then(result => {
    			$$invalidate(2, synonymsList = []);
    			result.map(createSyn);
    			$$invalidate(1, loaded = true);

    			function createSyn(Syn) {
    				synonymsList.push(Syn.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Synonyms> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDic,
    		choseText,
    		onMount,
    		zIndex,
    		loaded,
    		synonymsList,
    		$choseText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('synonymsList' in $$props) $$invalidate(2, synonymsList = $$props.synonymsList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, synonymsList];
    }

    class Synonyms extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1y, create_fragment$1y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Synonyms",
    			options,
    			id: create_fragment$1y.name
    		});
    	}
    }

    /* srcReading\ChoicePanel\CoNount.svelte generated by Svelte v3.59.2 */
    const file$1t = "srcReading\\ChoicePanel\\CoNount.svelte";

    function get_each_context$v(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$z(ctx) {
    	let each_1_anchor;
    	let each_value = /*coNList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$v(get_each_context$v(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$choseText, coNList*/ 12) {
    				each_value = /*coNList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$v(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$v(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$z.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each coNList as coN}
    function create_each_block$v(ctx) {
    	let div;
    	let t_value = /*$choseText*/ ctx[3] + " " + /*coN*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "coNWord svelte-avmy3y");
    			add_location(div, file$1t, 37, 8, 971);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$choseText, coNList*/ 12 && t_value !== (t_value = /*$choseText*/ ctx[3] + " " + /*coN*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$v.name,
    		type: "each",
    		source: "(37:8) {#each coNList as coN}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1x(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$z(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containercoN svelte-avmy3y");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$1t, 34, 4, 841);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$z(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1x($$self, $$props, $$invalidate) {
    	let $choseText;
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(3, $choseText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CoNount', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDic.subscribe(value => {
    		if (value == 'coN') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let coNList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $choseText;
    		var urlcoN = "https://api.datamuse.com/words?rel_jja=" + huptext;

    		fetch(urlcoN).then(res => res.json()).then(result => {
    			$$invalidate(2, coNList = []);
    			result.map(createcoN);
    			$$invalidate(1, loaded = true);

    			function createcoN(coN) {
    				coNList.push(coN.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CoNount> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDic,
    		choseText,
    		onMount,
    		zIndex,
    		loaded,
    		coNList,
    		$choseText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('coNList' in $$props) $$invalidate(2, coNList = $$props.coNList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, coNList, $choseText];
    }

    class CoNount extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1x, create_fragment$1x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CoNount",
    			options,
    			id: create_fragment$1x.name
    		});
    	}
    }

    /* srcReading\ChoicePanel\CoAdj.svelte generated by Svelte v3.59.2 */
    const file$1s = "srcReading\\ChoicePanel\\CoAdj.svelte";

    function get_each_context$u(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$y(ctx) {
    	let each_1_anchor;
    	let each_value = /*coAList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$u(get_each_context$u(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coAList, $choseText*/ 12) {
    				each_value = /*coAList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$u(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$u(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each coAList as coA}
    function create_each_block$u(ctx) {
    	let div;
    	let t_value = /*coA*/ ctx[4] + " " + /*$choseText*/ ctx[3] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "coAWord svelte-1qkxkpw");
    			add_location(div, file$1s, 37, 8, 971);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coAList, $choseText*/ 12 && t_value !== (t_value = /*coA*/ ctx[4] + " " + /*$choseText*/ ctx[3] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$u.name,
    		type: "each",
    		source: "(37:8) {#each coAList as coA}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1w(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$y(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containercoA svelte-1qkxkpw");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$1s, 34, 4, 841);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$y(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1w($$self, $$props, $$invalidate) {
    	let $choseText;
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(3, $choseText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CoAdj', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDic.subscribe(value => {
    		if (value == 'coA') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let coAList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $choseText;
    		var urlcoA = "https://api.datamuse.com/words?rel_jjb=" + huptext;

    		fetch(urlcoA).then(res => res.json()).then(result => {
    			$$invalidate(2, coAList = []);
    			result.map(createcoA);
    			$$invalidate(1, loaded = true);

    			function createcoA(coA) {
    				coAList.push(coA.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CoAdj> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDic,
    		choseText,
    		onMount,
    		zIndex,
    		loaded,
    		coAList,
    		$choseText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('coAList' in $$props) $$invalidate(2, coAList = $$props.coAList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, coAList, $choseText];
    }

    class CoAdj extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1w, create_fragment$1w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CoAdj",
    			options,
    			id: create_fragment$1w.name
    		});
    	}
    }

    /* srcReading\ChoicePanel\ChoicePanel.svelte generated by Svelte v3.59.2 */

    const { console: console_1$w } = globals;
    const file$1r = "srcReading\\ChoicePanel\\ChoicePanel.svelte";

    function create_fragment$1v(ctx) {
    	let div1;
    	let div0;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let button2;
    	let t5;
    	let button3;
    	let t7;
    	let button4;
    	let t9;
    	let definition;
    	let t10;
    	let synonyms;
    	let t11;
    	let antonyms;
    	let t12;
    	let coadj;
    	let t13;
    	let conount;
    	let div1_transition;
    	let current;
    	let mounted;
    	let dispose;
    	definition = new Definition({ $$inline: true });
    	synonyms = new Synonyms({ $$inline: true });
    	antonyms = new Antonyms({ $$inline: true });
    	coadj = new CoAdj({ $$inline: true });
    	conount = new CoNount({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "defi";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "syn";
    			t3 = space();
    			button2 = element("button");
    			button2.textContent = "ant";
    			t5 = space();
    			button3 = element("button");
    			button3.textContent = "adj";
    			t7 = space();
    			button4 = element("button");
    			button4.textContent = "noun";
    			t9 = space();
    			create_component(definition.$$.fragment);
    			t10 = space();
    			create_component(synonyms.$$.fragment);
    			t11 = space();
    			create_component(antonyms.$$.fragment);
    			t12 = space();
    			create_component(coadj.$$.fragment);
    			t13 = space();
    			create_component(conount.$$.fragment);
    			attr_dev(button0, "class", "type svelte-1cqungj");
    			add_location(button0, file$1r, 62, 8, 2151);
    			attr_dev(button1, "class", "type svelte-1cqungj");
    			add_location(button1, file$1r, 63, 8, 2228);
    			attr_dev(button2, "class", "type svelte-1cqungj");
    			add_location(button2, file$1r, 64, 8, 2303);
    			attr_dev(button3, "class", "type svelte-1cqungj");
    			add_location(button3, file$1r, 65, 8, 2378);
    			attr_dev(button4, "class", "type svelte-1cqungj");
    			add_location(button4, file$1r, 66, 8, 2453);
    			attr_dev(div0, "id", "containerType");
    			attr_dev(div0, "class", "svelte-1cqungj");
    			add_location(div0, file$1r, 61, 4, 2115);
    			attr_dev(div1, "id", "containerLookUp");
    			attr_dev(div1, "class", "svelte-1cqungj");
    			add_location(div1, file$1r, 60, 0, 2039);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, button0);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			append_dev(div0, t3);
    			append_dev(div0, button2);
    			append_dev(div0, t5);
    			append_dev(div0, button3);
    			append_dev(div0, t7);
    			append_dev(div0, button4);
    			append_dev(div1, t9);
    			mount_component(definition, div1, null);
    			append_dev(div1, t10);
    			mount_component(synonyms, div1, null);
    			append_dev(div1, t11);
    			mount_component(antonyms, div1, null);
    			append_dev(div1, t12);
    			mount_component(coadj, div1, null);
    			append_dev(div1, t13);
    			mount_component(conount, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[1], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[3], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[4], false, false, false, false),
    					listen_dev(button4, "click", /*click_handler_4*/ ctx[5], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(definition.$$.fragment, local);
    			transition_in(synonyms.$$.fragment, local);
    			transition_in(antonyms.$$.fragment, local);
    			transition_in(coadj.$$.fragment, local);
    			transition_in(conount.$$.fragment, local);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 300, delay: 0 }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(definition.$$.fragment, local);
    			transition_out(synonyms.$$.fragment, local);
    			transition_out(antonyms.$$.fragment, local);
    			transition_out(coadj.$$.fragment, local);
    			transition_out(conount.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 300, delay: 0 }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(definition);
    			destroy_component(synonyms);
    			destroy_component(antonyms);
    			destroy_component(coadj);
    			destroy_component(conount);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1v($$self, $$props, $$invalidate) {
    	let $stepDic;
    	let $coordinateMouse;
    	validate_store(stepDic, 'stepDic');
    	component_subscribe($$self, stepDic, $$value => $$invalidate(6, $stepDic = $$value));
    	validate_store(coordinateMouse, 'coordinateMouse');
    	component_subscribe($$self, coordinateMouse, $$value => $$invalidate(7, $coordinateMouse = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ChoicePanel', slots, []);

    	onMount(() => {
    		set_store_value(stepDic, $stepDic = 'defi', $stepDic);
    		document.getElementsByClassName('type')[0].style.backgroundColor = '#fefefe';
    		document.getElementsByClassName('type')[0].style.color = '#1d1d1d';
    		let container = document.getElementById('containerLookUp');
    		console.log(container.offsetWidth, ",;;;;;;;;;;;;;;;;;;;;;;");

    		if ($coordinateMouse[0] + container.offsetWidth < window.innerWidth) {
    			container.style.left = $coordinateMouse[0] + 'px';
    		} else {
    			container.style.left = $coordinateMouse[0] - container.offsetWidth + 'px';
    		}

    		if ($coordinateMouse[1] + container.offsetHeight < window.innerHeight) {
    			container.style.top = $coordinateMouse[1] + 'px';
    		} else {
    			container.style.top = $coordinateMouse[1] - container.offsetHeight + 'px';
    		}

    		console.log("Applyed");
    	});

    	function Ref(choice, k) {
    		if (choice == 'defi') {
    			set_store_value(stepDic, $stepDic = 'defi', $stepDic);
    		} else if (choice == 'syn') {
    			set_store_value(stepDic, $stepDic = 'syn', $stepDic);
    		} else if (choice == 'ant') {
    			set_store_value(stepDic, $stepDic = 'ant', $stepDic);
    		} else if (choice == 'coA') {
    			set_store_value(stepDic, $stepDic = 'coA', $stepDic);
    		} else if (choice == 'coN') {
    			set_store_value(stepDic, $stepDic = 'coN', $stepDic);
    		}

    		for (let i = 0; i <= 4; i++) {
    			if (i + 1 == k) {
    				document.getElementsByClassName('type')[i].style.backgroundColor = '#fefefe';
    				document.getElementsByClassName('type')[i].style.color = '#1d1d1d';
    			} else {
    				document.getElementsByClassName('type')[i].style.backgroundColor = 'transparent';
    				document.getElementsByClassName('type')[i].style.color = '#fefefe';
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$w.warn(`<ChoicePanel> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		Ref('defi', 1);
    	};

    	const click_handler_1 = () => {
    		Ref('syn', 2);
    	};

    	const click_handler_2 = () => {
    		Ref('ant', 3);
    	};

    	const click_handler_3 = () => {
    		Ref('coA', 4);
    	};

    	const click_handler_4 = () => {
    		Ref('coN', 5);
    	};

    	$$self.$capture_state = () => ({
    		coordinateMouse,
    		stepDic,
    		onMount,
    		slide,
    		Definition,
    		Antonyms,
    		Synonyms,
    		CoNount,
    		CoAdj,
    		Ref,
    		$stepDic,
    		$coordinateMouse
    	});

    	return [
    		Ref,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4
    	];
    }

    class ChoicePanel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1v, create_fragment$1v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ChoicePanel",
    			options,
    			id: create_fragment$1v.name
    		});
    	}
    }

    /* srcReading\Dictionary\BoardDic.svelte generated by Svelte v3.59.2 */
    const file$1q = "srcReading\\Dictionary\\BoardDic.svelte";

    function create_fragment$1u(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let button2;
    	let t5;
    	let button3;
    	let t7;
    	let button4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "defi";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "syn";
    			t3 = space();
    			button2 = element("button");
    			button2.textContent = "ant";
    			t5 = space();
    			button3 = element("button");
    			button3.textContent = "adj";
    			t7 = space();
    			button4 = element("button");
    			button4.textContent = "noun";
    			attr_dev(button0, "class", "typeDS svelte-11v8fm6");
    			add_location(button0, file$1q, 35, 4, 1042);
    			attr_dev(button1, "class", "typeDS svelte-11v8fm6");
    			add_location(button1, file$1q, 36, 4, 1117);
    			attr_dev(button2, "class", "typeDS svelte-11v8fm6");
    			add_location(button2, file$1q, 37, 4, 1190);
    			attr_dev(button3, "class", "typeDS svelte-11v8fm6");
    			add_location(button3, file$1q, 38, 4, 1263);
    			attr_dev(button4, "class", "typeDS svelte-11v8fm6");
    			add_location(button4, file$1q, 39, 4, 1336);
    			attr_dev(div, "id", "containerTypeDS");
    			attr_dev(div, "class", "svelte-11v8fm6");
    			add_location(div, file$1q, 34, 0, 1008);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, button1);
    			append_dev(div, t3);
    			append_dev(div, button2);
    			append_dev(div, t5);
    			append_dev(div, button3);
    			append_dev(div, t7);
    			append_dev(div, button4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[1], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[3], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[4], false, false, false, false),
    					listen_dev(button4, "click", /*click_handler_4*/ ctx[5], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1u($$self, $$props, $$invalidate) {
    	let $stepDS;
    	validate_store(stepDS$2, 'stepDS');
    	component_subscribe($$self, stepDS$2, $$value => $$invalidate(6, $stepDS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BoardDic', slots, []);

    	onMount(() => {
    		document.getElementsByClassName('typeDS')[0].style.backgroundColor = '#fefefe';
    		document.getElementsByClassName('typeDS')[0].style.color = '#1d1d1d';
    	});

    	function Ref(choice, k) {
    		if (choice == 'defi') {
    			set_store_value(stepDS$2, $stepDS = 'defi', $stepDS);
    		} else if (choice == 'syn') {
    			set_store_value(stepDS$2, $stepDS = 'syn', $stepDS);
    		} else if (choice == 'ant') {
    			set_store_value(stepDS$2, $stepDS = 'ant', $stepDS);
    		} else if (choice == 'coA') {
    			set_store_value(stepDS$2, $stepDS = 'coA', $stepDS);
    		} else if (choice == 'coN') {
    			set_store_value(stepDS$2, $stepDS = 'coN', $stepDS);
    		}

    		for (let i = 0; i <= 4; i++) {
    			if (i + 1 == k) {
    				document.getElementsByClassName('typeDS')[i].style.backgroundColor = '#fefefe';
    				document.getElementsByClassName('typeDS')[i].style.color = '#1d1d1d';
    			} else {
    				document.getElementsByClassName('typeDS')[i].style.backgroundColor = 'transparent';
    				document.getElementsByClassName('typeDS')[i].style.color = '#fefefe';
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BoardDic> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		Ref('defi', 1);
    	};

    	const click_handler_1 = () => {
    		Ref('syn', 2);
    	};

    	const click_handler_2 = () => {
    		Ref('ant', 3);
    	};

    	const click_handler_3 = () => {
    		Ref('coA', 4);
    	};

    	const click_handler_4 = () => {
    		Ref('coN', 5);
    	};

    	$$self.$capture_state = () => ({ onMount, stepDS: stepDS$2, Ref, $stepDS });

    	return [
    		Ref,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4
    	];
    }

    let BoardDic$2 = class BoardDic extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1u, create_fragment$1u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BoardDic",
    			options,
    			id: create_fragment$1u.name
    		});
    	}
    };

    /* srcReading\Dictionary\DefiDS.svelte generated by Svelte v3.59.2 */

    const { console: console_1$v } = globals;
    const file$1p = "srcReading\\Dictionary\\DefiDS.svelte";

    function get_each_context$t(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (126:38) 
    function create_if_block_7$3(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#c780e8");
    			add_location(div, file$1p, 126, 4, 3774);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$3.name,
    		type: "if",
    		source: "(126:38) ",
    		ctx
    	});

    	return block;
    }

    // (124:43) 
    function create_if_block_6$4(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#9d94ff");
    			add_location(div, file$1p, 124, 4, 3647);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$4.name,
    		type: "if",
    		source: "(124:43) ",
    		ctx
    	});

    	return block;
    }

    // (122:42) 
    function create_if_block_5$4(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#59adf6");
    			add_location(div, file$1p, 122, 4, 3515);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(122:42) ",
    		ctx
    	});

    	return block;
    }

    // (120:42) 
    function create_if_block_4$5(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#08cad1");
    			add_location(div, file$1p, 120, 4, 3384);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(120:42) ",
    		ctx
    	});

    	return block;
    }

    // (118:37) 
    function create_if_block_3$5(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#42d6a4");
    			add_location(div, file$1p, 118, 4, 3253);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(118:37) ",
    		ctx
    	});

    	return block;
    }

    // (116:40) 
    function create_if_block_2$a(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#f8f38d");
    			add_location(div, file$1p, 116, 4, 3127);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(116:40) ",
    		ctx
    	});

    	return block;
    }

    // (114:35) 
    function create_if_block_1$e(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#ffb480");
    			add_location(div, file$1p, 114, 4, 2998);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(114:35) ",
    		ctx
    	});

    	return block;
    }

    // (112:4) {#if types.type== 'noun'}
    function create_if_block$x(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#ff6961");
    			add_location(div, file$1p, 112, 4, 2874);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(112:4) {#if types.type== 'noun'}",
    		ctx
    	});

    	return block;
    }

    // (129:4) {#each types.deex as defiexam}
    function create_each_block_1$3(ctx) {
    	let div2;
    	let button;
    	let t1;
    	let div0;
    	let t2_value = /*defiexam*/ ctx[7].defi + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4_value = /*defiexam*/ ctx[7].exam + "";
    	let t4;
    	let t5;
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*defiexam*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "save";
    			t1 = space();
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(button, "class", "savevo svelte-6z1hk9");
    			add_location(button, file$1p, 130, 8, 3978);
    			attr_dev(div0, "class", "DefiEng svelte-6z1hk9");
    			add_location(div0, file$1p, 131, 8, 4078);
    			attr_dev(div1, "class", "ExEng svelte-6z1hk9");
    			add_location(div1, file$1p, 132, 8, 4132);
    			attr_dev(div2, "class", "MeaningClass svelte-6z1hk9");
    			add_location(div2, file$1p, 129, 4, 3908);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, t4);
    			append_dev(div2, t5);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*fetchValue*/ 2) && t2_value !== (t2_value = /*defiexam*/ ctx[7].defi + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*fetchValue*/ 2) && t4_value !== (t4_value = /*defiexam*/ ctx[7].exam + "")) set_data_dev(t4, t4_value);
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, blur, { duration: 500 }, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, blur, { duration: 500 }, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(129:4) {#each types.deex as defiexam}",
    		ctx
    	});

    	return block;
    }

    // (111:2) {#each fetchValue.board as types}
    function create_each_block$t(ctx) {
    	let t;
    	let each_1_anchor;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*types*/ ctx[4].type == 'noun') return create_if_block$x;
    		if (/*types*/ ctx[4].type == 'verb') return create_if_block_1$e;
    		if (/*types*/ ctx[4].type == 'adjective') return create_if_block_2$a;
    		if (/*types*/ ctx[4].type == 'adverb') return create_if_block_3$5;
    		if (/*types*/ ctx[4].type == 'preposition') return create_if_block_4$5;
    		if (/*types*/ ctx[4].type == 'conjunction') return create_if_block_5$4;
    		if (/*types*/ ctx[4].type == 'interjection') return create_if_block_6$4;
    		if (/*types*/ ctx[4].type == 'pronoun') return create_if_block_7$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);
    	let each_value_1 = /*types*/ ctx[4].deex;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			}

    			if (dirty & /*fetchValue, Saving, $enterText*/ 6) {
    				each_value_1 = /*types*/ ctx[4].deex;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$3(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$t.name,
    		type: "each",
    		source: "(111:2) {#each fetchValue.board as types}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1t(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let div2_style_value;
    	let current;
    	let each_value = /*fetchValue*/ ctx[1].board;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$t(get_each_context$t(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*$enterText*/ ctx[2]);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "word");
    			attr_dev(div0, "class", "svelte-6z1hk9");
    			add_location(div0, file$1p, 106, 4, 2746);
    			attr_dev(div1, "id", "containerWord");
    			attr_dev(div1, "class", "svelte-6z1hk9");
    			add_location(div1, file$1p, 105, 2, 2714);
    			attr_dev(div2, "class", "containerPath svelte-6z1hk9");
    			attr_dev(div2, "style", div2_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div2, file$1p, 104, 0, 2650);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div2, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$enterText*/ 4) set_data_dev(t0, /*$enterText*/ ctx[2]);

    			if (dirty & /*fetchValue, Saving, $enterText*/ 6) {
    				each_value = /*fetchValue*/ ctx[1].board;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$t(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$t(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*zIndex*/ 1 && div2_style_value !== (div2_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div2, "style", div2_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Saving$3(definition, words) {
    	let vocData = JSON.parse(localStorage.getItem('vocabulary'));
    	let date = `${new Date().getUTCDate()} - ${new Date().getUTCMonth() + 1} - ${new Date().getUTCFullYear()}`;

    	if (vocData.length === 0 || vocData[0].day !== date) {
    		let newDay = {};
    		newDay["day"] = date;
    		newDay["content"] = [];
    		vocData.unshift(newDay);
    	}

    	let con = {};
    	con["word"] = words;
    	con["definition"] = definition;
    	vocData[0].content.push(con);
    	localStorage.setItem('vocabulary', JSON.stringify(vocData));
    }

    function instance$1t($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText$2, 'enterText');
    	component_subscribe($$self, enterText$2, $$value => $$invalidate(2, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DefiDS', slots, []);
    	let zIndex = 0;

    	stepDS$2.subscribe(value => {
    		if (value == 'defi') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let fetchValue = { "word": "", "pronon": "", "board": [] };

    	//API DÈINITION
    	onMount(() => {
    		let huptext = $enterText;
    		var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + `${huptext}`;
    		let contaiFile;

    		fetch(link).then(res => res.json()).then(result => {
    			result.map(run1);

    			function run1(resultNew) {
    				$$invalidate(1, fetchValue.word = resultNew.word, fetchValue);
    				$$invalidate(1, fetchValue.pronon = resultNew.phonetic, fetchValue);
    				resultNew.meanings.map(run2);

    				//phonetic vs word here
    				console.log(fetchValue);
    			}

    			function run2(meaningsNew) {
    				contaiFile = { "type": "", "deex": [] };
    				contaiFile.type = meaningsNew.partOfSpeech;
    				meaningsNew.definitions.map(run3);
    				console.log(contaiFile, "finishedrun2");
    				fetchValue.board.push(contaiFile);
    			}

    			function run3(definitionsNew) {
    				console.log(definitionsNew.definition + "run3");
    				let deSam = { "defi": "", "exam": "" };
    				deSam.defi = definitionsNew.definition;

    				if (definitionsNew.example != undefined) {
    					deSam.exam = "Ex: " + definitionsNew.example;
    				} else {
    					deSam.exam = '';
    				}

    				contaiFile.deex.push(deSam);
    			}
    		}).catch(error => {
    			document.write(error);
    		}).finally(() => {
    			
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$v.warn(`<DefiDS> was created with unknown prop '${key}'`);
    	});

    	const click_handler = defiexam => {
    		Saving$3(defiexam.defi, $enterText);
    	};

    	$$self.$capture_state = () => ({
    		blur,
    		enterText: enterText$2,
    		stepDS: stepDS$2,
    		onMount,
    		zIndex,
    		fetchValue,
    		Saving: Saving$3,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('fetchValue' in $$props) $$invalidate(1, fetchValue = $$props.fetchValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, fetchValue, $enterText, click_handler];
    }

    let DefiDS$2 = class DefiDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1t, create_fragment$1t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DefiDS",
    			options,
    			id: create_fragment$1t.name
    		});
    	}
    };

    /* srcReading\Dictionary\SynDS.svelte generated by Svelte v3.59.2 */
    const file$1o = "srcReading\\Dictionary\\SynDS.svelte";

    function get_each_context$s(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$w(ctx) {
    	let each_1_anchor;
    	let each_value = /*synonymsList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$s(get_each_context$s(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*synonymsList*/ 4) {
    				each_value = /*synonymsList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$s(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$s(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each synonymsList as Syn}
    function create_each_block$s(ctx) {
    	let div;
    	let t_value = /*Syn*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "SynWord svelte-pln53j");
    			add_location(div, file$1o, 37, 8, 990);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*synonymsList*/ 4 && t_value !== (t_value = /*Syn*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$s.name,
    		type: "each",
    		source: "(37:8) {#each synonymsList as Syn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1s(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$w(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containerSyn svelte-pln53j");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$1o, 34, 4, 855);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$w(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1s($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText$2, 'enterText');
    	component_subscribe($$self, enterText$2, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SynDS', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDS$2.subscribe(value => {
    		if (value == 'syn') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let synonymsList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlsyn = "https://api.datamuse.com/words?rel_syn=" + huptext;

    		fetch(urlsyn).then(res => res.json()).then(result => {
    			$$invalidate(2, synonymsList = []);
    			result.map(createSyn);
    			$$invalidate(1, loaded = true);

    			function createSyn(Syn) {
    				synonymsList.push(Syn.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SynDS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS: stepDS$2,
    		enterText: enterText$2,
    		onMount,
    		zIndex,
    		loaded,
    		synonymsList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('synonymsList' in $$props) $$invalidate(2, synonymsList = $$props.synonymsList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, synonymsList];
    }

    let SynDS$2 = class SynDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1s, create_fragment$1s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SynDS",
    			options,
    			id: create_fragment$1s.name
    		});
    	}
    };

    /* srcReading\Dictionary\AntDS.svelte generated by Svelte v3.59.2 */
    const file$1n = "srcReading\\Dictionary\\AntDS.svelte";

    function get_each_context$r(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$v(ctx) {
    	let each_1_anchor;
    	let each_value = /*antonymsList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$r(get_each_context$r(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*antonymsList*/ 4) {
    				each_value = /*antonymsList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$r(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$r(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each antonymsList as Ant}
    function create_each_block$r(ctx) {
    	let div;
    	let t_value = /*Ant*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "AntWord svelte-uizxxh");
    			add_location(div, file$1n, 37, 8, 975);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*antonymsList*/ 4 && t_value !== (t_value = /*Ant*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$r.name,
    		type: "each",
    		source: "(37:8) {#each antonymsList as Ant}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1r(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$v(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containerAnt svelte-uizxxh");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$1n, 34, 4, 840);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$v(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1r($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText$2, 'enterText');
    	component_subscribe($$self, enterText$2, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AntDS', slots, []);
    	let zIndex = 0;
    	let loaded;

    	stepDS$2.subscribe(value => {
    		if (value == 'ant') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let antonymsList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlant = "https://api.datamuse.com/words?rel_ant=" + huptext;

    		fetch(urlant).then(res => res.json()).then(result => {
    			$$invalidate(2, antonymsList = []);
    			result.map(createAnt);
    			$$invalidate(1, loaded = true);

    			function createAnt(Ant) {
    				antonymsList.push(Ant.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AntDS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS: stepDS$2,
    		enterText: enterText$2,
    		onMount,
    		zIndex,
    		loaded,
    		antonymsList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('antonymsList' in $$props) $$invalidate(2, antonymsList = $$props.antonymsList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, antonymsList];
    }

    let AntDS$2 = class AntDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1r, create_fragment$1r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AntDS",
    			options,
    			id: create_fragment$1r.name
    		});
    	}
    };

    /* srcReading\Dictionary\CoADS.svelte generated by Svelte v3.59.2 */
    const file$1m = "srcReading\\Dictionary\\CoADS.svelte";

    function get_each_context$q(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$u(ctx) {
    	let each_1_anchor;
    	let each_value = /*coAList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$q(get_each_context$q(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coAList, $enterText*/ 12) {
    				each_value = /*coAList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$q(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$q(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each coAList as coA}
    function create_each_block$q(ctx) {
    	let div;
    	let t_value = /*coA*/ ctx[4] + " " + /*$enterText*/ ctx[3] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "coAWord svelte-1uk4o7l");
    			add_location(div, file$1m, 37, 8, 970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coAList, $enterText*/ 12 && t_value !== (t_value = /*coA*/ ctx[4] + " " + /*$enterText*/ ctx[3] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$q.name,
    		type: "each",
    		source: "(37:8) {#each coAList as coA}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1q(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$u(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containercoA svelte-1uk4o7l");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$1m, 34, 4, 840);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$u(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1q($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText$2, 'enterText');
    	component_subscribe($$self, enterText$2, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CoADS', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDS$2.subscribe(value => {
    		if (value == 'coA') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let coAList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlcoA = "https://api.datamuse.com/words?rel_jjb=" + huptext;

    		fetch(urlcoA).then(res => res.json()).then(result => {
    			$$invalidate(2, coAList = []);
    			result.map(createcoA);
    			$$invalidate(1, loaded = true);

    			function createcoA(coA) {
    				coAList.push(coA.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CoADS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS: stepDS$2,
    		enterText: enterText$2,
    		onMount,
    		zIndex,
    		loaded,
    		coAList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('coAList' in $$props) $$invalidate(2, coAList = $$props.coAList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, coAList, $enterText];
    }

    let CoADS$2 = class CoADS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1q, create_fragment$1q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CoADS",
    			options,
    			id: create_fragment$1q.name
    		});
    	}
    };

    /* srcReading\Dictionary\CoNDS.svelte generated by Svelte v3.59.2 */
    const file$1l = "srcReading\\Dictionary\\CoNDS.svelte";

    function get_each_context$p(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$t(ctx) {
    	let each_1_anchor;
    	let each_value = /*coNList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$p(get_each_context$p(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$enterText, coNList*/ 12) {
    				each_value = /*coNList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$p(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$p(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each coNList as coN}
    function create_each_block$p(ctx) {
    	let div;
    	let t_value = /*$enterText*/ ctx[3] + " " + /*coN*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "coNWord svelte-j0axn7");
    			add_location(div, file$1l, 37, 8, 970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$enterText, coNList*/ 12 && t_value !== (t_value = /*$enterText*/ ctx[3] + " " + /*coN*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$p.name,
    		type: "each",
    		source: "(37:8) {#each coNList as coN}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1p(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$t(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containercoN svelte-j0axn7");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$1l, 34, 4, 840);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$t(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1p($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText$2, 'enterText');
    	component_subscribe($$self, enterText$2, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CoNDS', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDS$2.subscribe(value => {
    		if (value == 'coN') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let coNList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlcoN = "https://api.datamuse.com/words?rel_jja=" + huptext;

    		fetch(urlcoN).then(res => res.json()).then(result => {
    			$$invalidate(2, coNList = []);
    			result.map(createcoN);
    			$$invalidate(1, loaded = true);

    			function createcoN(coN) {
    				coNList.push(coN.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CoNDS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS: stepDS$2,
    		enterText: enterText$2,
    		onMount,
    		zIndex,
    		loaded,
    		coNList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('coNList' in $$props) $$invalidate(2, coNList = $$props.coNList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, coNList, $enterText];
    }

    let CoNDS$2 = class CoNDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1p, create_fragment$1p, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CoNDS",
    			options,
    			id: create_fragment$1p.name
    		});
    	}
    };

    /* srcReading\Dictionary\NoResult.svelte generated by Svelte v3.59.2 */
    const file$1k = "srcReading\\Dictionary\\NoResult.svelte";

    function create_fragment$1o(ctx) {
    	let div;
    	let div_transition;
    	let current;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Opp!! No data found.";
    			attr_dev(div, "id", "noresult");
    			attr_dev(div, "class", "svelte-1qc71ks");
    			add_location(div, file$1k, 3, 0, 65);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1o($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NoResult', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NoResult> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ slide });
    	return [];
    }

    let NoResult$3 = class NoResult extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1o, create_fragment$1o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NoResult",
    			options,
    			id: create_fragment$1o.name
    		});
    	}
    };

    /* srcReading\Dictionary\Dictionary.svelte generated by Svelte v3.59.2 */
    const file$1j = "srcReading\\Dictionary\\Dictionary.svelte";

    // (48:8) {#if search}
    function create_if_block$s(ctx) {
    	let previous_key = /*$enterText*/ ctx[2];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$4(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$enterText*/ 4 && safe_not_equal(previous_key, previous_key = /*$enterText*/ ctx[2])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$4(ctx);
    				key_block.c();
    				transition_in(key_block, 1);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(48:8) {#if search}",
    		ctx
    	});

    	return block;
    }

    // (60:41) 
    function create_if_block_2$9(ctx) {
    	let noresult;
    	let current;
    	noresult = new NoResult$3({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(noresult.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(noresult, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(noresult.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(noresult.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(noresult, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(60:41) ",
    		ctx
    	});

    	return block;
    }

    // (50:12) {#if haveornot == true}
    function create_if_block_1$d(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let boarddic;
    	let t1;
    	let defids;
    	let t2;
    	let synds;
    	let t3;
    	let antds;
    	let t4;
    	let coads;
    	let t5;
    	let conds;
    	let div1_transition;
    	let current;
    	boarddic = new BoardDic$2({ $$inline: true });
    	defids = new DefiDS$2({ $$inline: true });
    	synds = new SynDS$2({ $$inline: true });
    	antds = new AntDS$2({ $$inline: true });
    	coads = new CoADS$2({ $$inline: true });
    	conds = new CoNDS$2({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			create_component(boarddic.$$.fragment);
    			t1 = space();
    			create_component(defids.$$.fragment);
    			t2 = space();
    			create_component(synds.$$.fragment);
    			t3 = space();
    			create_component(antds.$$.fragment);
    			t4 = space();
    			create_component(coads.$$.fragment);
    			t5 = space();
    			create_component(conds.$$.fragment);
    			attr_dev(div0, "id", "behindblur");
    			attr_dev(div0, "class", "svelte-mm8umt");
    			add_location(div0, file$1j, 51, 16, 1546);
    			attr_dev(div1, "id", "contInnerDic");
    			attr_dev(div1, "class", "svelte-mm8umt");
    			add_location(div1, file$1j, 50, 16, 1470);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t0);
    			mount_component(boarddic, div1, null);
    			append_dev(div1, t1);
    			mount_component(defids, div1, null);
    			append_dev(div1, t2);
    			mount_component(synds, div1, null);
    			append_dev(div1, t3);
    			mount_component(antds, div1, null);
    			append_dev(div1, t4);
    			mount_component(coads, div1, null);
    			append_dev(div1, t5);
    			mount_component(conds, div1, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(boarddic.$$.fragment, local);
    			transition_in(defids.$$.fragment, local);
    			transition_in(synds.$$.fragment, local);
    			transition_in(antds.$$.fragment, local);
    			transition_in(coads.$$.fragment, local);
    			transition_in(conds.$$.fragment, local);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 500 }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(boarddic.$$.fragment, local);
    			transition_out(defids.$$.fragment, local);
    			transition_out(synds.$$.fragment, local);
    			transition_out(antds.$$.fragment, local);
    			transition_out(coads.$$.fragment, local);
    			transition_out(conds.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 500 }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(boarddic);
    			destroy_component(defids);
    			destroy_component(synds);
    			destroy_component(antds);
    			destroy_component(coads);
    			destroy_component(conds);
    			if (detaching && div1_transition) div1_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(50:12) {#if haveornot == true}",
    		ctx
    	});

    	return block;
    }

    // (49:8) {#key $enterText}
    function create_key_block$4(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$d, create_if_block_2$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*haveornot*/ ctx[1] == true) return 0;
    		if (/*haveornot*/ ctx[1] == false) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$4.name,
    		type: "key",
    		source: "(49:8) {#key $enterText}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1n(ctx) {
    	let button0;
    	let t0;
    	let div2;
    	let div0;
    	let input;
    	let t1;
    	let button1;
    	let t3;
    	let div1;
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*search*/ ctx[0] && create_if_block$s(ctx);

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = ">>";
    			t3 = space();
    			div1 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(button0, "id", "backgroundexit");
    			attr_dev(button0, "class", "svelte-mm8umt");
    			add_location(button0, file$1j, 38, 0, 1037);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", "enterWord");
    			attr_dev(input, "autocomplete", "off");
    			attr_dev(input, "class", "svelte-mm8umt");
    			add_location(input, file$1j, 42, 4, 1205);
    			attr_dev(button1, "id", "SearchDic");
    			attr_dev(button1, "class", "svelte-mm8umt");
    			add_location(button1, file$1j, 43, 4, 1266);
    			attr_dev(div0, "id", "containSearch");
    			attr_dev(div0, "class", "svelte-mm8umt");
    			add_location(div0, file$1j, 41, 4, 1174);
    			attr_dev(div1, "id", "containerDic");
    			attr_dev(div1, "class", "svelte-mm8umt");
    			add_location(div1, file$1j, 46, 4, 1342);
    			attr_dev(div2, "id", "containerDictionary");
    			attr_dev(div2, "class", "svelte-mm8umt");
    			add_location(div2, file$1j, 39, 0, 1096);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, input);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*Exit*/ ctx[4], false, false, false, false),
    					listen_dev(button1, "click", /*change*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*search*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*search*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$s(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 500 }, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 500 }, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1n($$self, $$props, $$invalidate) {
    	let $dictionaryDS;
    	let $enterText;
    	let $stepDS;
    	validate_store(dictionaryDS$2, 'dictionaryDS');
    	component_subscribe($$self, dictionaryDS$2, $$value => $$invalidate(5, $dictionaryDS = $$value));
    	validate_store(enterText$2, 'enterText');
    	component_subscribe($$self, enterText$2, $$value => $$invalidate(2, $enterText = $$value));
    	validate_store(stepDS$2, 'stepDS');
    	component_subscribe($$self, stepDS$2, $$value => $$invalidate(6, $stepDS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dictionary', slots, []);
    	let search = false;
    	let haveornot = 'no';

    	function change() {
    		set_store_value(stepDS$2, $stepDS = 'defi', $stepDS);
    		$$invalidate(0, search = true);
    		let text = document.getElementById('enterWord').value;
    		var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + `${text}`;

    		fetch(link).then(res => {
    			if (res.ok) {
    				$$invalidate(1, haveornot = true);
    				set_store_value(enterText$2, $enterText = text, $enterText);
    			} else {
    				$$invalidate(1, haveornot = false);
    			}
    		});
    	}

    	function Exit() {
    		set_store_value(dictionaryDS$2, $dictionaryDS = false, $dictionaryDS);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dictionary> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		dictionaryDS: dictionaryDS$2,
    		enterText: enterText$2,
    		stepDS: stepDS$2,
    		BoardDic: BoardDic$2,
    		DefiDs: DefiDS$2,
    		SynDs: SynDS$2,
    		AntDs: AntDS$2,
    		CoAds: CoADS$2,
    		CoNds: CoNDS$2,
    		NoResult: NoResult$3,
    		slide,
    		search,
    		haveornot,
    		change,
    		Exit,
    		$dictionaryDS,
    		$enterText,
    		$stepDS
    	});

    	$$self.$inject_state = $$props => {
    		if ('search' in $$props) $$invalidate(0, search = $$props.search);
    		if ('haveornot' in $$props) $$invalidate(1, haveornot = $$props.haveornot);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [search, haveornot, $enterText, change, Exit];
    }

    let Dictionary$2 = class Dictionary extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1n, create_fragment$1n, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dictionary",
    			options,
    			id: create_fragment$1n.name
    		});
    	}
    };

    var runtime = {exports: {}};

    /**
     * Copyright (c) 2014-present, Facebook, Inc.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    (function (module) {
    	var runtime = (function (exports) {

    	  var Op = Object.prototype;
    	  var hasOwn = Op.hasOwnProperty;
    	  var defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; };
    	  var undefined$1; // More compressible than void 0.
    	  var $Symbol = typeof Symbol === "function" ? Symbol : {};
    	  var iteratorSymbol = $Symbol.iterator || "@@iterator";
    	  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    	  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

    	  function define(obj, key, value) {
    	    Object.defineProperty(obj, key, {
    	      value: value,
    	      enumerable: true,
    	      configurable: true,
    	      writable: true
    	    });
    	    return obj[key];
    	  }
    	  try {
    	    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    	    define({}, "");
    	  } catch (err) {
    	    define = function(obj, key, value) {
    	      return obj[key] = value;
    	    };
    	  }

    	  function wrap(innerFn, outerFn, self, tryLocsList) {
    	    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    	    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    	    var generator = Object.create(protoGenerator.prototype);
    	    var context = new Context(tryLocsList || []);

    	    // The ._invoke method unifies the implementations of the .next,
    	    // .throw, and .return methods.
    	    defineProperty(generator, "_invoke", { value: makeInvokeMethod(innerFn, self, context) });

    	    return generator;
    	  }
    	  exports.wrap = wrap;

    	  // Try/catch helper to minimize deoptimizations. Returns a completion
    	  // record like context.tryEntries[i].completion. This interface could
    	  // have been (and was previously) designed to take a closure to be
    	  // invoked without arguments, but in all the cases we care about we
    	  // already have an existing method we want to call, so there's no need
    	  // to create a new function object. We can even get away with assuming
    	  // the method takes exactly one argument, since that happens to be true
    	  // in every case, so we don't have to touch the arguments object. The
    	  // only additional allocation required is the completion record, which
    	  // has a stable shape and so hopefully should be cheap to allocate.
    	  function tryCatch(fn, obj, arg) {
    	    try {
    	      return { type: "normal", arg: fn.call(obj, arg) };
    	    } catch (err) {
    	      return { type: "throw", arg: err };
    	    }
    	  }

    	  var GenStateSuspendedStart = "suspendedStart";
    	  var GenStateSuspendedYield = "suspendedYield";
    	  var GenStateExecuting = "executing";
    	  var GenStateCompleted = "completed";

    	  // Returning this object from the innerFn has the same effect as
    	  // breaking out of the dispatch switch statement.
    	  var ContinueSentinel = {};

    	  // Dummy constructor functions that we use as the .constructor and
    	  // .constructor.prototype properties for functions that return Generator
    	  // objects. For full spec compliance, you may wish to configure your
    	  // minifier not to mangle the names of these two functions.
    	  function Generator() {}
    	  function GeneratorFunction() {}
    	  function GeneratorFunctionPrototype() {}

    	  // This is a polyfill for %IteratorPrototype% for environments that
    	  // don't natively support it.
    	  var IteratorPrototype = {};
    	  define(IteratorPrototype, iteratorSymbol, function () {
    	    return this;
    	  });

    	  var getProto = Object.getPrototypeOf;
    	  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    	  if (NativeIteratorPrototype &&
    	      NativeIteratorPrototype !== Op &&
    	      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    	    // This environment has a native %IteratorPrototype%; use it instead
    	    // of the polyfill.
    	    IteratorPrototype = NativeIteratorPrototype;
    	  }

    	  var Gp = GeneratorFunctionPrototype.prototype =
    	    Generator.prototype = Object.create(IteratorPrototype);
    	  GeneratorFunction.prototype = GeneratorFunctionPrototype;
    	  defineProperty(Gp, "constructor", { value: GeneratorFunctionPrototype, configurable: true });
    	  defineProperty(
    	    GeneratorFunctionPrototype,
    	    "constructor",
    	    { value: GeneratorFunction, configurable: true }
    	  );
    	  GeneratorFunction.displayName = define(
    	    GeneratorFunctionPrototype,
    	    toStringTagSymbol,
    	    "GeneratorFunction"
    	  );

    	  // Helper for defining the .next, .throw, and .return methods of the
    	  // Iterator interface in terms of a single ._invoke method.
    	  function defineIteratorMethods(prototype) {
    	    ["next", "throw", "return"].forEach(function(method) {
    	      define(prototype, method, function(arg) {
    	        return this._invoke(method, arg);
    	      });
    	    });
    	  }

    	  exports.isGeneratorFunction = function(genFun) {
    	    var ctor = typeof genFun === "function" && genFun.constructor;
    	    return ctor
    	      ? ctor === GeneratorFunction ||
    	        // For the native GeneratorFunction constructor, the best we can
    	        // do is to check its .name property.
    	        (ctor.displayName || ctor.name) === "GeneratorFunction"
    	      : false;
    	  };

    	  exports.mark = function(genFun) {
    	    if (Object.setPrototypeOf) {
    	      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    	    } else {
    	      genFun.__proto__ = GeneratorFunctionPrototype;
    	      define(genFun, toStringTagSymbol, "GeneratorFunction");
    	    }
    	    genFun.prototype = Object.create(Gp);
    	    return genFun;
    	  };

    	  // Within the body of any async function, `await x` is transformed to
    	  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    	  // `hasOwn.call(value, "__await")` to determine if the yielded value is
    	  // meant to be awaited.
    	  exports.awrap = function(arg) {
    	    return { __await: arg };
    	  };

    	  function AsyncIterator(generator, PromiseImpl) {
    	    function invoke(method, arg, resolve, reject) {
    	      var record = tryCatch(generator[method], generator, arg);
    	      if (record.type === "throw") {
    	        reject(record.arg);
    	      } else {
    	        var result = record.arg;
    	        var value = result.value;
    	        if (value &&
    	            typeof value === "object" &&
    	            hasOwn.call(value, "__await")) {
    	          return PromiseImpl.resolve(value.__await).then(function(value) {
    	            invoke("next", value, resolve, reject);
    	          }, function(err) {
    	            invoke("throw", err, resolve, reject);
    	          });
    	        }

    	        return PromiseImpl.resolve(value).then(function(unwrapped) {
    	          // When a yielded Promise is resolved, its final value becomes
    	          // the .value of the Promise<{value,done}> result for the
    	          // current iteration.
    	          result.value = unwrapped;
    	          resolve(result);
    	        }, function(error) {
    	          // If a rejected Promise was yielded, throw the rejection back
    	          // into the async generator function so it can be handled there.
    	          return invoke("throw", error, resolve, reject);
    	        });
    	      }
    	    }

    	    var previousPromise;

    	    function enqueue(method, arg) {
    	      function callInvokeWithMethodAndArg() {
    	        return new PromiseImpl(function(resolve, reject) {
    	          invoke(method, arg, resolve, reject);
    	        });
    	      }

    	      return previousPromise =
    	        // If enqueue has been called before, then we want to wait until
    	        // all previous Promises have been resolved before calling invoke,
    	        // so that results are always delivered in the correct order. If
    	        // enqueue has not been called before, then it is important to
    	        // call invoke immediately, without waiting on a callback to fire,
    	        // so that the async generator function has the opportunity to do
    	        // any necessary setup in a predictable way. This predictability
    	        // is why the Promise constructor synchronously invokes its
    	        // executor callback, and why async functions synchronously
    	        // execute code before the first await. Since we implement simple
    	        // async functions in terms of async generators, it is especially
    	        // important to get this right, even though it requires care.
    	        previousPromise ? previousPromise.then(
    	          callInvokeWithMethodAndArg,
    	          // Avoid propagating failures to Promises returned by later
    	          // invocations of the iterator.
    	          callInvokeWithMethodAndArg
    	        ) : callInvokeWithMethodAndArg();
    	    }

    	    // Define the unified helper method that is used to implement .next,
    	    // .throw, and .return (see defineIteratorMethods).
    	    defineProperty(this, "_invoke", { value: enqueue });
    	  }

    	  defineIteratorMethods(AsyncIterator.prototype);
    	  define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    	    return this;
    	  });
    	  exports.AsyncIterator = AsyncIterator;

    	  // Note that simple async functions are implemented on top of
    	  // AsyncIterator objects; they just return a Promise for the value of
    	  // the final result produced by the iterator.
    	  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    	    if (PromiseImpl === void 0) PromiseImpl = Promise;

    	    var iter = new AsyncIterator(
    	      wrap(innerFn, outerFn, self, tryLocsList),
    	      PromiseImpl
    	    );

    	    return exports.isGeneratorFunction(outerFn)
    	      ? iter // If outerFn is a generator, return the full iterator.
    	      : iter.next().then(function(result) {
    	          return result.done ? result.value : iter.next();
    	        });
    	  };

    	  function makeInvokeMethod(innerFn, self, context) {
    	    var state = GenStateSuspendedStart;

    	    return function invoke(method, arg) {
    	      if (state === GenStateExecuting) {
    	        throw new Error("Generator is already running");
    	      }

    	      if (state === GenStateCompleted) {
    	        if (method === "throw") {
    	          throw arg;
    	        }

    	        // Be forgiving, per 25.3.3.3.3 of the spec:
    	        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
    	        return doneResult();
    	      }

    	      context.method = method;
    	      context.arg = arg;

    	      while (true) {
    	        var delegate = context.delegate;
    	        if (delegate) {
    	          var delegateResult = maybeInvokeDelegate(delegate, context);
    	          if (delegateResult) {
    	            if (delegateResult === ContinueSentinel) continue;
    	            return delegateResult;
    	          }
    	        }

    	        if (context.method === "next") {
    	          // Setting context._sent for legacy support of Babel's
    	          // function.sent implementation.
    	          context.sent = context._sent = context.arg;

    	        } else if (context.method === "throw") {
    	          if (state === GenStateSuspendedStart) {
    	            state = GenStateCompleted;
    	            throw context.arg;
    	          }

    	          context.dispatchException(context.arg);

    	        } else if (context.method === "return") {
    	          context.abrupt("return", context.arg);
    	        }

    	        state = GenStateExecuting;

    	        var record = tryCatch(innerFn, self, context);
    	        if (record.type === "normal") {
    	          // If an exception is thrown from innerFn, we leave state ===
    	          // GenStateExecuting and loop back for another invocation.
    	          state = context.done
    	            ? GenStateCompleted
    	            : GenStateSuspendedYield;

    	          if (record.arg === ContinueSentinel) {
    	            continue;
    	          }

    	          return {
    	            value: record.arg,
    	            done: context.done
    	          };

    	        } else if (record.type === "throw") {
    	          state = GenStateCompleted;
    	          // Dispatch the exception by looping back around to the
    	          // context.dispatchException(context.arg) call above.
    	          context.method = "throw";
    	          context.arg = record.arg;
    	        }
    	      }
    	    };
    	  }

    	  // Call delegate.iterator[context.method](context.arg) and handle the
    	  // result, either by returning a { value, done } result from the
    	  // delegate iterator, or by modifying context.method and context.arg,
    	  // setting context.delegate to null, and returning the ContinueSentinel.
    	  function maybeInvokeDelegate(delegate, context) {
    	    var methodName = context.method;
    	    var method = delegate.iterator[methodName];
    	    if (method === undefined$1) {
    	      // A .throw or .return when the delegate iterator has no .throw
    	      // method, or a missing .next mehtod, always terminate the
    	      // yield* loop.
    	      context.delegate = null;

    	      // Note: ["return"] must be used for ES3 parsing compatibility.
    	      if (methodName === "throw" && delegate.iterator["return"]) {
    	        // If the delegate iterator has a return method, give it a
    	        // chance to clean up.
    	        context.method = "return";
    	        context.arg = undefined$1;
    	        maybeInvokeDelegate(delegate, context);

    	        if (context.method === "throw") {
    	          // If maybeInvokeDelegate(context) changed context.method from
    	          // "return" to "throw", let that override the TypeError below.
    	          return ContinueSentinel;
    	        }
    	      }
    	      if (methodName !== "return") {
    	        context.method = "throw";
    	        context.arg = new TypeError(
    	          "The iterator does not provide a '" + methodName + "' method");
    	      }

    	      return ContinueSentinel;
    	    }

    	    var record = tryCatch(method, delegate.iterator, context.arg);

    	    if (record.type === "throw") {
    	      context.method = "throw";
    	      context.arg = record.arg;
    	      context.delegate = null;
    	      return ContinueSentinel;
    	    }

    	    var info = record.arg;

    	    if (! info) {
    	      context.method = "throw";
    	      context.arg = new TypeError("iterator result is not an object");
    	      context.delegate = null;
    	      return ContinueSentinel;
    	    }

    	    if (info.done) {
    	      // Assign the result of the finished delegate to the temporary
    	      // variable specified by delegate.resultName (see delegateYield).
    	      context[delegate.resultName] = info.value;

    	      // Resume execution at the desired location (see delegateYield).
    	      context.next = delegate.nextLoc;

    	      // If context.method was "throw" but the delegate handled the
    	      // exception, let the outer generator proceed normally. If
    	      // context.method was "next", forget context.arg since it has been
    	      // "consumed" by the delegate iterator. If context.method was
    	      // "return", allow the original .return call to continue in the
    	      // outer generator.
    	      if (context.method !== "return") {
    	        context.method = "next";
    	        context.arg = undefined$1;
    	      }

    	    } else {
    	      // Re-yield the result returned by the delegate method.
    	      return info;
    	    }

    	    // The delegate iterator is finished, so forget it and continue with
    	    // the outer generator.
    	    context.delegate = null;
    	    return ContinueSentinel;
    	  }

    	  // Define Generator.prototype.{next,throw,return} in terms of the
    	  // unified ._invoke helper method.
    	  defineIteratorMethods(Gp);

    	  define(Gp, toStringTagSymbol, "Generator");

    	  // A Generator should always return itself as the iterator object when the
    	  // @@iterator function is called on it. Some browsers' implementations of the
    	  // iterator prototype chain incorrectly implement this, causing the Generator
    	  // object to not be returned from this call. This ensures that doesn't happen.
    	  // See https://github.com/facebook/regenerator/issues/274 for more details.
    	  define(Gp, iteratorSymbol, function() {
    	    return this;
    	  });

    	  define(Gp, "toString", function() {
    	    return "[object Generator]";
    	  });

    	  function pushTryEntry(locs) {
    	    var entry = { tryLoc: locs[0] };

    	    if (1 in locs) {
    	      entry.catchLoc = locs[1];
    	    }

    	    if (2 in locs) {
    	      entry.finallyLoc = locs[2];
    	      entry.afterLoc = locs[3];
    	    }

    	    this.tryEntries.push(entry);
    	  }

    	  function resetTryEntry(entry) {
    	    var record = entry.completion || {};
    	    record.type = "normal";
    	    delete record.arg;
    	    entry.completion = record;
    	  }

    	  function Context(tryLocsList) {
    	    // The root entry object (effectively a try statement without a catch
    	    // or a finally block) gives us a place to store values thrown from
    	    // locations where there is no enclosing try statement.
    	    this.tryEntries = [{ tryLoc: "root" }];
    	    tryLocsList.forEach(pushTryEntry, this);
    	    this.reset(true);
    	  }

    	  exports.keys = function(val) {
    	    var object = Object(val);
    	    var keys = [];
    	    for (var key in object) {
    	      keys.push(key);
    	    }
    	    keys.reverse();

    	    // Rather than returning an object with a next method, we keep
    	    // things simple and return the next function itself.
    	    return function next() {
    	      while (keys.length) {
    	        var key = keys.pop();
    	        if (key in object) {
    	          next.value = key;
    	          next.done = false;
    	          return next;
    	        }
    	      }

    	      // To avoid creating an additional object, we just hang the .value
    	      // and .done properties off the next function object itself. This
    	      // also ensures that the minifier will not anonymize the function.
    	      next.done = true;
    	      return next;
    	    };
    	  };

    	  function values(iterable) {
    	    if (iterable) {
    	      var iteratorMethod = iterable[iteratorSymbol];
    	      if (iteratorMethod) {
    	        return iteratorMethod.call(iterable);
    	      }

    	      if (typeof iterable.next === "function") {
    	        return iterable;
    	      }

    	      if (!isNaN(iterable.length)) {
    	        var i = -1, next = function next() {
    	          while (++i < iterable.length) {
    	            if (hasOwn.call(iterable, i)) {
    	              next.value = iterable[i];
    	              next.done = false;
    	              return next;
    	            }
    	          }

    	          next.value = undefined$1;
    	          next.done = true;

    	          return next;
    	        };

    	        return next.next = next;
    	      }
    	    }

    	    // Return an iterator with no values.
    	    return { next: doneResult };
    	  }
    	  exports.values = values;

    	  function doneResult() {
    	    return { value: undefined$1, done: true };
    	  }

    	  Context.prototype = {
    	    constructor: Context,

    	    reset: function(skipTempReset) {
    	      this.prev = 0;
    	      this.next = 0;
    	      // Resetting context._sent for legacy support of Babel's
    	      // function.sent implementation.
    	      this.sent = this._sent = undefined$1;
    	      this.done = false;
    	      this.delegate = null;

    	      this.method = "next";
    	      this.arg = undefined$1;

    	      this.tryEntries.forEach(resetTryEntry);

    	      if (!skipTempReset) {
    	        for (var name in this) {
    	          // Not sure about the optimal order of these conditions:
    	          if (name.charAt(0) === "t" &&
    	              hasOwn.call(this, name) &&
    	              !isNaN(+name.slice(1))) {
    	            this[name] = undefined$1;
    	          }
    	        }
    	      }
    	    },

    	    stop: function() {
    	      this.done = true;

    	      var rootEntry = this.tryEntries[0];
    	      var rootRecord = rootEntry.completion;
    	      if (rootRecord.type === "throw") {
    	        throw rootRecord.arg;
    	      }

    	      return this.rval;
    	    },

    	    dispatchException: function(exception) {
    	      if (this.done) {
    	        throw exception;
    	      }

    	      var context = this;
    	      function handle(loc, caught) {
    	        record.type = "throw";
    	        record.arg = exception;
    	        context.next = loc;

    	        if (caught) {
    	          // If the dispatched exception was caught by a catch block,
    	          // then let that catch block handle the exception normally.
    	          context.method = "next";
    	          context.arg = undefined$1;
    	        }

    	        return !! caught;
    	      }

    	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
    	        var entry = this.tryEntries[i];
    	        var record = entry.completion;

    	        if (entry.tryLoc === "root") {
    	          // Exception thrown outside of any try block that could handle
    	          // it, so set the completion value of the entire function to
    	          // throw the exception.
    	          return handle("end");
    	        }

    	        if (entry.tryLoc <= this.prev) {
    	          var hasCatch = hasOwn.call(entry, "catchLoc");
    	          var hasFinally = hasOwn.call(entry, "finallyLoc");

    	          if (hasCatch && hasFinally) {
    	            if (this.prev < entry.catchLoc) {
    	              return handle(entry.catchLoc, true);
    	            } else if (this.prev < entry.finallyLoc) {
    	              return handle(entry.finallyLoc);
    	            }

    	          } else if (hasCatch) {
    	            if (this.prev < entry.catchLoc) {
    	              return handle(entry.catchLoc, true);
    	            }

    	          } else if (hasFinally) {
    	            if (this.prev < entry.finallyLoc) {
    	              return handle(entry.finallyLoc);
    	            }

    	          } else {
    	            throw new Error("try statement without catch or finally");
    	          }
    	        }
    	      }
    	    },

    	    abrupt: function(type, arg) {
    	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
    	        var entry = this.tryEntries[i];
    	        if (entry.tryLoc <= this.prev &&
    	            hasOwn.call(entry, "finallyLoc") &&
    	            this.prev < entry.finallyLoc) {
    	          var finallyEntry = entry;
    	          break;
    	        }
    	      }

    	      if (finallyEntry &&
    	          (type === "break" ||
    	           type === "continue") &&
    	          finallyEntry.tryLoc <= arg &&
    	          arg <= finallyEntry.finallyLoc) {
    	        // Ignore the finally entry if control is not jumping to a
    	        // location outside the try/catch block.
    	        finallyEntry = null;
    	      }

    	      var record = finallyEntry ? finallyEntry.completion : {};
    	      record.type = type;
    	      record.arg = arg;

    	      if (finallyEntry) {
    	        this.method = "next";
    	        this.next = finallyEntry.finallyLoc;
    	        return ContinueSentinel;
    	      }

    	      return this.complete(record);
    	    },

    	    complete: function(record, afterLoc) {
    	      if (record.type === "throw") {
    	        throw record.arg;
    	      }

    	      if (record.type === "break" ||
    	          record.type === "continue") {
    	        this.next = record.arg;
    	      } else if (record.type === "return") {
    	        this.rval = this.arg = record.arg;
    	        this.method = "return";
    	        this.next = "end";
    	      } else if (record.type === "normal" && afterLoc) {
    	        this.next = afterLoc;
    	      }

    	      return ContinueSentinel;
    	    },

    	    finish: function(finallyLoc) {
    	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
    	        var entry = this.tryEntries[i];
    	        if (entry.finallyLoc === finallyLoc) {
    	          this.complete(entry.completion, entry.afterLoc);
    	          resetTryEntry(entry);
    	          return ContinueSentinel;
    	        }
    	      }
    	    },

    	    "catch": function(tryLoc) {
    	      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
    	        var entry = this.tryEntries[i];
    	        if (entry.tryLoc === tryLoc) {
    	          var record = entry.completion;
    	          if (record.type === "throw") {
    	            var thrown = record.arg;
    	            resetTryEntry(entry);
    	          }
    	          return thrown;
    	        }
    	      }

    	      // The context.catch method must only be called with a location
    	      // argument that corresponds to a known catch block.
    	      throw new Error("illegal catch attempt");
    	    },

    	    delegateYield: function(iterable, resultName, nextLoc) {
    	      this.delegate = {
    	        iterator: values(iterable),
    	        resultName: resultName,
    	        nextLoc: nextLoc
    	      };

    	      if (this.method === "next") {
    	        // Deliberately forget the last sent value so that we don't
    	        // accidentally pass it on to the delegate.
    	        this.arg = undefined$1;
    	      }

    	      return ContinueSentinel;
    	    }
    	  };

    	  // Regardless of whether this script is executing as a CommonJS module
    	  // or not, return the runtime object so that we can declare the variable
    	  // regeneratorRuntime in the outer scope, which allows this module to be
    	  // injected easily by `bin/regenerator --include-runtime script.js`.
    	  return exports;

    	}(
    	  // If this script is executing as a CommonJS module, use module.exports
    	  // as the regeneratorRuntime namespace. Otherwise create a new empty
    	  // object. Either way, the resulting object will be used to initialize
    	  // the regeneratorRuntime variable at the top of this file.
    	  module.exports 
    	));

    	try {
    	  regeneratorRuntime = runtime;
    	} catch (accidentalStrictMode) {
    	  // This module should not be running in strict mode, so the above
    	  // assignment should always work unless something is misconfigured. Just
    	  // in case runtime.js accidentally runs in strict mode, in modern engines
    	  // we can explicitly access globalThis. In older engines we can escape
    	  // strict mode using a global Function call. This could conceivably fail
    	  // if a Content Security Policy forbids using Function, but in that case
    	  // the proper solution is to fix the accidental strict mode problem. If
    	  // you've misconfigured your bundler to force strict mode and applied a
    	  // CSP to forbid Function, and you're not willing to fix either of those
    	  // problems, please detail your unique predicament in a GitHub issue.
    	  if (typeof globalThis === "object") {
    	    globalThis.regeneratorRuntime = runtime;
    	  } else {
    	    Function("r", "regeneratorRuntime = r")(runtime);
    	  }
    	} 
    } (runtime));

    var getId$3 = (prefix, cnt) => (
      `${prefix}-${cnt}-${Math.random().toString(16).slice(3, 8)}`
    );

    const getId$2 = getId$3;

    let jobCounter = 0;

    var createJob$2 = ({
      id: _id,
      action,
      payload = {},
    }) => {
      let id = _id;
      if (typeof id === 'undefined') {
        id = getId$2('Job', jobCounter);
        jobCounter += 1;
      }

      return {
        id,
        action,
        payload,
      };
    };

    var log$2 = {};

    let logging = false;

    log$2.logging = logging;

    log$2.setLogging = (_logging) => {
      logging = _logging;
    };

    log$2.log = (...args) => (logging ? console.log.apply(undefined, args) : null);

    const createJob$1 = createJob$2;
    const { log: log$1 } = log$2;
    const getId$1 = getId$3;

    let schedulerCounter = 0;

    var createScheduler$1 = () => {
      const id = getId$1('Scheduler', schedulerCounter);
      const workers = {};
      const runningWorkers = {};
      let jobQueue = [];

      schedulerCounter += 1;

      const getQueueLen = () => jobQueue.length;
      const getNumWorkers = () => Object.keys(workers).length;

      const dequeue = () => {
        if (jobQueue.length !== 0) {
          const wIds = Object.keys(workers);
          for (let i = 0; i < wIds.length; i += 1) {
            if (typeof runningWorkers[wIds[i]] === 'undefined') {
              jobQueue[0](workers[wIds[i]]);
              break;
            }
          }
        }
      };

      const queue = (action, payload) => (
        new Promise((resolve, reject) => {
          const job = createJob$1({ action, payload });
          jobQueue.push(async (w) => {
            jobQueue.shift();
            runningWorkers[w.id] = job;
            try {
              resolve(await w[action].apply(undefined, [...payload, job.id]));
            } catch (err) {
              reject(err);
            } finally {
              delete runningWorkers[w.id];
              dequeue();
            }
          });
          log$1(`[${id}]: Add ${job.id} to JobQueue`);
          log$1(`[${id}]: JobQueue length=${jobQueue.length}`);
          dequeue();
        })
      );

      const addWorker = (w) => {
        workers[w.id] = w;
        log$1(`[${id}]: Add ${w.id}`);
        log$1(`[${id}]: Number of workers=${getNumWorkers()}`);
        dequeue();
        return w.id;
      };

      const addJob = async (action, ...payload) => {
        if (getNumWorkers() === 0) {
          throw Error(`[${id}]: You need to have at least one worker before adding jobs`);
        }
        return queue(action, payload);
      };

      const terminate = async () => {
        Object.keys(workers).forEach(async (wid) => {
          await workers[wid].terminate();
        });
        jobQueue = [];
      };

      return {
        addWorker,
        addJob,
        terminate,
        getQueueLen,
        getNumWorkers,
      };
    };

    function commonjsRequire(path) {
    	throw new Error('Could not dynamically require "' + path + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
    }

    // https://github.com/electron/electron/issues/2288
    function isElectron$1() {
        // Renderer process
        if (typeof window !== 'undefined' && typeof window.process === 'object' && window.process.type === 'renderer') {
            return true;
        }

        // Main process
        if (typeof process !== 'undefined' && typeof process.versions === 'object' && !!process.versions.electron) {
            return true;
        }

        // Detect the user agent when the `nodeIntegration` option is set to false
        if (typeof navigator === 'object' && typeof navigator.userAgent === 'string' && navigator.userAgent.indexOf('Electron') >= 0) {
            return true;
        }

        return false;
    }

    var isElectron_1 = isElectron$1;

    const isElectron = isElectron_1;

    var getEnvironment = (key) => {
      const env = {};

      if (typeof WorkerGlobalScope !== 'undefined') {
        env.type = 'webworker';
      } else if (isElectron()) {
        env.type = 'electron';
      } else if (typeof document === 'object') {
        env.type = 'browser';
      } else if (typeof process === 'object' && typeof commonjsRequire === 'function') {
        env.type = 'node';
      }

      if (typeof key === 'undefined') {
        return env;
      }

      return env[key];
    };

    const isBrowser = getEnvironment('type') === 'browser';

    const resolveURL = isBrowser ? s => (new URL(s, window.location.href)).href : s => s; // eslint-disable-line

    var resolvePaths$1 = (options) => {
      const opts = { ...options };
      ['corePath', 'workerPath', 'langPath'].forEach((key) => {
        if (options[key]) {
          opts[key] = resolveURL(opts[key]);
        }
      });
      return opts;
    };

    /**
     * In the recognition result of tesseract, there
     * is a deep JSON object for details, it has around
     *
     * The result of dump.js is a big JSON tree
     * which can be easily serialized (for instance
     * to be sent from a webworker to the main app
     * or through Node's IPC), but we want
     * a (circular) DOM-like interface for walking
     * through the data.
     *
     * @fileoverview DOM-like interface for walking through data
     * @author Kevin Kwok <antimatter15@gmail.com>
     * @author Guillermo Webster <gui@mit.edu>
     * @author Jerome Wu <jeromewus@gmail.com>
     */

    var circularize$1 = (page) => {
      const blocks = [];
      const paragraphs = [];
      const lines = [];
      const words = [];
      const symbols = [];

      if (page.blocks) {
        page.blocks.forEach((block) => {
          block.paragraphs.forEach((paragraph) => {
            paragraph.lines.forEach((line) => {
              line.words.forEach((word) => {
                word.symbols.forEach((sym) => {
                  symbols.push({
                    ...sym, page, block, paragraph, line, word,
                  });
                });
                words.push({
                  ...word, page, block, paragraph, line,
                });
              });
              lines.push({
                ...line, page, block, paragraph,
              });
            });
            paragraphs.push({
              ...paragraph, page, block,
            });
          });
          blocks.push({
            ...block, page,
          });
        });
      }

      return {
        ...page, blocks, paragraphs, lines, words, symbols,
      };
    };

    /*
     * OEM = OCR Engine Mode, and there are 4 possible modes.
     *
     * By default tesseract.js uses LSTM_ONLY mode.
     *
     */

    var OEM$2 = {
      TESSERACT_ONLY: 0,
      LSTM_ONLY: 1,
      TESSERACT_LSTM_COMBINED: 2,
      DEFAULT: 3,
    };

    var name = "tesseract.js";
    var version$1 = "5.0.3";
    var description = "Pure Javascript Multilingual OCR";
    var main = "src/index.js";
    var types = "src/index.d.ts";
    var unpkg = "dist/tesseract.min.js";
    var jsdelivr = "dist/tesseract.min.js";
    var scripts = {
    	start: "node scripts/server.js",
    	build: "rimraf dist && webpack --config scripts/webpack.config.prod.js && rollup -c scripts/rollup.esm.mjs",
    	"profile:tesseract": "webpack-bundle-analyzer dist/tesseract-stats.json",
    	"profile:worker": "webpack-bundle-analyzer dist/worker-stats.json",
    	prepublishOnly: "npm run build",
    	wait: "rimraf dist && wait-on http://localhost:3000/dist/tesseract.min.js",
    	test: "npm-run-all -p -r start test:all",
    	"test:all": "npm-run-all wait test:browser:* test:node:all",
    	"test:node": "nyc mocha --exit --bail --require ./scripts/test-helper.js",
    	"test:node:all": "npm run test:node -- ./tests/*.test.js",
    	"test:browser-tpl": "mocha-headless-chrome -a incognito -a no-sandbox -a disable-setuid-sandbox -a disable-logging -t 300000",
    	"test:browser:detect": "npm run test:browser-tpl -- -f ./tests/detect.test.html",
    	"test:browser:recognize": "npm run test:browser-tpl -- -f ./tests/recognize.test.html",
    	"test:browser:scheduler": "npm run test:browser-tpl -- -f ./tests/scheduler.test.html",
    	"test:browser:FS": "npm run test:browser-tpl -- -f ./tests/FS.test.html",
    	lint: "eslint src",
    	"lint:fix": "eslint --fix src",
    	postinstall: "opencollective-postinstall || true"
    };
    var browser$1 = {
    	"./src/worker/node/index.js": "./src/worker/browser/index.js"
    };
    var author = "";
    var contributors = [
    	"jeromewu"
    ];
    var license = "Apache-2.0";
    var devDependencies = {
    	"@babel/core": "^7.21.4",
    	"@babel/eslint-parser": "^7.21.3",
    	"@babel/preset-env": "^7.21.4",
    	"@rollup/plugin-commonjs": "^24.1.0",
    	acorn: "^8.8.2",
    	"babel-loader": "^9.1.2",
    	buffer: "^6.0.3",
    	cors: "^2.8.5",
    	eslint: "^7.32.0",
    	"eslint-config-airbnb-base": "^14.2.1",
    	"eslint-plugin-import": "^2.27.5",
    	"expect.js": "^0.3.1",
    	express: "^4.18.2",
    	mocha: "^10.2.0",
    	"mocha-headless-chrome": "^4.0.0",
    	"npm-run-all": "^4.1.5",
    	nyc: "^15.1.0",
    	rimraf: "^5.0.0",
    	rollup: "^3.20.7",
    	"wait-on": "^7.0.1",
    	webpack: "^5.79.0",
    	"webpack-bundle-analyzer": "^4.8.0",
    	"webpack-cli": "^5.0.1",
    	"webpack-dev-middleware": "^6.0.2",
    	"rollup-plugin-sourcemaps": "^0.6.3"
    };
    var dependencies = {
    	"bmp-js": "^0.1.0",
    	"idb-keyval": "^6.2.0",
    	"is-electron": "^2.2.2",
    	"is-url": "^1.2.4",
    	"node-fetch": "^2.6.9",
    	"opencollective-postinstall": "^2.0.3",
    	"regenerator-runtime": "^0.13.3",
    	"tesseract.js-core": "^5.0.0",
    	"wasm-feature-detect": "^1.2.11",
    	zlibjs: "^0.3.1"
    };
    var overrides = {
    	"@rollup/pluginutils": "^5.0.2"
    };
    var repository = {
    	type: "git",
    	url: "https://github.com/naptha/tesseract.js.git"
    };
    var bugs = {
    	url: "https://github.com/naptha/tesseract.js/issues"
    };
    var homepage = "https://github.com/naptha/tesseract.js";
    var collective = {
    	type: "opencollective",
    	url: "https://opencollective.com/tesseractjs"
    };
    var require$$0 = {
    	name: name,
    	version: version$1,
    	description: description,
    	main: main,
    	types: types,
    	unpkg: unpkg,
    	jsdelivr: jsdelivr,
    	scripts: scripts,
    	browser: browser$1,
    	author: author,
    	contributors: contributors,
    	license: license,
    	devDependencies: devDependencies,
    	dependencies: dependencies,
    	overrides: overrides,
    	repository: repository,
    	bugs: bugs,
    	homepage: homepage,
    	collective: collective
    };

    var defaultOptions$3 = {
      /*
       * Use BlobURL for worker script by default
       * TODO: remove this option
       *
       */
      workerBlobURL: true,
      logger: () => {},
    };

    const version = require$$0.version;
    const defaultOptions$2 = defaultOptions$3;

    /*
     * Default options for browser worker
     */
    var defaultOptions_1 = {
      ...defaultOptions$2,
      workerPath: `https://cdn.jsdelivr.net/npm/tesseract.js@v${version}/dist/worker.min.js`,
    };

    /**
     * spawnWorker
     *
     * @name spawnWorker
     * @function create a new Worker in browser
     * @access public
     */

    var spawnWorker$2 = ({ workerPath, workerBlobURL }) => {
      let worker;
      if (Blob && URL && workerBlobURL) {
        const blob = new Blob([`importScripts("${workerPath}");`], {
          type: 'application/javascript',
        });
        worker = new Worker(URL.createObjectURL(blob));
      } else {
        worker = new Worker(workerPath);
      }

      return worker;
    };

    /**
     * terminateWorker
     *
     * @name terminateWorker
     * @function terminate worker
     * @access public
     */

    var terminateWorker$2 = (worker) => {
      worker.terminate();
    };

    var onMessage$2 = (worker, handler) => {
      worker.onmessage = ({ data }) => { // eslint-disable-line
        handler(data);
      };
    };

    /**
     * send
     *
     * @name send
     * @function send packet to worker and create a job
     * @access public
     */

    var send$2 = async (worker, packet) => {
      worker.postMessage(packet);
    };

    /**
     * readFromBlobOrFile
     *
     * @name readFromBlobOrFile
     * @function
     * @access private
     */

    const readFromBlobOrFile = (blob) => (
      new Promise((resolve, reject) => {
        const fileReader = new FileReader();
        fileReader.onload = () => {
          resolve(fileReader.result);
        };
        fileReader.onerror = ({ target: { error: { code } } }) => {
          reject(Error(`File could not be read! Code=${code}`));
        };
        fileReader.readAsArrayBuffer(blob);
      })
    );

    /**
     * loadImage
     *
     * @name loadImage
     * @function load image from different source
     * @access private
     */
    const loadImage$2 = async (image) => {
      let data = image;
      if (typeof image === 'undefined') {
        return 'undefined';
      }

      if (typeof image === 'string') {
        // Base64 Image
        if (/data:image\/([a-zA-Z]*);base64,([^"]*)/.test(image)) {
          data = atob(image.split(',')[1])
            .split('')
            .map((c) => c.charCodeAt(0));
        } else {
          const resp = await fetch(image);
          data = await resp.arrayBuffer();
        }
      } else if (typeof HTMLElement !== 'undefined' && image instanceof HTMLElement) {
        if (image.tagName === 'IMG') {
          data = await loadImage$2(image.src);
        }
        if (image.tagName === 'VIDEO') {
          data = await loadImage$2(image.poster);
        }
        if (image.tagName === 'CANVAS') {
          await new Promise((resolve) => {
            image.toBlob(async (blob) => {
              data = await readFromBlobOrFile(blob);
              resolve();
            });
          });
        }
      } else if (typeof OffscreenCanvas !== 'undefined' && image instanceof OffscreenCanvas) {
        const blob = await image.convertToBlob();
        data = await readFromBlobOrFile(blob);
      } else if (image instanceof File || image instanceof Blob) {
        data = await readFromBlobOrFile(image);
      }

      return new Uint8Array(data);
    };

    var loadImage_1 = loadImage$2;

    /**
     *
     * Tesseract Worker adapter for browser
     *
     * @fileoverview Tesseract Worker adapter for browser
     * @author Kevin Kwok <antimatter15@gmail.com>
     * @author Guillermo Webster <gui@mit.edu>
     * @author Jerome Wu <jeromewus@gmail.com>
     */

    const defaultOptions$1 = defaultOptions_1;
    const spawnWorker$1 = spawnWorker$2;
    const terminateWorker$1 = terminateWorker$2;
    const onMessage$1 = onMessage$2;
    const send$1 = send$2;
    const loadImage$1 = loadImage_1;

    var browser = {
      defaultOptions: defaultOptions$1,
      spawnWorker: spawnWorker$1,
      terminateWorker: terminateWorker$1,
      onMessage: onMessage$1,
      send: send$1,
      loadImage: loadImage$1,
    };

    const resolvePaths = resolvePaths$1;
    const circularize = circularize$1;
    const createJob = createJob$2;
    const { log } = log$2;
    const getId = getId$3;
    const OEM$1 = OEM$2;
    const {
      defaultOptions,
      spawnWorker,
      terminateWorker,
      onMessage,
      loadImage,
      send,
    } = browser;

    let workerCounter = 0;

    var createWorker$2 = async (langs = 'eng', oem = OEM$1.LSTM_ONLY, _options = {}, config = {}) => {
      const id = getId('Worker', workerCounter);
      const {
        logger,
        errorHandler,
        ...options
      } = resolvePaths({
        ...defaultOptions,
        ..._options,
      });
      const resolves = {};
      const rejects = {};

      // Current langs, oem, and config file.
      // Used if the user ever re-initializes the worker using `worker.reinitialize`.
      const currentLangs = typeof langs === 'string' ? langs.split('+') : langs;
      let currentOem = oem;
      let currentConfig = config;
      const lstmOnlyCore = [OEM$1.DEFAULT, OEM$1.LSTM_ONLY].includes(oem) && !options.legacyCore;

      let workerResReject;
      let workerResResolve;
      const workerRes = new Promise((resolve, reject) => {
        workerResResolve = resolve;
        workerResReject = reject;
      });
      const workerError = (event) => { workerResReject(event.message); };

      let worker = spawnWorker(options);
      worker.onerror = workerError;

      workerCounter += 1;

      const setResolve = (action, res) => {
        resolves[action] = res;
      };

      const setReject = (action, rej) => {
        rejects[action] = rej;
      };

      const startJob = ({ id: jobId, action, payload }) => (
        new Promise((resolve, reject) => {
          log(`[${id}]: Start ${jobId}, action=${action}`);
          setResolve(action, resolve);
          setReject(action, reject);
          send(worker, {
            workerId: id,
            jobId,
            action,
            payload,
          });
        })
      );

      const load = () => (
        console.warn('`load` is depreciated and should be removed from code (workers now come pre-loaded)')
      );

      const loadInternal = (jobId) => (
        startJob(createJob({
          id: jobId, action: 'load', payload: { options: { lstmOnly: lstmOnlyCore, corePath: options.corePath, logging: options.logging } },
        }))
      );

      const writeText = (path, text, jobId) => (
        startJob(createJob({
          id: jobId,
          action: 'FS',
          payload: { method: 'writeFile', args: [path, text] },
        }))
      );

      const readText = (path, jobId) => (
        startJob(createJob({
          id: jobId,
          action: 'FS',
          payload: { method: 'readFile', args: [path, { encoding: 'utf8' }] },
        }))
      );

      const removeFile = (path, jobId) => (
        startJob(createJob({
          id: jobId,
          action: 'FS',
          payload: { method: 'unlink', args: [path] },
        }))
      );

      const FS = (method, args, jobId) => (
        startJob(createJob({
          id: jobId,
          action: 'FS',
          payload: { method, args },
        }))
      );

      const loadLanguage = () => (
        console.warn('`loadLanguage` is depreciated and should be removed from code (workers now come with language pre-loaded)')
      );

      const loadLanguageInternal = (_langs, jobId) => startJob(createJob({
        id: jobId,
        action: 'loadLanguage',
        payload: {
          langs: _langs,
          options: {
            langPath: options.langPath,
            dataPath: options.dataPath,
            cachePath: options.cachePath,
            cacheMethod: options.cacheMethod,
            gzip: options.gzip,
            lstmOnly: [OEM$1.LSTM_ONLY, OEM$1.TESSERACT_LSTM_COMBINED].includes(currentOem)
              && !options.legacyLang,
          },
        },
      }));

      const initialize = () => (
        console.warn('`initialize` is depreciated and should be removed from code (workers now come pre-initialized)')
      );

      const initializeInternal = (_langs, _oem, _config, jobId) => (
        startJob(createJob({
          id: jobId,
          action: 'initialize',
          payload: { langs: _langs, oem: _oem, config: _config },
        }))
      );

      const reinitialize = (langs = 'eng', oem, config, jobId) => { // eslint-disable-line

        if (lstmOnlyCore && [OEM$1.TESSERACT_ONLY, OEM$1.TESSERACT_LSTM_COMBINED].includes(oem)) throw Error('Legacy model requested but code missing.');

        const _oem = oem || currentOem;
        currentOem = _oem;

        const _config = config || currentConfig;
        currentConfig = _config;

        // Only load langs that are not already loaded.
        // This logic fails if the user downloaded the LSTM-only English data for a language
        // and then uses `worker.reinitialize` to switch to the Legacy engine.
        // However, the correct data will still be downloaded after initialization fails
        // and this can be avoided entirely if the user loads the correct data ahead of time.
        const langsArr = typeof langs === 'string' ? langs.split('+') : langs;
        const _langs = langsArr.filter((x) => !currentLangs.includes(x));
        currentLangs.push(..._langs);

        if (_langs.length > 0) {
          return loadLanguageInternal(_langs, jobId)
            .then(() => initializeInternal(langs, _oem, _config, jobId));
        }

        return initializeInternal(langs, _oem, _config, jobId);
      };

      const setParameters = (params = {}, jobId) => (
        startJob(createJob({
          id: jobId,
          action: 'setParameters',
          payload: { params },
        }))
      );

      const recognize = async (image, opts = {}, output = {
        blocks: true, text: true, hocr: true, tsv: true,
      }, jobId) => (
        startJob(createJob({
          id: jobId,
          action: 'recognize',
          payload: { image: await loadImage(image), options: opts, output },
        }))
      );

      const getPDF = (title = 'Tesseract OCR Result', textonly = false, jobId) => {
        console.log('`getPDF` function is depreciated. `recognize` option `savePDF` should be used instead.');
        return startJob(createJob({
          id: jobId,
          action: 'getPDF',
          payload: { title, textonly },
        }));
      };

      const detect = async (image, jobId) => {
        if (lstmOnlyCore) throw Error('`worker.detect` requires Legacy model, which was not loaded.');

        return startJob(createJob({
          id: jobId,
          action: 'detect',
          payload: { image: await loadImage(image) },
        }));
      };

      const terminate = async () => {
        if (worker !== null) {
          /*
          await startJob(createJob({
            id: jobId,
            action: 'terminate',
          }));
          */
          terminateWorker(worker);
          worker = null;
        }
        return Promise.resolve();
      };

      onMessage(worker, ({
        workerId, jobId, status, action, data,
      }) => {
        if (status === 'resolve') {
          log(`[${workerId}]: Complete ${jobId}`);
          let d = data;
          if (action === 'recognize') {
            d = circularize(data);
          } else if (action === 'getPDF') {
            d = Array.from({ ...data, length: Object.keys(data).length });
          }
          resolves[action]({ jobId, data: d });
        } else if (status === 'reject') {
          rejects[action](data);
          if (action === 'load') workerResReject(data);
          if (errorHandler) {
            errorHandler(data);
          } else {
            throw Error(data);
          }
        } else if (status === 'progress') {
          logger({ ...data, userJobId: jobId });
        }
      });

      const resolveObj = {
        id,
        worker,
        setResolve,
        setReject,
        load,
        writeText,
        readText,
        removeFile,
        FS,
        loadLanguage,
        initialize,
        reinitialize,
        setParameters,
        recognize,
        getPDF,
        detect,
        terminate,
      };

      loadInternal()
        .then(() => loadLanguageInternal(langs))
        .then(() => initializeInternal(langs, oem, config))
        .then(() => workerResResolve(resolveObj))
        .catch(() => {});

      return workerRes;
    };

    const createWorker$1 = createWorker$2;

    const recognize = async (image, langs, options) => {
      const worker = await createWorker$1(langs, 1, options);
      return worker.recognize(image)
        .finally(async () => {
          await worker.terminate();
        });
    };

    const detect = async (image, options) => {
      const worker = await createWorker$1('osd', 0, options);
      return worker.detect(image)
        .finally(async () => {
          await worker.terminate();
        });
    };

    var Tesseract$1 = {
      recognize,
      detect,
    };

    /*
     * languages with existing tesseract traineddata
     * https://tesseract-ocr.github.io/tessdoc/Data-Files#data-files-for-version-400-november-29-2016
     */

    /**
     * @typedef {object} Languages
     * @property {string} AFR Afrikaans
     * @property {string} AMH Amharic
     * @property {string} ARA Arabic
     * @property {string} ASM Assamese
     * @property {string} AZE Azerbaijani
     * @property {string} AZE_CYRL Azerbaijani - Cyrillic
     * @property {string} BEL Belarusian
     * @property {string} BEN Bengali
     * @property {string} BOD Tibetan
     * @property {string} BOS Bosnian
     * @property {string} BUL Bulgarian
     * @property {string} CAT Catalan; Valencian
     * @property {string} CEB Cebuano
     * @property {string} CES Czech
     * @property {string} CHI_SIM Chinese - Simplified
     * @property {string} CHI_TRA Chinese - Traditional
     * @property {string} CHR Cherokee
     * @property {string} CYM Welsh
     * @property {string} DAN Danish
     * @property {string} DEU German
     * @property {string} DZO Dzongkha
     * @property {string} ELL Greek, Modern (1453-)
     * @property {string} ENG English
     * @property {string} ENM English, Middle (1100-1500)
     * @property {string} EPO Esperanto
     * @property {string} EST Estonian
     * @property {string} EUS Basque
     * @property {string} FAS Persian
     * @property {string} FIN Finnish
     * @property {string} FRA French
     * @property {string} FRK German Fraktur
     * @property {string} FRM French, Middle (ca. 1400-1600)
     * @property {string} GLE Irish
     * @property {string} GLG Galician
     * @property {string} GRC Greek, Ancient (-1453)
     * @property {string} GUJ Gujarati
     * @property {string} HAT Haitian; Haitian Creole
     * @property {string} HEB Hebrew
     * @property {string} HIN Hindi
     * @property {string} HRV Croatian
     * @property {string} HUN Hungarian
     * @property {string} IKU Inuktitut
     * @property {string} IND Indonesian
     * @property {string} ISL Icelandic
     * @property {string} ITA Italian
     * @property {string} ITA_OLD Italian - Old
     * @property {string} JAV Javanese
     * @property {string} JPN Japanese
     * @property {string} KAN Kannada
     * @property {string} KAT Georgian
     * @property {string} KAT_OLD Georgian - Old
     * @property {string} KAZ Kazakh
     * @property {string} KHM Central Khmer
     * @property {string} KIR Kirghiz; Kyrgyz
     * @property {string} KOR Korean
     * @property {string} KUR Kurdish
     * @property {string} LAO Lao
     * @property {string} LAT Latin
     * @property {string} LAV Latvian
     * @property {string} LIT Lithuanian
     * @property {string} MAL Malayalam
     * @property {string} MAR Marathi
     * @property {string} MKD Macedonian
     * @property {string} MLT Maltese
     * @property {string} MSA Malay
     * @property {string} MYA Burmese
     * @property {string} NEP Nepali
     * @property {string} NLD Dutch; Flemish
     * @property {string} NOR Norwegian
     * @property {string} ORI Oriya
     * @property {string} PAN Panjabi; Punjabi
     * @property {string} POL Polish
     * @property {string} POR Portuguese
     * @property {string} PUS Pushto; Pashto
     * @property {string} RON Romanian; Moldavian; Moldovan
     * @property {string} RUS Russian
     * @property {string} SAN Sanskrit
     * @property {string} SIN Sinhala; Sinhalese
     * @property {string} SLK Slovak
     * @property {string} SLV Slovenian
     * @property {string} SPA Spanish; Castilian
     * @property {string} SPA_OLD Spanish; Castilian - Old
     * @property {string} SQI Albanian
     * @property {string} SRP Serbian
     * @property {string} SRP_LATN Serbian - Latin
     * @property {string} SWA Swahili
     * @property {string} SWE Swedish
     * @property {string} SYR Syriac
     * @property {string} TAM Tamil
     * @property {string} TEL Telugu
     * @property {string} TGK Tajik
     * @property {string} TGL Tagalog
     * @property {string} THA Thai
     * @property {string} TIR Tigrinya
     * @property {string} TUR Turkish
     * @property {string} UIG Uighur; Uyghur
     * @property {string} UKR Ukrainian
     * @property {string} URD Urdu
     * @property {string} UZB Uzbek
     * @property {string} UZB_CYRL Uzbek - Cyrillic
     * @property {string} VIE Vietnamese
     * @property {string} YID Yiddish
     */

    /**
      * @type {Languages}
      */
    var languages$1 = {
      AFR: 'afr',
      AMH: 'amh',
      ARA: 'ara',
      ASM: 'asm',
      AZE: 'aze',
      AZE_CYRL: 'aze_cyrl',
      BEL: 'bel',
      BEN: 'ben',
      BOD: 'bod',
      BOS: 'bos',
      BUL: 'bul',
      CAT: 'cat',
      CEB: 'ceb',
      CES: 'ces',
      CHI_SIM: 'chi_sim',
      CHI_TRA: 'chi_tra',
      CHR: 'chr',
      CYM: 'cym',
      DAN: 'dan',
      DEU: 'deu',
      DZO: 'dzo',
      ELL: 'ell',
      ENG: 'eng',
      ENM: 'enm',
      EPO: 'epo',
      EST: 'est',
      EUS: 'eus',
      FAS: 'fas',
      FIN: 'fin',
      FRA: 'fra',
      FRK: 'frk',
      FRM: 'frm',
      GLE: 'gle',
      GLG: 'glg',
      GRC: 'grc',
      GUJ: 'guj',
      HAT: 'hat',
      HEB: 'heb',
      HIN: 'hin',
      HRV: 'hrv',
      HUN: 'hun',
      IKU: 'iku',
      IND: 'ind',
      ISL: 'isl',
      ITA: 'ita',
      ITA_OLD: 'ita_old',
      JAV: 'jav',
      JPN: 'jpn',
      KAN: 'kan',
      KAT: 'kat',
      KAT_OLD: 'kat_old',
      KAZ: 'kaz',
      KHM: 'khm',
      KIR: 'kir',
      KOR: 'kor',
      KUR: 'kur',
      LAO: 'lao',
      LAT: 'lat',
      LAV: 'lav',
      LIT: 'lit',
      MAL: 'mal',
      MAR: 'mar',
      MKD: 'mkd',
      MLT: 'mlt',
      MSA: 'msa',
      MYA: 'mya',
      NEP: 'nep',
      NLD: 'nld',
      NOR: 'nor',
      ORI: 'ori',
      PAN: 'pan',
      POL: 'pol',
      POR: 'por',
      PUS: 'pus',
      RON: 'ron',
      RUS: 'rus',
      SAN: 'san',
      SIN: 'sin',
      SLK: 'slk',
      SLV: 'slv',
      SPA: 'spa',
      SPA_OLD: 'spa_old',
      SQI: 'sqi',
      SRP: 'srp',
      SRP_LATN: 'srp_latn',
      SWA: 'swa',
      SWE: 'swe',
      SYR: 'syr',
      TAM: 'tam',
      TEL: 'tel',
      TGK: 'tgk',
      TGL: 'tgl',
      THA: 'tha',
      TIR: 'tir',
      TUR: 'tur',
      UIG: 'uig',
      UKR: 'ukr',
      URD: 'urd',
      UZB: 'uzb',
      UZB_CYRL: 'uzb_cyrl',
      VIE: 'vie',
      YID: 'yid',
    };

    /*
     * PSM = Page Segmentation Mode
     */

    var PSM$1 = {
      OSD_ONLY: '0',
      AUTO_OSD: '1',
      AUTO_ONLY: '2',
      AUTO: '3',
      SINGLE_COLUMN: '4',
      SINGLE_BLOCK_VERT_TEXT: '5',
      SINGLE_BLOCK: '6',
      SINGLE_LINE: '7',
      SINGLE_WORD: '8',
      CIRCLE_WORD: '9',
      SINGLE_CHAR: '10',
      SPARSE_TEXT: '11',
      SPARSE_TEXT_OSD: '12',
      RAW_LINE: '13',
    };

    /**
     *
     * Entry point for tesseract.js, should be the entry when bundling.
     *
     * @fileoverview entry point for tesseract.js
     * @author Kevin Kwok <antimatter15@gmail.com>
     * @author Guillermo Webster <gui@mit.edu>
     * @author Jerome Wu <jeromewus@gmail.com>
     */

    const createScheduler = createScheduler$1;
    const createWorker = createWorker$2;
    const Tesseract = Tesseract$1;
    const languages = languages$1;
    const OEM = OEM$2;
    const PSM = PSM$1;
    const { setLogging } = log$2;

    var src = {
      languages,
      OEM,
      PSM,
      createScheduler,
      createWorker,
      setLogging,
      ...Tesseract,
    };

    /* srcReading\PDFviewer\Convert.svelte generated by Svelte v3.59.2 */

    const { console: console_1$u } = globals;

    const file$1i = "srcReading\\PDFviewer\\Convert.svelte";

    function create_fragment$1m(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let button2;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "VN-convert";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "ENG-convert";
    			t3 = space();
    			button2 = element("button");
    			button2.textContent = "exit";
    			attr_dev(button0, "class", "svelte-1wmiq0a");
    			add_location(button0, file$1i, 2, 0, 66);
    			attr_dev(button1, "class", "svelte-1wmiq0a");
    			add_location(button1, file$1i, 3, 0, 110);
    			attr_dev(button2, "class", "svelte-1wmiq0a");
    			add_location(button2, file$1i, 4, 0, 157);
    			attr_dev(div, "id", "container2choice");
    			attr_dev(div, "class", "svelte-1wmiq0a");
    			add_location(div, file$1i, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, button1);
    			append_dev(div, t3);
    			append_dev(div, button2);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*Vn*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*Tess*/ ctx[1], false, false, false, false),
    					listen_dev(button2, "click", /*Des*/ ctx[0], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1m($$self, $$props, $$invalidate) {
    	let $convertedTextTess;
    	let $nowlinkTess;
    	let $captureTF;
    	let $isConvertingTess;
    	let $captureLink;
    	validate_store(convertedTextTess, 'convertedTextTess');
    	component_subscribe($$self, convertedTextTess, $$value => $$invalidate(5, $convertedTextTess = $$value));
    	validate_store(nowlinkTess, 'nowlinkTess');
    	component_subscribe($$self, nowlinkTess, $$value => $$invalidate(6, $nowlinkTess = $$value));
    	validate_store(captureTF, 'captureTF');
    	component_subscribe($$self, captureTF, $$value => $$invalidate(7, $captureTF = $$value));
    	validate_store(isConvertingTess, 'isConvertingTess');
    	component_subscribe($$self, isConvertingTess, $$value => $$invalidate(8, $isConvertingTess = $$value));
    	validate_store(captureLink, 'captureLink');
    	component_subscribe($$self, captureLink, $$value => $$invalidate(9, $captureLink = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Convert', slots, []);
    	let { top } = $$props;
    	let { right } = $$props;

    	function Des() {
    		set_store_value(captureTF, $captureTF = false, $captureTF);
    		set_store_value(captureLink, $captureLink = '', $captureLink);
    	}

    	onMount(() => {
    		let contain = document.getElementById("container2choice");
    		contain.style.top = top.toString() + 'px';
    		contain.style.right = right.toString() + 'px';
    	});

    	async function Tess() {
    		set_store_value(isConvertingTess, $isConvertingTess = true, $isConvertingTess);
    		set_store_value(captureTF, $captureTF = false, $captureTF);
    		console.log("tesseringcting");
    		const worker = await src.createWorker('eng');
    		const ret = await worker.recognize($nowlinkTess);
    		set_store_value(convertedTextTess, $convertedTextTess = ret.data.text, $convertedTextTess);
    		await worker.terminate();
    	}

    	async function Vn() {
    		set_store_value(isConvertingTess, $isConvertingTess = true, $isConvertingTess);
    		set_store_value(captureTF, $captureTF = false, $captureTF);
    		console.log("tesseringcting");
    		const worker = await src.createWorker('vie');
    		const ret = await worker.recognize($nowlinkTess);
    		set_store_value(convertedTextTess, $convertedTextTess = ret.data.text, $convertedTextTess);
    		await worker.terminate();
    	}

    	$$self.$$.on_mount.push(function () {
    		if (top === undefined && !('top' in $$props || $$self.$$.bound[$$self.$$.props['top']])) {
    			console_1$u.warn("<Convert> was created without expected prop 'top'");
    		}

    		if (right === undefined && !('right' in $$props || $$self.$$.bound[$$self.$$.props['right']])) {
    			console_1$u.warn("<Convert> was created without expected prop 'right'");
    		}
    	});

    	const writable_props = ['top', 'right'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$u.warn(`<Convert> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('top' in $$props) $$invalidate(3, top = $$props.top);
    		if ('right' in $$props) $$invalidate(4, right = $$props.right);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		slide,
    		top,
    		right,
    		Des,
    		createWorker: src.createWorker,
    		convertedTextTess,
    		isConvertingTess,
    		nowlinkTess,
    		captureTF,
    		captureLink,
    		Tess,
    		Vn,
    		$convertedTextTess,
    		$nowlinkTess,
    		$captureTF,
    		$isConvertingTess,
    		$captureLink
    	});

    	$$self.$inject_state = $$props => {
    		if ('top' in $$props) $$invalidate(3, top = $$props.top);
    		if ('right' in $$props) $$invalidate(4, right = $$props.right);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [Des, Tess, Vn, top, right];
    }

    class Convert extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1m, create_fragment$1m, safe_not_equal, { top: 3, right: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Convert",
    			options,
    			id: create_fragment$1m.name
    		});
    	}

    	get top() {
    		throw new Error("<Convert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set top(value) {
    		throw new Error("<Convert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get right() {
    		throw new Error("<Convert>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set right(value) {
    		throw new Error("<Convert>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReading\PDFviewer\UpopCap.svelte generated by Svelte v3.59.2 */

    const { console: console_1$t } = globals;
    const file$1h = "srcReading\\PDFviewer\\UpopCap.svelte";

    // (94:0) {#if finish}
    function create_if_block$r(ctx) {
    	let convert;
    	let current;

    	convert = new Convert({
    			props: {
    				top: /*topvalue*/ ctx[0],
    				right: /*rightvalue*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(convert.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(convert, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const convert_changes = {};
    			if (dirty & /*topvalue*/ 1) convert_changes.top = /*topvalue*/ ctx[0];
    			if (dirty & /*rightvalue*/ 2) convert_changes.right = /*rightvalue*/ ctx[1];
    			convert.$set(convert_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(convert.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(convert.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(convert, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(94:0) {#if finish}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1l(ctx) {
    	let div0;
    	let t0;
    	let div1;
    	let img0;
    	let img0_src_value;
    	let t1;
    	let img1;
    	let t2;
    	let div2;
    	let t3;
    	let if_block_anchor;
    	let current;
    	let if_block = /*finish*/ ctx[2] && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			img0 = element("img");
    			t1 = space();
    			img1 = element("img");
    			t2 = space();
    			div2 = element("div");
    			t3 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(div0, "id", "layoutback");
    			attr_dev(div0, "class", "svelte-1n26qk");
    			add_location(div0, file$1h, 86, 0, 2262);
    			if (!src_url_equal(img0.src, img0_src_value = /*$captureLink*/ ctx[3])) attr_dev(img0, "src", img0_src_value);
    			attr_dev(img0, "alt", "capture");
    			attr_dev(img0, "id", "capturedimage");
    			attr_dev(img0, "class", "svelte-1n26qk");
    			add_location(img0, file$1h, 88, 4, 2322);
    			attr_dev(div1, "id", "prevDisplay");
    			attr_dev(div1, "class", "svelte-1n26qk");
    			add_location(div1, file$1h, 87, 0, 2292);
    			attr_dev(img1, "id", "image");
    			attr_dev(img1, "alt", "hi");
    			attr_dev(img1, "class", "svelte-1n26qk");
    			add_location(img1, file$1h, 91, 0, 2398);
    			attr_dev(div2, "id", "containCap");
    			attr_dev(div2, "class", "svelte-1n26qk");
    			add_location(div2, file$1h, 92, 0, 2429);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, img0);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, img1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div2, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$captureLink*/ 8 && !src_url_equal(img0.src, img0_src_value = /*$captureLink*/ ctx[3])) {
    				attr_dev(img0, "src", img0_src_value);
    			}

    			if (/*finish*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*finish*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$r(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(img1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div2);
    			if (detaching) detach_dev(t3);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1l($$self, $$props, $$invalidate) {
    	let $nowlinkTess;
    	let $captureLink;
    	validate_store(nowlinkTess, 'nowlinkTess');
    	component_subscribe($$self, nowlinkTess, $$value => $$invalidate(7, $nowlinkTess = $$value));
    	validate_store(captureLink, 'captureLink');
    	component_subscribe($$self, captureLink, $$value => $$invalidate(3, $captureLink = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UpopCap', slots, []);
    	let topvalue, rightvalue;
    	let finish = false;
    	let prevX, prevY;
    	let linker = false;

    	onMount(() => {
    		let image = document.getElementById('capturedimage');
    		let contai = document.getElementById('containCap');
    		let isSelecting = false;
    		let background = document.getElementById('layoutback');

    		image.ondragstart = event => {
    			event.preventDefault();
    		};

    		background.addEventListener('mousedown', event => {
    			$$invalidate(2, finish = false);
    			contai.style.width = 0;
    			contai.style.height = 0;
    			isSelecting = true;
    			contai.style.display = 'block';
    			prevY = event.clientY;
    			contai.style.top = prevY + 'px';
    			prevX = event.clientX;
    			contai.style.left = prevX + 'px';
    			console.log(prevX, prevY);
    		});

    		background.addEventListener('mousemove', event => {
    			if (isSelecting) {
    				contai.style.width = event.clientX - prevX + 'px';
    				contai.style.height = event.clientY - prevY + 'px';
    				console.log("move");
    			}
    		});

    		background.addEventListener('mouseup', event => {
    			if (isSelecting) {
    				background.style.zIndex = '-1';
    				$$invalidate(0, topvalue = event.clientY);
    				$$invalidate(1, rightvalue = window.innerWidth - event.clientX);
    				$$invalidate(2, finish = true);
    				Crop(topvalue, event.clientX);
    			}

    			isSelecting = false;
    		});
    	});

    	function Crop(sH, sW) {
    		const canvas = document.createElement('canvas');
    		const ctx = canvas.getContext('2d');
    		const img = document.getElementById('capturedimage');
    		const height = sH - prevY;
    		const width = sW - prevX;
    		console.log(height, "----", width);
    		canvas.width = width;
    		canvas.height = height;
    		ctx.drawImage(img, prevX, prevY, width, height, 0, 0, width, height);
    		let image = document.getElementById('image');
    		image.style.position = 'absolute';
    		image.style.width = width.toString();
    		image.style.height = height.toString();

    		canvas.toBlob(
    			blob => {
    				linker = URL.createObjectURL(blob);
    				console.log(linker);
    				image.src = linker;
    				console.log(linker);
    				set_store_value(nowlinkTess, $nowlinkTess = linker, $nowlinkTess);
    			},
    			'image/jpg'
    		);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$t.warn(`<UpopCap> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		captureLink,
    		captureTF,
    		nowlinkTess,
    		onMount,
    		Convert,
    		topvalue,
    		rightvalue,
    		finish,
    		prevX,
    		prevY,
    		linker,
    		Crop,
    		$nowlinkTess,
    		$captureLink
    	});

    	$$self.$inject_state = $$props => {
    		if ('topvalue' in $$props) $$invalidate(0, topvalue = $$props.topvalue);
    		if ('rightvalue' in $$props) $$invalidate(1, rightvalue = $$props.rightvalue);
    		if ('finish' in $$props) $$invalidate(2, finish = $$props.finish);
    		if ('prevX' in $$props) prevX = $$props.prevX;
    		if ('prevY' in $$props) prevY = $$props.prevY;
    		if ('linker' in $$props) linker = $$props.linker;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [topvalue, rightvalue, finish, $captureLink];
    }

    class UpopCap extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1l, create_fragment$1l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UpopCap",
    			options,
    			id: create_fragment$1l.name
    		});
    	}
    }

    /* srcReading\UploadImage\Drag.svelte generated by Svelte v3.59.2 */
    const file$1g = "srcReading\\UploadImage\\Drag.svelte";

    function create_fragment$1k(ctx) {
    	let button;
    	let t;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text("drag images or click here");
    			input = element("input");
    			attr_dev(input, "type", "file");
    			input.multiple = true;
    			attr_dev(input, "id", "fileInput");
    			attr_dev(input, "class", "svelte-lm26d");
    			add_location(input, file$1g, 69, 29, 1652);
    			attr_dev(button, "id", "containDragUp");
    			attr_dev(button, "class", "svelte-lm26d");
    			add_location(button, file$1g, 68, 2, 1508);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);
    			append_dev(button, input);

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "change", /*change_handler*/ ctx[4], false, false, false, false),
    					listen_dev(button, "dragover", /*DragOver*/ ctx[0], false, false, false, false),
    					listen_dev(button, "dragleave", /*DragLeave*/ ctx[1], false, false, false, false),
    					listen_dev(button, "drop", /*DragDrop*/ ctx[2], false, false, false, false),
    					listen_dev(button, "click", Trigger, false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Trigger() {
    	document.getElementById('fileInput').click();
    }

    function instance$1k($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Drag', slots, []);
    	let dropZone;

    	onMount(() => {
    		dropZone = document.getElementById('containDragUp');
    	});

    	function DragOver(e) {
    		e.preventDefault();
    		dropZone.style.backgroundColor = '#000000';
    	}

    	function DragLeave() {
    		// Change back to original color
    		dropZone.style.backgroundColor = '#535353';
    	}

    	function DragDrop(e) {
    		dropZone.style.backgroundColor = '#535353';
    		e.preventDefault();
    		handleFiles(e.dataTransfer.files);
    	}

    	function handleFiles(files) {
    		for (var i = 0; i < files.length; i++) {
    			if (files[i].type.match('image.*')) {
    				imageList.update(value => {
    					let prev = [...value];
    					prev.push(URL.createObjectURL(files[i]));
    					return prev;
    				});
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Drag> was created with unknown prop '${key}'`);
    	});

    	const change_handler = () => {
    		handleFiles(event.target.files);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		imageList,
    		dropZone,
    		DragOver,
    		DragLeave,
    		DragDrop,
    		handleFiles,
    		Trigger
    	});

    	$$self.$inject_state = $$props => {
    		if ('dropZone' in $$props) dropZone = $$props.dropZone;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [DragOver, DragLeave, DragDrop, handleFiles, change_handler];
    }

    class Drag extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1k, create_fragment$1k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Drag",
    			options,
    			id: create_fragment$1k.name
    		});
    	}
    }

    /* srcReading\UploadImage\Preview.svelte generated by Svelte v3.59.2 */
    const file$1f = "srcReading\\UploadImage\\Preview.svelte";

    function get_each_context$o(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	child_ctx[5] = i;
    	return child_ctx;
    }

    // (14:4) {#each $imageList as image, x}
    function create_each_block$o(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let t0;
    	let button;
    	let t2;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[2](/*x*/ ctx[5]);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t0 = space();
    			button = element("button");
    			button.textContent = "remove";
    			t2 = space();
    			if (!src_url_equal(img.src, img_src_value = /*image*/ ctx[3])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "aimg");
    			attr_dev(img, "class", "svelte-1j84ubx");
    			add_location(img, file$1f, 15, 12, 328);
    			attr_dev(button, "class", "deleteImg svelte-1j84ubx");
    			add_location(button, file$1f, 16, 12, 373);
    			attr_dev(div, "class", "containMage svelte-1j84ubx");
    			add_location(div, file$1f, 14, 8, 287);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t0);
    			append_dev(div, button);
    			append_dev(div, t2);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;

    			if (dirty & /*$imageList*/ 1 && !src_url_equal(img.src, img_src_value = /*image*/ ctx[3])) {
    				attr_dev(img, "src", img_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$o.name,
    		type: "each",
    		source: "(14:4) {#each $imageList as image, x}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1j(ctx) {
    	let div;
    	let each_value = /*$imageList*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$o(get_each_context$o(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "id", "containPrev");
    			attr_dev(div, "class", "svelte-1j84ubx");
    			add_location(div, file$1f, 12, 0, 217);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Delete, $imageList*/ 3) {
    				each_value = /*$imageList*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$o(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$o(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1j($$self, $$props, $$invalidate) {
    	let $imageList;
    	validate_store(imageList, 'imageList');
    	component_subscribe($$self, imageList, $$value => $$invalidate(0, $imageList = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Preview', slots, []);

    	function Delete(num) {
    		imageList.update(value => {
    			let prev = [...value];
    			prev.splice(num, 1);
    			return prev;
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Preview> was created with unknown prop '${key}'`);
    	});

    	const click_handler = x => {
    		Delete(x);
    	};

    	$$self.$capture_state = () => ({ imageList, Delete, $imageList });
    	return [$imageList, Delete, click_handler];
    }

    class Preview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1j, create_fragment$1j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Preview",
    			options,
    			id: create_fragment$1j.name
    		});
    	}
    }

    /* srcReading\UploadImage\UpBoard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$s } = globals;
    const file$1e = "srcReading\\UploadImage\\UpBoard.svelte";

    function create_fragment$1i(ctx) {
    	let div2;
    	let div0;
    	let drag;
    	let div0_transition;
    	let t0;
    	let div1;
    	let preview;
    	let div1_transition;
    	let t1;
    	let button0;
    	let t3;
    	let button1;
    	let div2_transition;
    	let t5;
    	let div3;
    	let current;
    	let mounted;
    	let dispose;
    	drag = new Drag({ $$inline: true });
    	preview = new Preview({ $$inline: true });

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			create_component(drag.$$.fragment);
    			t0 = space();
    			div1 = element("div");
    			create_component(preview.$$.fragment);
    			t1 = space();
    			button0 = element("button");
    			button0.textContent = "out";
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "done";
    			t5 = space();
    			div3 = element("div");
    			attr_dev(div0, "id", "containUpMain");
    			attr_dev(div0, "class", "svelte-1q31ykx");
    			add_location(div0, file$1e, 21, 4, 587);
    			attr_dev(div1, "id", "containGalary");
    			attr_dev(div1, "class", "svelte-1q31ykx");
    			add_location(div1, file$1e, 24, 4, 681);
    			attr_dev(button0, "id", "exit");
    			attr_dev(button0, "class", "svelte-1q31ykx");
    			add_location(button0, file$1e, 27, 4, 778);
    			attr_dev(button1, "id", "okeImgage");
    			attr_dev(button1, "class", "svelte-1q31ykx");
    			add_location(button1, file$1e, 28, 4, 850);
    			attr_dev(div2, "id", "containUpload");
    			attr_dev(div2, "class", "svelte-1q31ykx");
    			add_location(div2, file$1e, 19, 0, 515);
    			attr_dev(div3, "id", "blackground");
    			attr_dev(div3, "class", "svelte-1q31ykx");
    			add_location(div3, file$1e, 31, 0, 924);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			mount_component(drag, div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			mount_component(preview, div1, null);
    			append_dev(div2, t1);
    			append_dev(div2, button0);
    			append_dev(div2, t3);
    			append_dev(div2, button1);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, div3, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*OkImage*/ ctx[1], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(drag.$$.fragment, local);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div0_transition) div0_transition = create_bidirectional_transition(div0, blur, { duration: 500 }, true);
    				div0_transition.run(1);
    			});

    			transition_in(preview.$$.fragment, local);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, blur, { duration: 500 }, true);
    				div1_transition.run(1);
    			});

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 500 }, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(drag.$$.fragment, local);
    			if (!div0_transition) div0_transition = create_bidirectional_transition(div0, blur, { duration: 500 }, false);
    			div0_transition.run(0);
    			transition_out(preview.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, blur, { duration: 500 }, false);
    			div1_transition.run(0);
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 500 }, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(drag);
    			if (detaching && div0_transition) div0_transition.end();
    			destroy_component(preview);
    			if (detaching && div1_transition) div1_transition.end();
    			if (detaching && div2_transition) div2_transition.end();
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(div3);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1i($$self, $$props, $$invalidate) {
    	let $imageTF;
    	let $imageList;
    	let $onTabImage;
    	validate_store(imageTF, 'imageTF');
    	component_subscribe($$self, imageTF, $$value => $$invalidate(0, $imageTF = $$value));
    	validate_store(imageList, 'imageList');
    	component_subscribe($$self, imageList, $$value => $$invalidate(3, $imageList = $$value));
    	validate_store(onTabImage, 'onTabImage');
    	component_subscribe($$self, onTabImage, $$value => $$invalidate(4, $onTabImage = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('UpBoard', slots, []);

    	function OkImage() {
    		imageListTab.update(value => {
    			let prev = [...value];
    			console.log(prev, $onTabImage, "ads");
    			prev[$onTabImage - 1] = prev[$onTabImage - 1].concat($imageList);
    			return prev;
    		});

    		set_store_value(imageTF, $imageTF = false, $imageTF);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$s.warn(`<UpBoard> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		set_store_value(imageTF, $imageTF = false, $imageTF);
    	};

    	$$self.$capture_state = () => ({
    		DisplayImageList,
    		imageList,
    		imageListTab,
    		imageTF,
    		onTabImage,
    		Drag,
    		Preview,
    		slide,
    		blur,
    		OkImage,
    		$imageTF,
    		$imageList,
    		$onTabImage
    	});

    	return [$imageTF, OkImage, click_handler];
    }

    class UpBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1i, create_fragment$1i, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "UpBoard",
    			options,
    			id: create_fragment$1i.name
    		});
    	}
    }

    /* srcReading\QuickTask\QuickTask.svelte generated by Svelte v3.59.2 */
    const file$1d = "srcReading\\QuickTask\\QuickTask.svelte";

    function create_fragment$1h(ctx) {
    	let div1;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let div0;
    	let button2;
    	let t4;
    	let button3;
    	let t5;
    	let button4;
    	let t6;
    	let button5;
    	let t7;
    	let button6;
    	let t8;
    	let button7;
    	let div1_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "Find";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "Own-Saving";
    			t3 = space();
    			div0 = element("div");
    			button2 = element("button");
    			t4 = space();
    			button3 = element("button");
    			t5 = space();
    			button4 = element("button");
    			t6 = space();
    			button5 = element("button");
    			t7 = space();
    			button6 = element("button");
    			t8 = space();
    			button7 = element("button");
    			attr_dev(button0, "id", "translate");
    			attr_dev(button0, "class", "buttask svelte-1pvoy87");
    			add_location(button0, file$1d, 48, 4, 1502);
    			attr_dev(button1, "id", "saveown");
    			attr_dev(button1, "class", "buttask svelte-1pvoy87");
    			add_location(button1, file$1d, 49, 4, 1579);
    			attr_dev(button2, "class", "quickHighlight svelte-1pvoy87");
    			attr_dev(button2, "id", "color1");
    			add_location(button2, file$1d, 51, 8, 1711);
    			attr_dev(button3, "class", "quickHighlight svelte-1pvoy87");
    			attr_dev(button3, "id", "color2");
    			add_location(button3, file$1d, 52, 8, 1817);
    			attr_dev(button4, "class", "quickHighlight svelte-1pvoy87");
    			attr_dev(button4, "id", "color3");
    			add_location(button4, file$1d, 53, 8, 1923);
    			attr_dev(button5, "class", "quickHighlight svelte-1pvoy87");
    			attr_dev(button5, "id", "color4");
    			add_location(button5, file$1d, 54, 8, 2029);
    			attr_dev(button6, "class", "quickHighlight svelte-1pvoy87");
    			attr_dev(button6, "id", "color5");
    			add_location(button6, file$1d, 55, 8, 2135);
    			attr_dev(button7, "class", "quickHighlight svelte-1pvoy87");
    			attr_dev(button7, "id", "Nocolor");
    			add_location(button7, file$1d, 56, 8, 2241);
    			attr_dev(div0, "id", "containQuickHighlight");
    			attr_dev(div0, "class", "svelte-1pvoy87");
    			add_location(div0, file$1d, 50, 4, 1668);
    			attr_dev(div1, "id", "containQuickTask");
    			attr_dev(div1, "class", "svelte-1pvoy87");
    			add_location(div1, file$1d, 47, 0, 1433);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, button0);
    			append_dev(div1, t1);
    			append_dev(div1, button1);
    			append_dev(div1, t3);
    			append_dev(div1, div0);
    			append_dev(div0, button2);
    			append_dev(div0, t4);
    			append_dev(div0, button3);
    			append_dev(div0, t5);
    			append_dev(div0, button4);
    			append_dev(div0, t6);
    			append_dev(div0, button5);
    			append_dev(div0, t7);
    			append_dev(div0, button6);
    			append_dev(div0, t8);
    			append_dev(div0, button7);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*RUN*/ ctx[0], false, false, false, false),
    					listen_dev(button1, "click", /*savingown*/ ctx[1], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_1*/ ctx[3], false, false, false, false),
    					listen_dev(button4, "click", /*click_handler_2*/ ctx[4], false, false, false, false),
    					listen_dev(button5, "click", /*click_handler_3*/ ctx[5], false, false, false, false),
    					listen_dev(button6, "click", /*click_handler_4*/ ctx[6], false, false, false, false),
    					listen_dev(button7, "click", /*click_handler_5*/ ctx[7], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 300 }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 300 }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function HightLight(color) {
    	document.execCommand('backColor', false, color);
    }

    function instance$1h($$self, $$props, $$invalidate) {
    	let $selectedTextForQuickTask;
    	let $selectedText;
    	let $choseText;
    	let $coordinateMouse;
    	validate_store(selectedTextForQuickTask, 'selectedTextForQuickTask');
    	component_subscribe($$self, selectedTextForQuickTask, $$value => $$invalidate(8, $selectedTextForQuickTask = $$value));
    	validate_store(selectedText, 'selectedText');
    	component_subscribe($$self, selectedText, $$value => $$invalidate(9, $selectedText = $$value));
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(10, $choseText = $$value));
    	validate_store(coordinateMouse, 'coordinateMouse');
    	component_subscribe($$self, coordinateMouse, $$value => $$invalidate(11, $coordinateMouse = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('QuickTask', slots, []);

    	onMount(() => {
    		let container = document.getElementById('containQuickTask');

    		if ($coordinateMouse[0] + container.offsetWidth < window.innerWidth) {
    			container.style.left = $coordinateMouse[0] + 'px';
    		} else {
    			container.style.left = $coordinateMouse[0] - container.offsetWidth + 'px';
    		}

    		if ($coordinateMouse[1] + container.offsetHeight < window.innerHeight) {
    			container.style.top = $coordinateMouse[1] + 'px';
    		} else {
    			container.style.top = $coordinateMouse[1] - container.offsetHeight + 'px';
    		}
    	});

    	function RUN() {
    		set_store_value(selectedTextForQuickTask, $selectedTextForQuickTask = false, $selectedTextForQuickTask);
    		var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + $choseText;

    		fetch(link).then(res => {
    			if (res.ok) {
    				set_store_value(selectedText, $selectedText = 'available', $selectedText);
    			} else {
    				set_store_value(selectedText, $selectedText = 'notfound', $selectedText);
    			}
    		});
    	}

    	function savingown() {
    		set_store_value(selectedText, $selectedText = 'owning', $selectedText);
    		set_store_value(selectedTextForQuickTask, $selectedTextForQuickTask = false, $selectedTextForQuickTask);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<QuickTask> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		HightLight('#ff6565');
    	};

    	const click_handler_1 = () => {
    		HightLight('#91e0ee');
    	};

    	const click_handler_2 = () => {
    		HightLight('#ffe16c');
    	};

    	const click_handler_3 = () => {
    		HightLight('#179487');
    	};

    	const click_handler_4 = () => {
    		HightLight('#fe5d8c');
    	};

    	const click_handler_5 = () => {
    		HightLight('#00000000');
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		choseText,
    		coordinateMouse,
    		selectedText,
    		selectedTextForQuickTask,
    		slide,
    		RUN,
    		savingown,
    		HightLight,
    		$selectedTextForQuickTask,
    		$selectedText,
    		$choseText,
    		$coordinateMouse
    	});

    	return [
    		RUN,
    		savingown,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5
    	];
    }

    class QuickTask extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1h, create_fragment$1h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "QuickTask",
    			options,
    			id: create_fragment$1h.name
    		});
    	}
    }

    /* srcReading\Tab\NameTab.svelte generated by Svelte v3.59.2 */
    const file$1c = "srcReading\\Tab\\NameTab.svelte";

    function create_fragment$1g(ctx) {
    	let button;
    	let t_value = /*$tab*/ ctx[1][/*$onTab*/ ctx[2] - 1] + "";
    	let t;
    	let button_intro;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "id", "contaiNameDiv");
    			attr_dev(button, "class", "svelte-ehzmtp");
    			add_location(button, file$1c, 6, 0, 123);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$tab, $onTab*/ 6 && t_value !== (t_value = /*$tab*/ ctx[1][/*$onTab*/ ctx[2] - 1] + "")) set_data_dev(t, t_value);
    		},
    		i: function intro(local) {
    			if (!button_intro) {
    				add_render_callback(() => {
    					button_intro = create_in_transition(button, scale, { duration: 500 });
    					button_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1g($$self, $$props, $$invalidate) {
    	let $nameTF;
    	let $tab;
    	let $onTab;
    	validate_store(nameTF, 'nameTF');
    	component_subscribe($$self, nameTF, $$value => $$invalidate(0, $nameTF = $$value));
    	validate_store(tab, 'tab');
    	component_subscribe($$self, tab, $$value => $$invalidate(1, $tab = $$value));
    	validate_store(onTab, 'onTab');
    	component_subscribe($$self, onTab, $$value => $$invalidate(2, $onTab = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NameTab', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NameTab> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		set_store_value(nameTF, $nameTF = false, $nameTF);
    	};

    	$$self.$capture_state = () => ({
    		nameTF,
    		onTab,
    		tab,
    		scale,
    		$nameTF,
    		$tab,
    		$onTab
    	});

    	return [$nameTF, $tab, $onTab, click_handler];
    }

    class NameTab extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1g, create_fragment$1g, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NameTab",
    			options,
    			id: create_fragment$1g.name
    		});
    	}
    }

    /* srcReading\Tab\New.svelte generated by Svelte v3.59.2 */

    const { console: console_1$r } = globals;

    const file$1b = "srcReading\\Tab\\New.svelte";

    function create_fragment$1f(ctx) {
    	let button0;
    	let t1;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			button0.textContent = "exit";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "add";
    			attr_dev(button0, "id", "exit");
    			attr_dev(button0, "class", "inout svelte-9c0x2q");
    			add_location(button0, file$1b, 41, 0, 905);
    			attr_dev(button1, "id", "create");
    			attr_dev(button1, "class", "inout svelte-9c0x2q");
    			add_location(button1, file$1b, 42, 0, 988);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button1, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[2], false, false, false, false),
    					listen_dev(button1, "click", /*increasePage*/ ctx[1], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1f($$self, $$props, $$invalidate) {
    	let $taskbar;
    	let $onTab;
    	let $nameTF;
    	validate_store(taskbar, 'taskbar');
    	component_subscribe($$self, taskbar, $$value => $$invalidate(3, $taskbar = $$value));
    	validate_store(onTab, 'onTab');
    	component_subscribe($$self, onTab, $$value => $$invalidate(4, $onTab = $$value));
    	validate_store(nameTF, 'nameTF');
    	component_subscribe($$self, nameTF, $$value => $$invalidate(0, $nameTF = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('New', slots, []);

    	function increasePage() {
    		imageList.update(value => {
    			return [];
    		});

    		step.update(value => {
    			const newstep = [...value];
    			newstep.push("");
    			return newstep;
    		});

    		tab.update(currentTab => {
    			const newTab = [...currentTab];
    			const s = "draft_" + (newTab.length + 1);
    			set_store_value(onTab, $onTab = newTab.length + 1, $onTab);
    			console.log($onTab);
    			newTab.push(s);
    			return newTab;
    		});

    		typesFile.update(value => {
    			const newFile = [...value];
    			newFile.push("no");
    			set_store_value(taskbar, $taskbar = "no", $taskbar);
    			return newFile;
    		});

    		isOning.update(value => {
    			let prev = [...value];
    			prev.push(true);
    			return prev;
    		});

    		preventReloadFile.update(value => {
    			const up = [...value];
    			up.push(false);
    			return up;
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$r.warn(`<New> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		set_store_value(nameTF, $nameTF = true, $nameTF);
    	};

    	$$self.$capture_state = () => ({
    		tab,
    		onTab,
    		step,
    		typesFile,
    		preventReloadFile,
    		taskbar,
    		isOning,
    		imageList,
    		nameTF,
    		increasePage,
    		$taskbar,
    		$onTab,
    		$nameTF
    	});

    	return [$nameTF, increasePage, click_handler];
    }

    class New extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1f, create_fragment$1f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "New",
    			options,
    			id: create_fragment$1f.name
    		});
    	}
    }

    /* srcReading\TaskBar\ContainPage.svelte generated by Svelte v3.59.2 */
    const file$1a = "srcReading\\TaskBar\\ContainPage.svelte";

    function get_each_context$n(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    // (18:4) {#if $isOning[i]}
    function create_if_block$q(ctx) {
    	let tab_1;
    	let current;

    	tab_1 = new Tab({
    			props: {
    				numtab: /*item*/ ctx[4],
    				pagenum: /*i*/ ctx[6] + 1
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(tab_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(tab_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tab_1_changes = {};
    			if (dirty & /*$tab*/ 2) tab_1_changes.numtab = /*item*/ ctx[4];
    			tab_1.$set(tab_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tab_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tab_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(tab_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(18:4) {#if $isOning[i]}",
    		ctx
    	});

    	return block;
    }

    // (17:4) {#each $tab as item,i}
    function create_each_block$n(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$isOning*/ ctx[2][/*i*/ ctx[6]] && create_if_block$q(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$isOning*/ ctx[2][/*i*/ ctx[6]]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$isOning*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$q(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$n.name,
    		type: "each",
    		source: "(17:4) {#each $tab as item,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1e(ctx) {
    	let button;
    	let t0;
    	let div;
    	let new_1;
    	let t1;
    	let div_intro;
    	let div_outro;
    	let current;
    	let mounted;
    	let dispose;
    	new_1 = new New({ $$inline: true });
    	let each_value = /*$tab*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$n(get_each_context$n(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			button = element("button");
    			t0 = space();
    			div = element("div");
    			create_component(new_1.$$.fragment);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(button, "id", "backgen");
    			attr_dev(button, "class", "svelte-pn23s0");
    			add_location(button, file$1a, 12, 0, 237);
    			attr_dev(div, "id", "num");
    			attr_dev(div, "class", "svelte-pn23s0");
    			add_location(div, file$1a, 13, 0, 303);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			mount_component(new_1, div, null);
    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*click_handler*/ ctx[3], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$tab, $isOning*/ 6) {
    				each_value = /*$tab*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$n(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$n(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(new_1.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			add_render_callback(() => {
    				if (!current) return;
    				if (div_outro) div_outro.end(1);
    				div_intro = create_in_transition(div, slide, { duration: 500 });
    				div_intro.start();
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(new_1.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			if (div_intro) div_intro.invalidate();
    			div_outro = create_out_transition(div, slide, { duration: 200 });
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			destroy_component(new_1);
    			destroy_each(each_blocks, detaching);
    			if (detaching && div_outro) div_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1e($$self, $$props, $$invalidate) {
    	let $nameTF;
    	let $tab;
    	let $isOning;
    	validate_store(nameTF, 'nameTF');
    	component_subscribe($$self, nameTF, $$value => $$invalidate(0, $nameTF = $$value));
    	validate_store(tab, 'tab');
    	component_subscribe($$self, tab, $$value => $$invalidate(1, $tab = $$value));
    	validate_store(isOning, 'isOning');
    	component_subscribe($$self, isOning, $$value => $$invalidate(2, $isOning = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ContainPage', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContainPage> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		set_store_value(nameTF, $nameTF = true, $nameTF);
    	};

    	$$self.$capture_state = () => ({
    		tab,
    		isOning,
    		nameTF,
    		onTab,
    		Tab,
    		New,
    		slide,
    		$nameTF,
    		$tab,
    		$isOning
    	});

    	return [$nameTF, $tab, $isOning, click_handler];
    }

    class ContainPage extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1e, create_fragment$1e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContainPage",
    			options,
    			id: create_fragment$1e.name
    		});
    	}
    }

    /* srcReading\SavingOwn\SavingOwn.svelte generated by Svelte v3.59.2 */
    const file$19 = "srcReading\\SavingOwn\\SavingOwn.svelte";

    function create_fragment$1d(ctx) {
    	let div2;
    	let div0;
    	let input0;
    	let t0;
    	let div1;
    	let input1;
    	let t1;
    	let button0;
    	let t3;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			input0 = element("input");
    			t0 = space();
    			div1 = element("div");
    			input1 = element("input");
    			t1 = space();
    			button0 = element("button");
    			button0.textContent = "cancel";
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "done";
    			attr_dev(input0, "id", "enterText");
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Enter words/clauses");
    			attr_dev(input0, "class", "svelte-16vujlc");
    			add_location(input0, file$19, 34, 8, 1030);
    			attr_dev(div0, "class", "containOwn svelte-16vujlc");
    			add_location(div0, file$19, 32, 4, 985);
    			attr_dev(input1, "id", "meanenter");
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "Extract sentences/meanings");
    			attr_dev(input1, "class", "svelte-16vujlc");
    			add_location(input1, file$19, 38, 8, 1166);
    			attr_dev(div1, "class", "containOwn svelte-16vujlc");
    			add_location(div1, file$19, 36, 4, 1122);
    			attr_dev(button0, "id", "exit");
    			attr_dev(button0, "class", "minibut svelte-16vujlc");
    			add_location(button0, file$19, 40, 4, 1264);
    			attr_dev(button1, "id", "done");
    			attr_dev(button1, "class", "minibut svelte-16vujlc");
    			add_location(button1, file$19, 41, 0, 1337);
    			attr_dev(div2, "id", "containSavingOwn");
    			attr_dev(div2, "class", "svelte-16vujlc");
    			add_location(div2, file$19, 31, 0, 951);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, input0);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			append_dev(div1, input1);
    			append_dev(div2, t1);
    			append_dev(div2, button0);
    			append_dev(div2, t3);
    			append_dev(div2, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*Exit*/ ctx[0], false, false, false, false),
    					listen_dev(button1, "click", /*Done*/ ctx[1], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1d($$self, $$props, $$invalidate) {
    	let $selectedText;
    	let $choseText;
    	validate_store(selectedText, 'selectedText');
    	component_subscribe($$self, selectedText, $$value => $$invalidate(2, $selectedText = $$value));
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(3, $choseText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SavingOwn', slots, []);

    	onMount(() => {
    		document.getElementById('enterText').value = $choseText;
    	});

    	function Exit() {
    		set_store_value(selectedText, $selectedText = false, $selectedText);
    	}

    	function Done() {
    		set_store_value(selectedText, $selectedText = false, $selectedText);
    		let vocData = JSON.parse(localStorage.getItem('vocabulary'));
    		let date = `${new Date().getUTCDate()} - ${new Date().getUTCMonth() + 1} - ${new Date().getUTCFullYear()}`;

    		if (vocData.length === 0 || vocData[0].day !== date) {
    			let newDay = {};
    			newDay["day"] = date;
    			newDay["content"] = [];
    			vocData.unshift(newDay);
    		}

    		let con = {};
    		con["word"] = document.getElementById('enterText').value;
    		con["definition"] = document.getElementById('meanenter').value;
    		vocData[0].content.push(con);
    		localStorage.setItem('vocabulary', JSON.stringify(vocData));
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SavingOwn> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		choseText,
    		enterText: enterText$2,
    		selectedText,
    		Exit,
    		Done,
    		$selectedText,
    		$choseText
    	});

    	return [Exit, Done];
    }

    class SavingOwn extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1d, create_fragment$1d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SavingOwn",
    			options,
    			id: create_fragment$1d.name
    		});
    	}
    }

    /* srcReading\ChoicePanel\NoResult.svelte generated by Svelte v3.59.2 */
    const file$18 = "srcReading\\ChoicePanel\\NoResult.svelte";

    function create_fragment$1c(ctx) {
    	let button;
    	let t0;
    	let div;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t0 = space();
    			div = element("div");
    			div.textContent = "Opp!! No data found.";
    			attr_dev(button, "id", "backene");
    			attr_dev(button, "class", "svelte-s4xzaq");
    			add_location(button, file$18, 8, 0, 172);
    			attr_dev(div, "id", "noresult");
    			attr_dev(div, "class", "svelte-s4xzaq");
    			add_location(div, file$18, 10, 0, 229);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Backene*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1c($$self, $$props, $$invalidate) {
    	let $selectedText;
    	validate_store(selectedText, 'selectedText');
    	component_subscribe($$self, selectedText, $$value => $$invalidate(1, $selectedText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NoResult', slots, []);

    	function Backene() {
    		set_store_value(selectedText, $selectedText = '', $selectedText);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NoResult> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		selectedText,
    		slide,
    		Backene,
    		$selectedText
    	});

    	return [Backene];
    }

    let NoResult$2 = class NoResult extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1c, create_fragment$1c, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NoResult",
    			options,
    			id: create_fragment$1c.name
    		});
    	}
    };

    /* srcReading\QuickTask\QuickTaskPDF.svelte generated by Svelte v3.59.2 */
    const file$17 = "srcReading\\QuickTask\\QuickTaskPDF.svelte";

    function create_fragment$1b(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let button1;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "Find";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "Own-Saving";
    			attr_dev(button0, "id", "translate");
    			attr_dev(button0, "class", "buttask svelte-z8aefg");
    			add_location(button0, file$17, 44, 4, 1407);
    			attr_dev(button1, "id", "saveown");
    			attr_dev(button1, "class", "buttask svelte-z8aefg");
    			add_location(button1, file$17, 45, 4, 1484);
    			attr_dev(div, "id", "containQuickTask");
    			attr_dev(div, "class", "svelte-z8aefg");
    			add_location(div, file$17, 43, 0, 1338);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, button1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*RUN*/ ctx[0], false, false, false, false),
    					listen_dev(button1, "click", /*savingown*/ ctx[1], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1b($$self, $$props, $$invalidate) {
    	let $selectedTextForQuickTaskPDF;
    	let $selectedText;
    	let $choseText;
    	let $coordinateMouse;
    	validate_store(selectedTextForQuickTaskPDF, 'selectedTextForQuickTaskPDF');
    	component_subscribe($$self, selectedTextForQuickTaskPDF, $$value => $$invalidate(2, $selectedTextForQuickTaskPDF = $$value));
    	validate_store(selectedText, 'selectedText');
    	component_subscribe($$self, selectedText, $$value => $$invalidate(3, $selectedText = $$value));
    	validate_store(choseText, 'choseText');
    	component_subscribe($$self, choseText, $$value => $$invalidate(4, $choseText = $$value));
    	validate_store(coordinateMouse, 'coordinateMouse');
    	component_subscribe($$self, coordinateMouse, $$value => $$invalidate(5, $coordinateMouse = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('QuickTaskPDF', slots, []);

    	onMount(() => {
    		let container = document.getElementById('containQuickTask');

    		if ($coordinateMouse[0] + container.offsetWidth < window.innerWidth) {
    			container.style.left = $coordinateMouse[0] + 'px';
    		} else {
    			container.style.left = $coordinateMouse[0] - container.offsetWidth + 'px';
    		}

    		if ($coordinateMouse[1] + container.offsetHeight < window.innerHeight) {
    			container.style.top = $coordinateMouse[1] + 'px';
    		} else {
    			container.style.top = $coordinateMouse[1] - container.offsetHeight + 'px';
    		}
    	});

    	function RUN() {
    		set_store_value(selectedTextForQuickTaskPDF, $selectedTextForQuickTaskPDF = false, $selectedTextForQuickTaskPDF);
    		var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + $choseText;

    		fetch(link).then(res => {
    			if (res.ok) {
    				set_store_value(selectedText, $selectedText = 'available', $selectedText);
    			} else {
    				set_store_value(selectedText, $selectedText = 'notfound', $selectedText);
    			}
    		});
    	}

    	function savingown() {
    		set_store_value(selectedText, $selectedText = 'owning', $selectedText);
    		set_store_value(selectedTextForQuickTaskPDF, $selectedTextForQuickTaskPDF = false, $selectedTextForQuickTaskPDF);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<QuickTaskPDF> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		choseText,
    		coordinateMouse,
    		selectedText,
    		selectedTextForQuickTaskPDF,
    		slide,
    		RUN,
    		savingown,
    		$selectedTextForQuickTaskPDF,
    		$selectedText,
    		$choseText,
    		$coordinateMouse
    	});

    	return [RUN, savingown];
    }

    class QuickTaskPDF extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1b, create_fragment$1b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "QuickTaskPDF",
    			options,
    			id: create_fragment$1b.name
    		});
    	}
    }

    /* srcReading\TaskBar\Taskbar.svelte generated by Svelte v3.59.2 */

    const { console: console_1$q } = globals;
    const file$16 = "srcReading\\TaskBar\\Taskbar.svelte";

    function get_each_context$m(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	child_ctx[13] = i;
    	return child_ctx;
    }

    // (50:32) 
    function create_if_block_14(ctx) {
    	let img;
    	let img_src_value;
    	let t;
    	let pdftask;
    	let current;
    	pdftask = new PDFtask({ $$inline: true });

    	const block = {
    		c: function create() {
    			img = element("img");
    			t = space();
    			create_component(pdftask.$$.fragment);
    			if (!src_url_equal(img.src, img_src_value = "../images/withoutunderwhite.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "id", "logo");
    			attr_dev(img, "class", "svelte-112tfrp");
    			add_location(img, file$16, 50, 8, 1932);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(pdftask, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(pdftask.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(pdftask.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			if (detaching) detach_dev(t);
    			destroy_component(pdftask, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_14.name,
    		type: "if",
    		source: "(50:32) ",
    		ctx
    	});

    	return block;
    }

    // (46:34) 
    function create_if_block_13(ctx) {
    	let img;
    	let img_src_value;
    	let t;
    	let imagetask;
    	let current;
    	imagetask = new ImageTask({ $$inline: true });

    	const block = {
    		c: function create() {
    			img = element("img");
    			t = space();
    			create_component(imagetask.$$.fragment);
    			if (!src_url_equal(img.src, img_src_value = "../images/withoutunderwhite.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "id", "logo");
    			attr_dev(img, "class", "svelte-112tfrp");
    			add_location(img, file$16, 46, 4, 1788);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(imagetask, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(imagetask.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(imagetask.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			if (detaching) detach_dev(t);
    			destroy_component(imagetask, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_13.name,
    		type: "if",
    		source: "(46:34) ",
    		ctx
    	});

    	return block;
    }

    // (39:33) 
    function create_if_block_11(ctx) {
    	let img;
    	let img_src_value;
    	let t;
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_12, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$moreless*/ ctx[1] == "more") return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			img = element("img");
    			t = space();
    			if_block.c();
    			if_block_anchor = empty();
    			if (!src_url_equal(img.src, img_src_value = "../images/withoutunderwhite.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "id", "logo");
    			attr_dev(img, "class", "svelte-112tfrp");
    			add_location(img, file$16, 39, 8, 1562);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    			insert_dev(target, t, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			if (detaching) detach_dev(t);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_11.name,
    		type: "if",
    		source: "(39:33) ",
    		ctx
    	});

    	return block;
    }

    // (37:4) {#if $taskbar == "no"}
    function create_if_block_10(ctx) {
    	let nothing;
    	let current;
    	nothing = new Nothing({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(nothing.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nothing, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nothing.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nothing.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nothing, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(37:4) {#if $taskbar == \\\"no\\\"}",
    		ctx
    	});

    	return block;
    }

    // (43:8) {:else}
    function create_else_block_1(ctx) {
    	let extratexttask;
    	let current;
    	extratexttask = new ExtraTextTask({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(extratexttask.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(extratexttask, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(extratexttask.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(extratexttask.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(extratexttask, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(43:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (41:8) {#if $moreless == "more"}
    function create_if_block_12(ctx) {
    	let texttask;
    	let current;
    	texttask = new TextTask({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(texttask.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(texttask, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(texttask.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(texttask.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(texttask, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_12.name,
    		type: "if",
    		source: "(41:8) {#if $moreless == \\\"more\\\"}",
    		ctx
    	});

    	return block;
    }

    // (59:42) 
    function create_if_block_9(ctx) {
    	let noresult;
    	let current;
    	noresult = new NoResult$2({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(noresult.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(noresult, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(noresult.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(noresult.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(noresult, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(59:42) ",
    		ctx
    	});

    	return block;
    }

    // (57:40) 
    function create_if_block_8(ctx) {
    	let savingown;
    	let current;
    	savingown = new SavingOwn({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(savingown.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(savingown, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(savingown.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(savingown.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(savingown, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(57:40) ",
    		ctx
    	});

    	return block;
    }

    // (55:4) {#if $selectedText == 'available'}
    function create_if_block_7$2(ctx) {
    	let choicepanel;
    	let current;
    	choicepanel = new ChoicePanel({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(choicepanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(choicepanel, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(choicepanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(choicepanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(choicepanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(55:4) {#if $selectedText == 'available'}",
    		ctx
    	});

    	return block;
    }

    // (63:4) {#if $selectedTextForQuickTask}
    function create_if_block_6$3(ctx) {
    	let quicktask;
    	let current;
    	quicktask = new QuickTask({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(quicktask.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(quicktask, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(quicktask.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(quicktask.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(quicktask, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(63:4) {#if $selectedTextForQuickTask}",
    		ctx
    	});

    	return block;
    }

    // (67:4) {#if $selectedTextForQuickTaskPDF}
    function create_if_block_5$3(ctx) {
    	let quicktaskpdf;
    	let current;
    	quicktaskpdf = new QuickTaskPDF({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(quicktaskpdf.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(quicktaskpdf, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(quicktaskpdf.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(quicktaskpdf.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(quicktaskpdf, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(67:4) {#if $selectedTextForQuickTaskPDF}",
    		ctx
    	});

    	return block;
    }

    // (71:4) {#if $dictionaryDS}
    function create_if_block_4$4(ctx) {
    	let dictionary;
    	let current;
    	dictionary = new Dictionary$2({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dictionary.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dictionary, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dictionary.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dictionary.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dictionary, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(71:4) {#if $dictionaryDS}",
    		ctx
    	});

    	return block;
    }

    // (75:4) {#if $captureTF}
    function create_if_block_3$4(ctx) {
    	let upopcap;
    	let current;
    	upopcap = new UpopCap({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(upopcap.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(upopcap, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(upopcap.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(upopcap.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(upopcap, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(75:4) {#if $captureTF}",
    		ctx
    	});

    	return block;
    }

    // (82:4) {#if $imageTF}
    function create_if_block_2$8(ctx) {
    	let upboard;
    	let current;
    	upboard = new UpBoard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(upboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(upboard, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(upboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(upboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(upboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(82:4) {#if $imageTF}",
    		ctx
    	});

    	return block;
    }

    // (88:4) {:else}
    function create_else_block$7(ctx) {
    	let containpage;
    	let current;
    	containpage = new ContainPage({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(containpage.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(containpage, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(containpage.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(containpage.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(containpage, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(88:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (86:4) {#if $nameTF}
    function create_if_block_1$c(ctx) {
    	let nametab;
    	let current;
    	nametab = new NameTab({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(nametab.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(nametab, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(nametab.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(nametab.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(nametab, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(86:4) {#if $nameTF}",
    		ctx
    	});

    	return block;
    }

    // (94:0) {#if $isOning[i]}
    function create_if_block$p(ctx) {
    	let textarea;
    	let current;

    	textarea = new Textarea$1({
    			props: {
    				content: /*item*/ ctx[11],
    				page: /*i*/ ctx[13] + 1
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(textarea.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textarea, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textarea_changes = {};
    			if (dirty & /*$tab*/ 512) textarea_changes.content = /*item*/ ctx[11];
    			textarea.$set(textarea_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textarea.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textarea.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textarea, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(94:0) {#if $isOning[i]}",
    		ctx
    	});

    	return block;
    }

    // (93:0) {#each $tab as item,i}
    function create_each_block$m(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$isOning*/ ctx[10][/*i*/ ctx[13]] && create_if_block$p(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*$isOning*/ ctx[10][/*i*/ ctx[13]]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$isOning*/ 1024) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$p(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$m.name,
    		type: "each",
    		source: "(93:0) {#each $tab as item,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1a(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let current_block_type_index_1;
    	let if_block1;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let current_block_type_index_2;
    	let if_block7;
    	let t7;
    	let each_1_anchor;
    	let current;
    	const if_block_creators = [create_if_block_10, create_if_block_11, create_if_block_13, create_if_block_14];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$taskbar*/ ctx[0] == "no") return 0;
    		if (/*$taskbar*/ ctx[0] == "text") return 1;
    		if (/*$taskbar*/ ctx[0] == "image") return 2;
    		if (/*$taskbar*/ ctx[0] == "pdf") return 3;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const if_block_creators_1 = [create_if_block_7$2, create_if_block_8, create_if_block_9];
    	const if_blocks_1 = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*$selectedText*/ ctx[2] == 'available') return 0;
    		if (/*$selectedText*/ ctx[2] == 'owning') return 1;
    		if (/*$selectedText*/ ctx[2] == 'notfound') return 2;
    		return -1;
    	}

    	if (~(current_block_type_index_1 = select_block_type_2(ctx))) {
    		if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    	}

    	let if_block2 = /*$selectedTextForQuickTask*/ ctx[3] && create_if_block_6$3(ctx);
    	let if_block3 = /*$selectedTextForQuickTaskPDF*/ ctx[4] && create_if_block_5$3(ctx);
    	let if_block4 = /*$dictionaryDS*/ ctx[5] && create_if_block_4$4(ctx);
    	let if_block5 = /*$captureTF*/ ctx[6] && create_if_block_3$4(ctx);
    	let if_block6 = /*$imageTF*/ ctx[7] && create_if_block_2$8(ctx);
    	const if_block_creators_2 = [create_if_block_1$c, create_else_block$7];
    	const if_blocks_2 = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*$nameTF*/ ctx[8]) return 0;
    		return 1;
    	}

    	current_block_type_index_2 = select_block_type_3(ctx);
    	if_block7 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    	let each_value = /*$tab*/ ctx[9];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			t3 = space();
    			if (if_block4) if_block4.c();
    			t4 = space();
    			if (if_block5) if_block5.c();
    			t5 = space();
    			if (if_block6) if_block6.c();
    			t6 = space();
    			if_block7.c();
    			t7 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			attr_dev(div, "class", "taskbar svelte-112tfrp");
    			add_location(div, file$16, 34, 0, 1440);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div, null);
    			}

    			append_dev(div, t0);

    			if (~current_block_type_index_1) {
    				if_blocks_1[current_block_type_index_1].m(div, null);
    			}

    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t3);
    			if (if_block4) if_block4.m(div, null);
    			append_dev(div, t4);
    			if (if_block5) if_block5.m(div, null);
    			append_dev(div, t5);
    			if (if_block6) if_block6.m(div, null);
    			append_dev(div, t6);
    			if_blocks_2[current_block_type_index_2].m(div, null);
    			insert_dev(target, t7, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block0) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block0 = if_blocks[current_block_type_index];

    					if (!if_block0) {
    						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block0.c();
    					} else {
    						if_block0.p(ctx, dirty);
    					}

    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				} else {
    					if_block0 = null;
    				}
    			}

    			let previous_block_index_1 = current_block_type_index_1;
    			current_block_type_index_1 = select_block_type_2(ctx);

    			if (current_block_type_index_1 !== previous_block_index_1) {
    				if (if_block1) {
    					group_outros();

    					transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
    						if_blocks_1[previous_block_index_1] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index_1) {
    					if_block1 = if_blocks_1[current_block_type_index_1];

    					if (!if_block1) {
    						if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
    						if_block1.c();
    					}

    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				} else {
    					if_block1 = null;
    				}
    			}

    			if (/*$selectedTextForQuickTask*/ ctx[3]) {
    				if (if_block2) {
    					if (dirty & /*$selectedTextForQuickTask*/ 8) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_6$3(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$selectedTextForQuickTaskPDF*/ ctx[4]) {
    				if (if_block3) {
    					if (dirty & /*$selectedTextForQuickTaskPDF*/ 16) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_5$3(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t3);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*$dictionaryDS*/ ctx[5]) {
    				if (if_block4) {
    					if (dirty & /*$dictionaryDS*/ 32) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_4$4(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, t4);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*$captureTF*/ ctx[6]) {
    				if (if_block5) {
    					if (dirty & /*$captureTF*/ 64) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_3$4(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div, t5);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*$imageTF*/ ctx[7]) {
    				if (if_block6) {
    					if (dirty & /*$imageTF*/ 128) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_2$8(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div, t6);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index_2 = current_block_type_index_2;
    			current_block_type_index_2 = select_block_type_3(ctx);

    			if (current_block_type_index_2 !== previous_block_index_2) {
    				group_outros();

    				transition_out(if_blocks_2[previous_block_index_2], 1, 1, () => {
    					if_blocks_2[previous_block_index_2] = null;
    				});

    				check_outros();
    				if_block7 = if_blocks_2[current_block_type_index_2];

    				if (!if_block7) {
    					if_block7 = if_blocks_2[current_block_type_index_2] = if_block_creators_2[current_block_type_index_2](ctx);
    					if_block7.c();
    				}

    				transition_in(if_block7, 1);
    				if_block7.m(div, null);
    			}

    			if (dirty & /*$tab, $isOning*/ 1536) {
    				each_value = /*$tab*/ ctx[9];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$m(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$m(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			transition_in(if_block7);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			transition_out(if_block7);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			if (~current_block_type_index_1) {
    				if_blocks_1[current_block_type_index_1].d();
    			}

    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if_blocks_2[current_block_type_index_2].d();
    			if (detaching) detach_dev(t7);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1a($$self, $$props, $$invalidate) {
    	let $taskbar;
    	let $moreless;
    	let $selectedText;
    	let $selectedTextForQuickTask;
    	let $selectedTextForQuickTaskPDF;
    	let $dictionaryDS;
    	let $captureTF;
    	let $imageTF;
    	let $nameTF;
    	let $tab;
    	let $isOning;
    	validate_store(taskbar, 'taskbar');
    	component_subscribe($$self, taskbar, $$value => $$invalidate(0, $taskbar = $$value));
    	validate_store(moreless, 'moreless');
    	component_subscribe($$self, moreless, $$value => $$invalidate(1, $moreless = $$value));
    	validate_store(selectedText, 'selectedText');
    	component_subscribe($$self, selectedText, $$value => $$invalidate(2, $selectedText = $$value));
    	validate_store(selectedTextForQuickTask, 'selectedTextForQuickTask');
    	component_subscribe($$self, selectedTextForQuickTask, $$value => $$invalidate(3, $selectedTextForQuickTask = $$value));
    	validate_store(selectedTextForQuickTaskPDF, 'selectedTextForQuickTaskPDF');
    	component_subscribe($$self, selectedTextForQuickTaskPDF, $$value => $$invalidate(4, $selectedTextForQuickTaskPDF = $$value));
    	validate_store(dictionaryDS$2, 'dictionaryDS');
    	component_subscribe($$self, dictionaryDS$2, $$value => $$invalidate(5, $dictionaryDS = $$value));
    	validate_store(captureTF, 'captureTF');
    	component_subscribe($$self, captureTF, $$value => $$invalidate(6, $captureTF = $$value));
    	validate_store(imageTF, 'imageTF');
    	component_subscribe($$self, imageTF, $$value => $$invalidate(7, $imageTF = $$value));
    	validate_store(nameTF, 'nameTF');
    	component_subscribe($$self, nameTF, $$value => $$invalidate(8, $nameTF = $$value));
    	validate_store(tab, 'tab');
    	component_subscribe($$self, tab, $$value => $$invalidate(9, $tab = $$value));
    	validate_store(isOning, 'isOning');
    	component_subscribe($$self, isOning, $$value => $$invalidate(10, $isOning = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Taskbar', slots, []);

    	onMount(() => {
    		if (!localStorage.getItem('vocabulary')) {
    			// If the item doesn't exist, set it in localStorage
    			localStorage.setItem('vocabulary', JSON.stringify([]));

    			console.log("okkkkkkkkkkkkkk");
    		} else {
    			console.log('ádsd');
    		}
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$q.warn(`<Taskbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		TextTask,
    		ExtraTextTask,
    		dictionaryDS: dictionaryDS$2,
    		moreless,
    		selectedText,
    		tab,
    		taskbar,
    		captureTF,
    		imageTF,
    		isOning,
    		selectedTextForQuickTask,
    		nameTF,
    		selectedTextForQuickTaskPDF,
    		Textarea: Textarea$1,
    		onMount,
    		Nothing,
    		ImageTask,
    		ChoicePanel,
    		Dictionary: Dictionary$2,
    		PdFtask: PDFtask,
    		UpopCap,
    		UpBoard,
    		QuickTask,
    		NameTab,
    		ContainPage,
    		SavingOwn,
    		NoResult: NoResult$2,
    		QuickTaskPdf: QuickTaskPDF,
    		$taskbar,
    		$moreless,
    		$selectedText,
    		$selectedTextForQuickTask,
    		$selectedTextForQuickTaskPDF,
    		$dictionaryDS,
    		$captureTF,
    		$imageTF,
    		$nameTF,
    		$tab,
    		$isOning
    	});

    	return [
    		$taskbar,
    		$moreless,
    		$selectedText,
    		$selectedTextForQuickTask,
    		$selectedTextForQuickTaskPDF,
    		$dictionaryDS,
    		$captureTF,
    		$imageTF,
    		$nameTF,
    		$tab,
    		$isOning
    	];
    }

    let Taskbar$2 = class Taskbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1a, create_fragment$1a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Taskbar",
    			options,
    			id: create_fragment$1a.name
    		});
    	}
    };

    /* srcReading\Reading.svelte generated by Svelte v3.59.2 */

    function create_fragment$19(ctx) {
    	let taskbar;
    	let current;
    	taskbar = new Taskbar$2({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(taskbar.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(taskbar, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(taskbar.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(taskbar.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(taskbar, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$19.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$19($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Reading', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Reading> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ Taskbar: Taskbar$2 });
    	return [];
    }

    class Reading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$19, create_fragment$19, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Reading",
    			options,
    			id: create_fragment$19.name
    		});
    	}
    }

    let dictionaryDS$1 = writable(false);

    let enterText$1 = writable('');

    let stepDS$1 = writable('defi');

    let editBoard = writable(false);

    let numWord = writable();
    let lenWord = writable();
    let ongoingText = writable();

    let result = writable([]);

    let finalanswerTF = writable(false);

    let testAns = writable([]);

    /* srcListening\TaskBar\Taskbar.svelte generated by Svelte v3.59.2 */
    const file$15 = "srcListening\\TaskBar\\Taskbar.svelte";

    function create_fragment$18(ctx) {
    	let div1;
    	let div0;
    	let select0;
    	let option0;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let t5;
    	let select1;
    	let option5;
    	let option6;
    	let option7;
    	let option8;
    	let option9;
    	let option10;
    	let option11;
    	let t13;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "cursive";
    			option1 = element("option");
    			option1.textContent = "fantasy";
    			option2 = element("option");
    			option2.textContent = "serif";
    			option3 = element("option");
    			option3.textContent = "monospace";
    			option4 = element("option");
    			option4.textContent = "Times New Roman";
    			t5 = space();
    			select1 = element("select");
    			option5 = element("option");
    			option5.textContent = "1";
    			option6 = element("option");
    			option6.textContent = "2";
    			option7 = element("option");
    			option7.textContent = "2.5";
    			option8 = element("option");
    			option8.textContent = "3";
    			option9 = element("option");
    			option9.textContent = "3.5";
    			option10 = element("option");
    			option10.textContent = "4";
    			option11 = element("option");
    			option11.textContent = "4.5";
    			t13 = space();
    			button = element("button");
    			button.textContent = "dictionary";
    			option0.__value = "cursive";
    			option0.value = option0.__value;
    			add_location(option0, file$15, 30, 8, 546);
    			option1.__value = "fantasy";
    			option1.value = option1.__value;
    			add_location(option1, file$15, 31, 8, 597);
    			option2.__value = "serif";
    			option2.value = option2.__value;
    			add_location(option2, file$15, 32, 8, 649);
    			option3.__value = "monospace";
    			option3.value = option3.__value;
    			add_location(option3, file$15, 33, 8, 697);
    			option4.__value = "\"Times New Roman\"";
    			option4.value = option4.__value;
    			add_location(option4, file$15, 34, 8, 753);
    			attr_dev(select0, "id", "font");
    			attr_dev(select0, "class", "svelte-1xtah4r");
    			add_location(select0, file$15, 29, 4, 498);
    			option5.__value = "1";
    			option5.value = option5.__value;
    			add_location(option5, file$15, 38, 8, 884);
    			option6.__value = "2";
    			option6.value = option6.__value;
    			add_location(option6, file$15, 39, 8, 923);
    			option7.__value = "2.5";
    			option7.value = option7.__value;
    			add_location(option7, file$15, 40, 8, 963);
    			option8.__value = "3";
    			option8.value = option8.__value;
    			add_location(option8, file$15, 41, 8, 1007);
    			option9.__value = "3.5";
    			option9.value = option9.__value;
    			add_location(option9, file$15, 42, 8, 1047);
    			option10.__value = "4";
    			option10.value = option10.__value;
    			add_location(option10, file$15, 43, 8, 1091);
    			option11.__value = "4.5";
    			option11.value = option11.__value;
    			add_location(option11, file$15, 44, 8, 1131);
    			attr_dev(select1, "id", "size");
    			attr_dev(select1, "class", "svelte-1xtah4r");
    			add_location(select1, file$15, 37, 4, 836);
    			attr_dev(div0, "class", "group1 svelte-1xtah4r");
    			add_location(div0, file$15, 28, 4, 470);
    			attr_dev(button, "id", "dic");
    			attr_dev(button, "class", "extrabut svelte-1xtah4r");
    			add_location(button, file$15, 51, 8, 1221);
    			attr_dev(div1, "class", "container svelte-1xtah4r");
    			add_location(div1, file$15, 27, 0, 439);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, select0);
    			append_dev(select0, option0);
    			append_dev(select0, option1);
    			append_dev(select0, option2);
    			append_dev(select0, option3);
    			append_dev(select0, option4);
    			append_dev(div0, t5);
    			append_dev(div0, select1);
    			append_dev(select1, option5);
    			append_dev(select1, option6);
    			append_dev(select1, option7);
    			append_dev(select1, option8);
    			append_dev(select1, option9);
    			append_dev(select1, option10);
    			append_dev(select1, option11);
    			append_dev(div1, t13);
    			append_dev(div1, button);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select0, "change", Font, false, false, false, false),
    					listen_dev(select1, "change", Size, false, false, false, false),
    					listen_dev(button, "click", /*Dictest*/ ctx[0], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$18.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Font() {
    	document.getElementById('textarea').style.fontFamily = document.getElementById('font').value;
    }

    function Size() {
    	document.getElementById('textarea').style.fontSize = document.getElementById("size").value + 'vh';
    }

    function instance$18($$self, $$props, $$invalidate) {
    	let $dictionaryDS;
    	validate_store(dictionaryDS$1, 'dictionaryDS');
    	component_subscribe($$self, dictionaryDS$1, $$value => $$invalidate(1, $dictionaryDS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Taskbar', slots, []);

    	function Dictest() {
    		set_store_value(dictionaryDS$1, $dictionaryDS = true, $dictionaryDS);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Taskbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		dictionaryDS: dictionaryDS$1,
    		Font,
    		Size,
    		Dictest,
    		$dictionaryDS
    	});

    	return [Dictest];
    }

    let Taskbar$1 = class Taskbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$18, create_fragment$18, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Taskbar",
    			options,
    			id: create_fragment$18.name
    		});
    	}
    };

    /* srcListening\TaskBoard\NumLength.svelte generated by Svelte v3.59.2 */

    const file$14 = "srcListening\\TaskBoard\\NumLength.svelte";

    function create_fragment$17(ctx) {
    	let div0;
    	let t1;
    	let input0;
    	let t2;
    	let div1;
    	let t4;
    	let input1;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div0.textContent = "number";
    			t1 = space();
    			input0 = element("input");
    			t2 = space();
    			div1 = element("div");
    			div1.textContent = "length";
    			t4 = space();
    			input1 = element("input");
    			attr_dev(div0, "class", "tile svelte-axzckv");
    			add_location(div0, file$14, 0, 0, 0);
    			attr_dev(input0, "type", "number");
    			attr_dev(input0, "class", "in svelte-axzckv");
    			attr_dev(input0, "id", "numword");
    			add_location(input0, file$14, 1, 4, 37);
    			attr_dev(div1, "class", "tile svelte-axzckv");
    			add_location(div1, file$14, 3, 1, 93);
    			attr_dev(input1, "type", "number");
    			attr_dev(input1, "class", "in svelte-axzckv");
    			attr_dev(input1, "id", "lenword");
    			add_location(input1, file$14, 4, 0, 126);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, input0, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div1, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, input1, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(input0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div1);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(input1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$17.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$17($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NumLength', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NumLength> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class NumLength extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$17, create_fragment$17, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NumLength",
    			options,
    			id: create_fragment$17.name
    		});
    	}
    }

    /* srcListening\TaskBoard\Taskboard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$p } = globals;
    const file$13 = "srcListening\\TaskBoard\\Taskboard.svelte";

    function create_fragment$16(ctx) {
    	let div1;
    	let div0;
    	let numlength;
    	let t0;
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	numlength = new NumLength({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			create_component(numlength.$$.fragment);
    			t0 = space();
    			button = element("button");
    			button.textContent = "Convert";
    			attr_dev(button, "id", "convert");
    			attr_dev(button, "class", "svelte-1h2c1ul");
    			add_location(button, file$13, 146, 4, 4266);
    			attr_dev(div0, "id", "containtask");
    			attr_dev(div0, "class", "svelte-1h2c1ul");
    			add_location(div0, file$13, 144, 4, 4214);
    			attr_dev(div1, "id", "taskboard");
    			attr_dev(div1, "class", "svelte-1h2c1ul");
    			add_location(div1, file$13, 143, 0, 4186);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			mount_component(numlength, div0, null);
    			append_dev(div0, t0);
    			append_dev(div0, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Convert*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(numlength.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(numlength.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(numlength);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$16.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$16($$self, $$props, $$invalidate) {
    	let $result;
    	let $numWord;
    	let $lenWord;
    	let $ongoingText;
    	let $finalanswerTF;
    	validate_store(result, 'result');
    	component_subscribe($$self, result, $$value => $$invalidate(1, $result = $$value));
    	validate_store(numWord, 'numWord');
    	component_subscribe($$self, numWord, $$value => $$invalidate(2, $numWord = $$value));
    	validate_store(lenWord, 'lenWord');
    	component_subscribe($$self, lenWord, $$value => $$invalidate(3, $lenWord = $$value));
    	validate_store(ongoingText, 'ongoingText');
    	component_subscribe($$self, ongoingText, $$value => $$invalidate(4, $ongoingText = $$value));
    	validate_store(finalanswerTF, 'finalanswerTF');
    	component_subscribe($$self, finalanswerTF, $$value => $$invalidate(5, $finalanswerTF = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Taskboard', slots, []);

    	function Convert() {
    		var yt = document.getElementsByClassName('answer');
    		Array.from(yt).forEach(test);

    		function test(element) {
    			element.value = '';
    		}

    		set_store_value(finalanswerTF, $finalanswerTF = false, $finalanswerTF);

    		result.update(value => {
    			return [];
    		});

    		set_store_value(numWord, $numWord = document.getElementById('numword').value, $numWord);
    		set_store_value(lenWord, $lenWord = document.getElementById('lenword').value, $lenWord);
    		let text = $ongoingText;
    		const regex = /\w+\’\w+|\b\w+\b|[^\w\s\n]|\n|\s/g;
    		let matches = [];
    		let match;

    		while (match = regex.exec(text)) {
    			matches.push(match[0]);
    		}

    		//let ui = text.split(/\W+/).filter(word => word && word != "'");
    		//let ui = text.match(/\w+\’\w+|\b\w+\b/g)
    		let ui = matches;

    		let v = $lenWord;
    		let r = $numWord;
    		let a = Math.round(ui.length / $numWord);
    		let yep;

    		function testText(text) {
    			var pattern = /^[a-zA-Z0-9]+$/;
    			return pattern.test(text);
    		}

    		for (let i = 0; i <= r - 1; i++) {
    			if (i == r - 1) {
    				let max = ui.length - 1;
    				let l = max;
    				let d = 0;

    				while (i * a < l) {
    					if (testText(ui[l])) {
    						d++;
    					}

    					if (d == v) {
    						break;
    					}

    					l = l - 1;
    				}

    				yep = Math.floor(Math.random() * (max - i * a + 1)) + i * a;

    				while (!testText(ui[yep]) || yep > l) {
    					yep = Math.floor(Math.random() * (max - i * a + 1)) + i * a;
    				}

    				l = yep;
    				let S = "";
    				d = 0;

    				while (l < max) {
    					if (testText(ui[l])) {
    						if (d == v - 1) {
    							S += ui[l];
    						} else {
    							S += ui[l] + " ";
    						}

    						d++;

    						if (d == 1) {
    							ui[l] = "(" + `${i + 1}` + ")" + ("_ ").repeat(ui[l].length);
    						} else {
    							ui[l] = ("_ ").repeat(ui[l].length);
    						}
    					}

    					if (d == v) {
    						break;
    					}

    					l++;
    				}

    				console.log(S);

    				result.update(value => {
    					return [...value, S];
    				});
    			} else {
    				let max = (i + 1) * a - 1;
    				let l = max;
    				let d = 0;

    				while (i * a < l) {
    					if (testText(ui[l])) {
    						d++;
    					}

    					if (d == v) {
    						break;
    					}

    					l = l - 1;
    				}

    				yep = Math.floor(Math.random() * ((i + 1) * a - 1 - i * a + 1)) + i * a;

    				while (!testText(ui[yep]) || yep > l) {
    					yep = Math.floor(Math.random() * ((i + 1) * a - 1 - i * a + 1)) + i * a;
    				}

    				l = yep;
    				let S = "";
    				d = 0;

    				while (l < max) {
    					if (testText(ui[l])) {
    						if (d == v - 1) {
    							S += ui[l];
    						} else {
    							S += ui[l] + " ";
    						}

    						d++;

    						if (d == 1) {
    							ui[l] = "(" + `${i + 1}` + ")" + ("_ ").repeat(ui[l].length);
    						} else {
    							ui[l] = ("_ ").repeat(ui[l].length);
    						}

    						console.log(l, "asasasas", ui[l]);
    					}

    					if (d == v) {
    						break;
    					}

    					l++;
    				}

    				console.log(S);

    				result.update(value => {
    					return [...value, S];
    				});
    			}
    		}

    		document.getElementById('textarea').value = ui.join('');
    		console.log($result);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$p.warn(`<Taskboard> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		finalanswerTF,
    		lenWord,
    		numWord,
    		ongoingText,
    		result,
    		NumLength,
    		Convert,
    		$result,
    		$numWord,
    		$lenWord,
    		$ongoingText,
    		$finalanswerTF
    	});

    	return [Convert];
    }

    class Taskboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$16, create_fragment$16, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Taskboard",
    			options,
    			id: create_fragment$16.name
    		});
    	}
    }

    /* srcListening\TextArea\Textarea.svelte generated by Svelte v3.59.2 */
    const file$12 = "srcListening\\TextArea\\Textarea.svelte";

    function create_fragment$15(ctx) {
    	let button;
    	let t1;
    	let textarea;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "Edit";
    			t1 = space();
    			textarea = element("textarea");
    			attr_dev(button, "id", "enterText");
    			attr_dev(button, "class", "svelte-13jf9k8");
    			add_location(button, file$12, 9, 0, 127);
    			attr_dev(textarea, "id", "textarea");
    			attr_dev(textarea, "spellcheck", "false");
    			textarea.readOnly = true;
    			attr_dev(textarea, "class", "svelte-13jf9k8");
    			add_location(textarea, file$12, 10, 0, 185);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, textarea, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Edit*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(textarea);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$15.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$15($$self, $$props, $$invalidate) {
    	let $editBoard;
    	validate_store(editBoard, 'editBoard');
    	component_subscribe($$self, editBoard, $$value => $$invalidate(1, $editBoard = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Textarea', slots, []);

    	function Edit() {
    		set_store_value(editBoard, $editBoard = true, $editBoard);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Textarea> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ editBoard, Edit, $editBoard });
    	return [Edit];
    }

    class Textarea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$15, create_fragment$15, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Textarea",
    			options,
    			id: create_fragment$15.name
    		});
    	}
    }

    /* srcListening\Dictionary\BoardDic.svelte generated by Svelte v3.59.2 */
    const file$11 = "srcListening\\Dictionary\\BoardDic.svelte";

    function create_fragment$14(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let button2;
    	let t5;
    	let button3;
    	let t7;
    	let button4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "defi";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "syn";
    			t3 = space();
    			button2 = element("button");
    			button2.textContent = "ant";
    			t5 = space();
    			button3 = element("button");
    			button3.textContent = "adj";
    			t7 = space();
    			button4 = element("button");
    			button4.textContent = "noun";
    			attr_dev(button0, "class", "typeDS svelte-11v8fm6");
    			add_location(button0, file$11, 35, 4, 1042);
    			attr_dev(button1, "class", "typeDS svelte-11v8fm6");
    			add_location(button1, file$11, 36, 4, 1117);
    			attr_dev(button2, "class", "typeDS svelte-11v8fm6");
    			add_location(button2, file$11, 37, 4, 1190);
    			attr_dev(button3, "class", "typeDS svelte-11v8fm6");
    			add_location(button3, file$11, 38, 4, 1263);
    			attr_dev(button4, "class", "typeDS svelte-11v8fm6");
    			add_location(button4, file$11, 39, 4, 1336);
    			attr_dev(div, "id", "containerTypeDS");
    			attr_dev(div, "class", "svelte-11v8fm6");
    			add_location(div, file$11, 34, 0, 1008);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, button1);
    			append_dev(div, t3);
    			append_dev(div, button2);
    			append_dev(div, t5);
    			append_dev(div, button3);
    			append_dev(div, t7);
    			append_dev(div, button4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[1], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[3], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[4], false, false, false, false),
    					listen_dev(button4, "click", /*click_handler_4*/ ctx[5], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$14.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$14($$self, $$props, $$invalidate) {
    	let $stepDS;
    	validate_store(stepDS$1, 'stepDS');
    	component_subscribe($$self, stepDS$1, $$value => $$invalidate(6, $stepDS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BoardDic', slots, []);

    	onMount(() => {
    		document.getElementsByClassName('typeDS')[0].style.backgroundColor = '#fefefe';
    		document.getElementsByClassName('typeDS')[0].style.color = '#1d1d1d';
    	});

    	function Ref(choice, k) {
    		if (choice == 'defi') {
    			set_store_value(stepDS$1, $stepDS = 'defi', $stepDS);
    		} else if (choice == 'syn') {
    			set_store_value(stepDS$1, $stepDS = 'syn', $stepDS);
    		} else if (choice == 'ant') {
    			set_store_value(stepDS$1, $stepDS = 'ant', $stepDS);
    		} else if (choice == 'coA') {
    			set_store_value(stepDS$1, $stepDS = 'coA', $stepDS);
    		} else if (choice == 'coN') {
    			set_store_value(stepDS$1, $stepDS = 'coN', $stepDS);
    		}

    		for (let i = 0; i <= 4; i++) {
    			if (i + 1 == k) {
    				document.getElementsByClassName('typeDS')[i].style.backgroundColor = '#fefefe';
    				document.getElementsByClassName('typeDS')[i].style.color = '#1d1d1d';
    			} else {
    				document.getElementsByClassName('typeDS')[i].style.backgroundColor = 'transparent';
    				document.getElementsByClassName('typeDS')[i].style.color = '#fefefe';
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BoardDic> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		Ref('defi', 1);
    	};

    	const click_handler_1 = () => {
    		Ref('syn', 2);
    	};

    	const click_handler_2 = () => {
    		Ref('ant', 3);
    	};

    	const click_handler_3 = () => {
    		Ref('coA', 4);
    	};

    	const click_handler_4 = () => {
    		Ref('coN', 5);
    	};

    	$$self.$capture_state = () => ({ onMount, stepDS: stepDS$1, Ref, $stepDS });

    	return [
    		Ref,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4
    	];
    }

    let BoardDic$1 = class BoardDic extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$14, create_fragment$14, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BoardDic",
    			options,
    			id: create_fragment$14.name
    		});
    	}
    };

    /* srcListening\Dictionary\DefiDS.svelte generated by Svelte v3.59.2 */

    const { console: console_1$o } = globals;
    const file$10 = "srcListening\\Dictionary\\DefiDS.svelte";

    function get_each_context$l(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (126:38) 
    function create_if_block_7$1(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#c780e8");
    			add_location(div, file$10, 126, 4, 3774);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(126:38) ",
    		ctx
    	});

    	return block;
    }

    // (124:43) 
    function create_if_block_6$2(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#9d94ff");
    			add_location(div, file$10, 124, 4, 3647);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(124:43) ",
    		ctx
    	});

    	return block;
    }

    // (122:42) 
    function create_if_block_5$2(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#59adf6");
    			add_location(div, file$10, 122, 4, 3515);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(122:42) ",
    		ctx
    	});

    	return block;
    }

    // (120:42) 
    function create_if_block_4$3(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#08cad1");
    			add_location(div, file$10, 120, 4, 3384);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(120:42) ",
    		ctx
    	});

    	return block;
    }

    // (118:37) 
    function create_if_block_3$3(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#42d6a4");
    			add_location(div, file$10, 118, 4, 3253);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(118:37) ",
    		ctx
    	});

    	return block;
    }

    // (116:40) 
    function create_if_block_2$7(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#f8f38d");
    			add_location(div, file$10, 116, 4, 3127);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(116:40) ",
    		ctx
    	});

    	return block;
    }

    // (114:35) 
    function create_if_block_1$b(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#ffb480");
    			add_location(div, file$10, 114, 4, 2998);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(114:35) ",
    		ctx
    	});

    	return block;
    }

    // (112:4) {#if types.type== 'noun'}
    function create_if_block$o(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#ff6961");
    			add_location(div, file$10, 112, 4, 2874);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(112:4) {#if types.type== 'noun'}",
    		ctx
    	});

    	return block;
    }

    // (129:4) {#each types.deex as defiexam}
    function create_each_block_1$2(ctx) {
    	let div2;
    	let button;
    	let t1;
    	let div0;
    	let t2_value = /*defiexam*/ ctx[7].defi + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4_value = /*defiexam*/ ctx[7].exam + "";
    	let t4;
    	let t5;
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*defiexam*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "save";
    			t1 = space();
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(button, "class", "savevo svelte-6z1hk9");
    			add_location(button, file$10, 130, 8, 3978);
    			attr_dev(div0, "class", "DefiEng svelte-6z1hk9");
    			add_location(div0, file$10, 131, 8, 4078);
    			attr_dev(div1, "class", "ExEng svelte-6z1hk9");
    			add_location(div1, file$10, 132, 8, 4132);
    			attr_dev(div2, "class", "MeaningClass svelte-6z1hk9");
    			add_location(div2, file$10, 129, 4, 3908);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, t4);
    			append_dev(div2, t5);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*fetchValue*/ 2) && t2_value !== (t2_value = /*defiexam*/ ctx[7].defi + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*fetchValue*/ 2) && t4_value !== (t4_value = /*defiexam*/ ctx[7].exam + "")) set_data_dev(t4, t4_value);
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, blur, { duration: 500 }, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, blur, { duration: 500 }, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(129:4) {#each types.deex as defiexam}",
    		ctx
    	});

    	return block;
    }

    // (111:2) {#each fetchValue.board as types}
    function create_each_block$l(ctx) {
    	let t;
    	let each_1_anchor;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*types*/ ctx[4].type == 'noun') return create_if_block$o;
    		if (/*types*/ ctx[4].type == 'verb') return create_if_block_1$b;
    		if (/*types*/ ctx[4].type == 'adjective') return create_if_block_2$7;
    		if (/*types*/ ctx[4].type == 'adverb') return create_if_block_3$3;
    		if (/*types*/ ctx[4].type == 'preposition') return create_if_block_4$3;
    		if (/*types*/ ctx[4].type == 'conjunction') return create_if_block_5$2;
    		if (/*types*/ ctx[4].type == 'interjection') return create_if_block_6$2;
    		if (/*types*/ ctx[4].type == 'pronoun') return create_if_block_7$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);
    	let each_value_1 = /*types*/ ctx[4].deex;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			}

    			if (dirty & /*fetchValue, Saving, $enterText*/ 6) {
    				each_value_1 = /*types*/ ctx[4].deex;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$l.name,
    		type: "each",
    		source: "(111:2) {#each fetchValue.board as types}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$13(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let div2_style_value;
    	let current;
    	let each_value = /*fetchValue*/ ctx[1].board;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*$enterText*/ ctx[2]);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "word");
    			attr_dev(div0, "class", "svelte-6z1hk9");
    			add_location(div0, file$10, 106, 4, 2746);
    			attr_dev(div1, "id", "containerWord");
    			attr_dev(div1, "class", "svelte-6z1hk9");
    			add_location(div1, file$10, 105, 2, 2714);
    			attr_dev(div2, "class", "containerPath svelte-6z1hk9");
    			attr_dev(div2, "style", div2_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div2, file$10, 104, 0, 2650);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div2, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$enterText*/ 4) set_data_dev(t0, /*$enterText*/ ctx[2]);

    			if (dirty & /*fetchValue, Saving, $enterText*/ 6) {
    				each_value = /*fetchValue*/ ctx[1].board;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$l(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$l(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*zIndex*/ 1 && div2_style_value !== (div2_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div2, "style", div2_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$13.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Saving$2(definition, words) {
    	let vocData = JSON.parse(localStorage.getItem('vocabulary'));
    	let date = `${new Date().getUTCDate()} - ${new Date().getUTCMonth() + 1} - ${new Date().getUTCFullYear()}`;

    	if (vocData.length === 0 || vocData[0].day !== date) {
    		let newDay = {};
    		newDay["day"] = date;
    		newDay["content"] = [];
    		vocData.unshift(newDay);
    	}

    	let con = {};
    	con["word"] = words;
    	con["definition"] = definition;
    	vocData[0].content.push(con);
    	localStorage.setItem('vocabulary', JSON.stringify(vocData));
    }

    function instance$13($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText$1, 'enterText');
    	component_subscribe($$self, enterText$1, $$value => $$invalidate(2, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DefiDS', slots, []);
    	let zIndex = 0;

    	stepDS$1.subscribe(value => {
    		if (value == 'defi') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let fetchValue = { "word": "", "pronon": "", "board": [] };

    	//API DÈINITION
    	onMount(() => {
    		let huptext = $enterText;
    		var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + `${huptext}`;
    		let contaiFile;

    		fetch(link).then(res => res.json()).then(result => {
    			result.map(run1);

    			function run1(resultNew) {
    				$$invalidate(1, fetchValue.word = resultNew.word, fetchValue);
    				$$invalidate(1, fetchValue.pronon = resultNew.phonetic, fetchValue);
    				resultNew.meanings.map(run2);

    				//phonetic vs word here
    				console.log(fetchValue);
    			}

    			function run2(meaningsNew) {
    				contaiFile = { "type": "", "deex": [] };
    				contaiFile.type = meaningsNew.partOfSpeech;
    				meaningsNew.definitions.map(run3);
    				console.log(contaiFile, "finishedrun2");
    				fetchValue.board.push(contaiFile);
    			}

    			function run3(definitionsNew) {
    				console.log(definitionsNew.definition + "run3");
    				let deSam = { "defi": "", "exam": "" };
    				deSam.defi = definitionsNew.definition;

    				if (definitionsNew.example != undefined) {
    					deSam.exam = "Ex: " + definitionsNew.example;
    				} else {
    					deSam.exam = '';
    				}

    				contaiFile.deex.push(deSam);
    			}
    		}).catch(error => {
    			document.write(error);
    		}).finally(() => {
    			
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$o.warn(`<DefiDS> was created with unknown prop '${key}'`);
    	});

    	const click_handler = defiexam => {
    		Saving$2(defiexam.defi, $enterText);
    	};

    	$$self.$capture_state = () => ({
    		blur,
    		enterText: enterText$1,
    		stepDS: stepDS$1,
    		onMount,
    		zIndex,
    		fetchValue,
    		Saving: Saving$2,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('fetchValue' in $$props) $$invalidate(1, fetchValue = $$props.fetchValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, fetchValue, $enterText, click_handler];
    }

    let DefiDS$1 = class DefiDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$13, create_fragment$13, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DefiDS",
    			options,
    			id: create_fragment$13.name
    		});
    	}
    };

    /* srcListening\Dictionary\SynDS.svelte generated by Svelte v3.59.2 */
    const file$$ = "srcListening\\Dictionary\\SynDS.svelte";

    function get_each_context$k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$n(ctx) {
    	let each_1_anchor;
    	let each_value = /*synonymsList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*synonymsList*/ 4) {
    				each_value = /*synonymsList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$k(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$k(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each synonymsList as Syn}
    function create_each_block$k(ctx) {
    	let div;
    	let t_value = /*Syn*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "SynWord svelte-pln53j");
    			add_location(div, file$$, 37, 8, 990);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*synonymsList*/ 4 && t_value !== (t_value = /*Syn*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$k.name,
    		type: "each",
    		source: "(37:8) {#each synonymsList as Syn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$12(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containerSyn svelte-pln53j");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$$, 34, 4, 855);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$n(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$12.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText$1, 'enterText');
    	component_subscribe($$self, enterText$1, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SynDS', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDS$1.subscribe(value => {
    		if (value == 'syn') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let synonymsList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlsyn = "https://api.datamuse.com/words?rel_syn=" + huptext;

    		fetch(urlsyn).then(res => res.json()).then(result => {
    			$$invalidate(2, synonymsList = []);
    			result.map(createSyn);
    			$$invalidate(1, loaded = true);

    			function createSyn(Syn) {
    				synonymsList.push(Syn.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SynDS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS: stepDS$1,
    		enterText: enterText$1,
    		onMount,
    		zIndex,
    		loaded,
    		synonymsList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('synonymsList' in $$props) $$invalidate(2, synonymsList = $$props.synonymsList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, synonymsList];
    }

    let SynDS$1 = class SynDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$12, create_fragment$12, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SynDS",
    			options,
    			id: create_fragment$12.name
    		});
    	}
    };

    /* srcListening\Dictionary\AntDS.svelte generated by Svelte v3.59.2 */
    const file$_ = "srcListening\\Dictionary\\AntDS.svelte";

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$m(ctx) {
    	let each_1_anchor;
    	let each_value = /*antonymsList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*antonymsList*/ 4) {
    				each_value = /*antonymsList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$j(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each antonymsList as Ant}
    function create_each_block$j(ctx) {
    	let div;
    	let t_value = /*Ant*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "AntWord svelte-uizxxh");
    			add_location(div, file$_, 37, 8, 975);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*antonymsList*/ 4 && t_value !== (t_value = /*Ant*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$j.name,
    		type: "each",
    		source: "(37:8) {#each antonymsList as Ant}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$11(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containerAnt svelte-uizxxh");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$_, 34, 4, 840);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$m(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$11.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText$1, 'enterText');
    	component_subscribe($$self, enterText$1, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AntDS', slots, []);
    	let zIndex = 0;
    	let loaded;

    	stepDS$1.subscribe(value => {
    		if (value == 'ant') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let antonymsList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlant = "https://api.datamuse.com/words?rel_ant=" + huptext;

    		fetch(urlant).then(res => res.json()).then(result => {
    			$$invalidate(2, antonymsList = []);
    			result.map(createAnt);
    			$$invalidate(1, loaded = true);

    			function createAnt(Ant) {
    				antonymsList.push(Ant.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AntDS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS: stepDS$1,
    		enterText: enterText$1,
    		onMount,
    		zIndex,
    		loaded,
    		antonymsList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('antonymsList' in $$props) $$invalidate(2, antonymsList = $$props.antonymsList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, antonymsList];
    }

    let AntDS$1 = class AntDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$11, create_fragment$11, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AntDS",
    			options,
    			id: create_fragment$11.name
    		});
    	}
    };

    /* srcListening\Dictionary\CoADS.svelte generated by Svelte v3.59.2 */
    const file$Z = "srcListening\\Dictionary\\CoADS.svelte";

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$l(ctx) {
    	let each_1_anchor;
    	let each_value = /*coAList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coAList, $enterText*/ 12) {
    				each_value = /*coAList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$i(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$i(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each coAList as coA}
    function create_each_block$i(ctx) {
    	let div;
    	let t_value = /*coA*/ ctx[4] + " " + /*$enterText*/ ctx[3] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "coAWord svelte-1uk4o7l");
    			add_location(div, file$Z, 37, 8, 970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coAList, $enterText*/ 12 && t_value !== (t_value = /*coA*/ ctx[4] + " " + /*$enterText*/ ctx[3] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$i.name,
    		type: "each",
    		source: "(37:8) {#each coAList as coA}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$10(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containercoA svelte-1uk4o7l");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$Z, 34, 4, 840);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$10.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText$1, 'enterText');
    	component_subscribe($$self, enterText$1, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CoADS', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDS$1.subscribe(value => {
    		if (value == 'coA') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let coAList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlcoA = "https://api.datamuse.com/words?rel_jjb=" + huptext;

    		fetch(urlcoA).then(res => res.json()).then(result => {
    			$$invalidate(2, coAList = []);
    			result.map(createcoA);
    			$$invalidate(1, loaded = true);

    			function createcoA(coA) {
    				coAList.push(coA.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CoADS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS: stepDS$1,
    		enterText: enterText$1,
    		onMount,
    		zIndex,
    		loaded,
    		coAList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('coAList' in $$props) $$invalidate(2, coAList = $$props.coAList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, coAList, $enterText];
    }

    let CoADS$1 = class CoADS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$10, create_fragment$10, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CoADS",
    			options,
    			id: create_fragment$10.name
    		});
    	}
    };

    /* srcListening\Dictionary\CoNDS.svelte generated by Svelte v3.59.2 */
    const file$Y = "srcListening\\Dictionary\\CoNDS.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$k(ctx) {
    	let each_1_anchor;
    	let each_value = /*coNList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$enterText, coNList*/ 12) {
    				each_value = /*coNList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each coNList as coN}
    function create_each_block$h(ctx) {
    	let div;
    	let t_value = /*$enterText*/ ctx[3] + " " + /*coN*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "coNWord svelte-j0axn7");
    			add_location(div, file$Y, 37, 8, 970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$enterText, coNList*/ 12 && t_value !== (t_value = /*$enterText*/ ctx[3] + " " + /*coN*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(37:8) {#each coNList as coN}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$$(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containercoN svelte-j0axn7");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$Y, 34, 4, 840);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$k(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$$.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText$1, 'enterText');
    	component_subscribe($$self, enterText$1, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CoNDS', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDS$1.subscribe(value => {
    		if (value == 'coN') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let coNList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlcoN = "https://api.datamuse.com/words?rel_jja=" + huptext;

    		fetch(urlcoN).then(res => res.json()).then(result => {
    			$$invalidate(2, coNList = []);
    			result.map(createcoN);
    			$$invalidate(1, loaded = true);

    			function createcoN(coN) {
    				coNList.push(coN.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CoNDS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS: stepDS$1,
    		enterText: enterText$1,
    		onMount,
    		zIndex,
    		loaded,
    		coNList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('coNList' in $$props) $$invalidate(2, coNList = $$props.coNList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, coNList, $enterText];
    }

    let CoNDS$1 = class CoNDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$$, create_fragment$$, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CoNDS",
    			options,
    			id: create_fragment$$.name
    		});
    	}
    };

    /* srcListening\Dictionary\NoResult.svelte generated by Svelte v3.59.2 */
    const file$X = "srcListening\\Dictionary\\NoResult.svelte";

    function create_fragment$_(ctx) {
    	let div;
    	let div_transition;
    	let current;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Opp!! No data found.";
    			attr_dev(div, "id", "noresult");
    			attr_dev(div, "class", "svelte-1qc71ks");
    			add_location(div, file$X, 3, 0, 65);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$_.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NoResult', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NoResult> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ slide });
    	return [];
    }

    let NoResult$1 = class NoResult extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$_, create_fragment$_, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NoResult",
    			options,
    			id: create_fragment$_.name
    		});
    	}
    };

    /* srcListening\Dictionary\Dictionary.svelte generated by Svelte v3.59.2 */
    const file$W = "srcListening\\Dictionary\\Dictionary.svelte";

    // (48:8) {#if search}
    function create_if_block$j(ctx) {
    	let previous_key = /*$enterText*/ ctx[2];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$3(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$enterText*/ 4 && safe_not_equal(previous_key, previous_key = /*$enterText*/ ctx[2])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$3(ctx);
    				key_block.c();
    				transition_in(key_block, 1);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(48:8) {#if search}",
    		ctx
    	});

    	return block;
    }

    // (60:41) 
    function create_if_block_2$6(ctx) {
    	let noresult;
    	let current;
    	noresult = new NoResult$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(noresult.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(noresult, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(noresult.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(noresult.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(noresult, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(60:41) ",
    		ctx
    	});

    	return block;
    }

    // (50:12) {#if haveornot == true}
    function create_if_block_1$a(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let boarddic;
    	let t1;
    	let defids;
    	let t2;
    	let synds;
    	let t3;
    	let antds;
    	let t4;
    	let coads;
    	let t5;
    	let conds;
    	let div1_transition;
    	let current;
    	boarddic = new BoardDic$1({ $$inline: true });
    	defids = new DefiDS$1({ $$inline: true });
    	synds = new SynDS$1({ $$inline: true });
    	antds = new AntDS$1({ $$inline: true });
    	coads = new CoADS$1({ $$inline: true });
    	conds = new CoNDS$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			create_component(boarddic.$$.fragment);
    			t1 = space();
    			create_component(defids.$$.fragment);
    			t2 = space();
    			create_component(synds.$$.fragment);
    			t3 = space();
    			create_component(antds.$$.fragment);
    			t4 = space();
    			create_component(coads.$$.fragment);
    			t5 = space();
    			create_component(conds.$$.fragment);
    			attr_dev(div0, "id", "behindblur");
    			attr_dev(div0, "class", "svelte-mm8umt");
    			add_location(div0, file$W, 51, 16, 1546);
    			attr_dev(div1, "id", "contInnerDic");
    			attr_dev(div1, "class", "svelte-mm8umt");
    			add_location(div1, file$W, 50, 16, 1470);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t0);
    			mount_component(boarddic, div1, null);
    			append_dev(div1, t1);
    			mount_component(defids, div1, null);
    			append_dev(div1, t2);
    			mount_component(synds, div1, null);
    			append_dev(div1, t3);
    			mount_component(antds, div1, null);
    			append_dev(div1, t4);
    			mount_component(coads, div1, null);
    			append_dev(div1, t5);
    			mount_component(conds, div1, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(boarddic.$$.fragment, local);
    			transition_in(defids.$$.fragment, local);
    			transition_in(synds.$$.fragment, local);
    			transition_in(antds.$$.fragment, local);
    			transition_in(coads.$$.fragment, local);
    			transition_in(conds.$$.fragment, local);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 500 }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(boarddic.$$.fragment, local);
    			transition_out(defids.$$.fragment, local);
    			transition_out(synds.$$.fragment, local);
    			transition_out(antds.$$.fragment, local);
    			transition_out(coads.$$.fragment, local);
    			transition_out(conds.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 500 }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(boarddic);
    			destroy_component(defids);
    			destroy_component(synds);
    			destroy_component(antds);
    			destroy_component(coads);
    			destroy_component(conds);
    			if (detaching && div1_transition) div1_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(50:12) {#if haveornot == true}",
    		ctx
    	});

    	return block;
    }

    // (49:8) {#key $enterText}
    function create_key_block$3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$a, create_if_block_2$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*haveornot*/ ctx[1] == true) return 0;
    		if (/*haveornot*/ ctx[1] == false) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$3.name,
    		type: "key",
    		source: "(49:8) {#key $enterText}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Z(ctx) {
    	let button0;
    	let t0;
    	let div2;
    	let div0;
    	let input;
    	let t1;
    	let button1;
    	let t3;
    	let div1;
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*search*/ ctx[0] && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = ">>";
    			t3 = space();
    			div1 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(button0, "id", "backgroundexit");
    			attr_dev(button0, "class", "svelte-mm8umt");
    			add_location(button0, file$W, 38, 0, 1037);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", "enterWord");
    			attr_dev(input, "autocomplete", "off");
    			attr_dev(input, "class", "svelte-mm8umt");
    			add_location(input, file$W, 42, 4, 1205);
    			attr_dev(button1, "id", "SearchDic");
    			attr_dev(button1, "class", "svelte-mm8umt");
    			add_location(button1, file$W, 43, 4, 1266);
    			attr_dev(div0, "id", "containSearch");
    			attr_dev(div0, "class", "svelte-mm8umt");
    			add_location(div0, file$W, 41, 4, 1174);
    			attr_dev(div1, "id", "containerDic");
    			attr_dev(div1, "class", "svelte-mm8umt");
    			add_location(div1, file$W, 46, 4, 1342);
    			attr_dev(div2, "id", "containerDictionary");
    			attr_dev(div2, "class", "svelte-mm8umt");
    			add_location(div2, file$W, 39, 0, 1096);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, input);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*Exit*/ ctx[4], false, false, false, false),
    					listen_dev(button1, "click", /*change*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*search*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*search*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$j(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 500 }, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 500 }, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
    	let $dictionaryDS;
    	let $enterText;
    	let $stepDS;
    	validate_store(dictionaryDS$1, 'dictionaryDS');
    	component_subscribe($$self, dictionaryDS$1, $$value => $$invalidate(5, $dictionaryDS = $$value));
    	validate_store(enterText$1, 'enterText');
    	component_subscribe($$self, enterText$1, $$value => $$invalidate(2, $enterText = $$value));
    	validate_store(stepDS$1, 'stepDS');
    	component_subscribe($$self, stepDS$1, $$value => $$invalidate(6, $stepDS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dictionary', slots, []);
    	let search = false;
    	let haveornot = 'no';

    	function change() {
    		set_store_value(stepDS$1, $stepDS = 'defi', $stepDS);
    		$$invalidate(0, search = true);
    		let text = document.getElementById('enterWord').value;
    		var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + `${text}`;

    		fetch(link).then(res => {
    			if (res.ok) {
    				$$invalidate(1, haveornot = true);
    				set_store_value(enterText$1, $enterText = text, $enterText);
    			} else {
    				$$invalidate(1, haveornot = false);
    			}
    		});
    	}

    	function Exit() {
    		set_store_value(dictionaryDS$1, $dictionaryDS = false, $dictionaryDS);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dictionary> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		dictionaryDS: dictionaryDS$1,
    		enterText: enterText$1,
    		stepDS: stepDS$1,
    		BoardDic: BoardDic$1,
    		DefiDs: DefiDS$1,
    		SynDs: SynDS$1,
    		AntDs: AntDS$1,
    		CoAds: CoADS$1,
    		CoNds: CoNDS$1,
    		NoResult: NoResult$1,
    		slide,
    		search,
    		haveornot,
    		change,
    		Exit,
    		$dictionaryDS,
    		$enterText,
    		$stepDS
    	});

    	$$self.$inject_state = $$props => {
    		if ('search' in $$props) $$invalidate(0, search = $$props.search);
    		if ('haveornot' in $$props) $$invalidate(1, haveornot = $$props.haveornot);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [search, haveornot, $enterText, change, Exit];
    }

    let Dictionary$1 = class Dictionary extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dictionary",
    			options,
    			id: create_fragment$Z.name
    		});
    	}
    };

    /* srcListening\EditBoard\EditBoard.svelte generated by Svelte v3.59.2 */
    const file$V = "srcListening\\EditBoard\\EditBoard.svelte";

    function create_fragment$Y(ctx) {
    	let div0;
    	let t0;
    	let div1;
    	let textarea;
    	let t1;
    	let button;
    	let div1_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			div1 = element("div");
    			textarea = element("textarea");
    			t1 = space();
    			button = element("button");
    			button.textContent = "Done";
    			attr_dev(div0, "id", "containBlack");
    			attr_dev(div0, "class", "svelte-1ejzvae");
    			add_location(div0, file$V, 14, 0, 513);
    			attr_dev(textarea, "id", "TextEdit");
    			attr_dev(textarea, "spellcheck", "false");
    			attr_dev(textarea, "class", "svelte-1ejzvae");
    			add_location(textarea, file$V, 16, 4, 612);
    			attr_dev(button, "id", "finish");
    			attr_dev(button, "class", "svelte-1ejzvae");
    			add_location(button, file$V, 17, 4, 674);
    			attr_dev(div1, "id", "containerEdit");
    			attr_dev(div1, "class", "svelte-1ejzvae");
    			add_location(div1, file$V, 15, 0, 546);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div1, anchor);
    			append_dev(div1, textarea);
    			append_dev(div1, t1);
    			append_dev(div1, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Finish*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 300 }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 300 }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div1);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
    	let $ongoingText;
    	let $editBoard;
    	validate_store(ongoingText, 'ongoingText');
    	component_subscribe($$self, ongoingText, $$value => $$invalidate(1, $ongoingText = $$value));
    	validate_store(editBoard, 'editBoard');
    	component_subscribe($$self, editBoard, $$value => $$invalidate(2, $editBoard = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EditBoard', slots, []);

    	onMount(() => {
    		document.getElementById('TextEdit').value = document.getElementById('textarea').value;
    	});

    	function Finish() {
    		set_store_value(editBoard, $editBoard = false, $editBoard);
    		set_store_value(ongoingText, $ongoingText = document.getElementById('TextEdit').value, $ongoingText);
    		document.getElementById('textarea').value = document.getElementById('TextEdit').value;
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EditBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		slide,
    		editBoard,
    		ongoingText,
    		Finish,
    		$ongoingText,
    		$editBoard
    	});

    	return [Finish];
    }

    class EditBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EditBoard",
    			options,
    			id: create_fragment$Y.name
    		});
    	}
    }

    /* srcListening\TaskBoard\FinalAns.svelte generated by Svelte v3.59.2 */

    const file$U = "srcListening\\TaskBoard\\FinalAns.svelte";

    function create_fragment$X(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*finalcontent*/ ctx[0]);
    			attr_dev(div, "class", "finalanswer svelte-1gyscqb");
    			set_style(div, "color", /*color*/ ctx[1]);
    			add_location(div, file$U, 4, 0, 72);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*finalcontent*/ 1) set_data_dev(t, /*finalcontent*/ ctx[0]);

    			if (dirty & /*color*/ 2) {
    				set_style(div, "color", /*color*/ ctx[1]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$X.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FinalAns', slots, []);
    	let { finalcontent } = $$props;
    	let { color } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (finalcontent === undefined && !('finalcontent' in $$props || $$self.$$.bound[$$self.$$.props['finalcontent']])) {
    			console.warn("<FinalAns> was created without expected prop 'finalcontent'");
    		}

    		if (color === undefined && !('color' in $$props || $$self.$$.bound[$$self.$$.props['color']])) {
    			console.warn("<FinalAns> was created without expected prop 'color'");
    		}
    	});

    	const writable_props = ['finalcontent', 'color'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FinalAns> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('finalcontent' in $$props) $$invalidate(0, finalcontent = $$props.finalcontent);
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    	};

    	$$self.$capture_state = () => ({ finalcontent, color });

    	$$self.$inject_state = $$props => {
    		if ('finalcontent' in $$props) $$invalidate(0, finalcontent = $$props.finalcontent);
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [finalcontent, color];
    }

    class FinalAns extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$X, create_fragment$X, safe_not_equal, { finalcontent: 0, color: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FinalAns",
    			options,
    			id: create_fragment$X.name
    		});
    	}

    	get finalcontent() {
    		throw new Error("<FinalAns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set finalcontent(value) {
    		throw new Error("<FinalAns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get color() {
    		throw new Error("<FinalAns>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set color(value) {
    		throw new Error("<FinalAns>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcListening\TaskBoard\AnswerForm.svelte generated by Svelte v3.59.2 */
    const file$T = "srcListening\\TaskBoard\\AnswerForm.svelte";

    // (12:0) {#if $finalanswerTF }
    function create_if_block$i(ctx) {
    	let finalans;
    	let current;

    	finalans = new FinalAns({
    			props: {
    				finalcontent: /*content*/ ctx[0],
    				color: /*$testAns*/ ctx[3][/*sort*/ ctx[1] - 1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(finalans.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(finalans, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const finalans_changes = {};
    			if (dirty & /*content*/ 1) finalans_changes.finalcontent = /*content*/ ctx[0];
    			if (dirty & /*$testAns, sort*/ 10) finalans_changes.color = /*$testAns*/ ctx[3][/*sort*/ ctx[1] - 1];
    			finalans.$set(finalans_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(finalans.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(finalans.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(finalans, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(12:0) {#if $finalanswerTF }",
    		ctx
    	});

    	return block;
    }

    function create_fragment$W(ctx) {
    	let div1;
    	let div0;
    	let p;
    	let t0;
    	let t1;
    	let input;
    	let t2;
    	let current;
    	let if_block = /*$finalanswerTF*/ ctx[2] && create_if_block$i(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			p = element("p");
    			t0 = text(/*sort*/ ctx[1]);
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			if (if_block) if_block.c();
    			attr_dev(p, "class", "svelte-9cuda5");
    			add_location(p, file$T, 8, 0, 215);
    			attr_dev(input, "class", "answer svelte-9cuda5");
    			add_location(input, file$T, 9, 0, 230);
    			attr_dev(div0, "class", "topic svelte-9cuda5");
    			add_location(div0, file$T, 7, 0, 192);
    			attr_dev(div1, "class", "answerCon svelte-9cuda5");
    			add_location(div1, file$T, 6, 0, 166);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, p);
    			append_dev(p, t0);
    			append_dev(div0, t1);
    			append_dev(div0, input);
    			append_dev(div1, t2);
    			if (if_block) if_block.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*sort*/ 2) set_data_dev(t0, /*sort*/ ctx[1]);

    			if (/*$finalanswerTF*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$finalanswerTF*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$i(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$W.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
    	let $finalanswerTF;
    	let $testAns;
    	validate_store(finalanswerTF, 'finalanswerTF');
    	component_subscribe($$self, finalanswerTF, $$value => $$invalidate(2, $finalanswerTF = $$value));
    	validate_store(testAns, 'testAns');
    	component_subscribe($$self, testAns, $$value => $$invalidate(3, $testAns = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AnswerForm', slots, []);
    	let { content } = $$props;
    	let { sort } = $$props;

    	$$self.$$.on_mount.push(function () {
    		if (content === undefined && !('content' in $$props || $$self.$$.bound[$$self.$$.props['content']])) {
    			console.warn("<AnswerForm> was created without expected prop 'content'");
    		}

    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console.warn("<AnswerForm> was created without expected prop 'sort'");
    		}
    	});

    	const writable_props = ['content', 'sort'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AnswerForm> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('content' in $$props) $$invalidate(0, content = $$props.content);
    		if ('sort' in $$props) $$invalidate(1, sort = $$props.sort);
    	};

    	$$self.$capture_state = () => ({
    		content,
    		sort,
    		finalanswerTF,
    		testAns,
    		FinalAns,
    		$finalanswerTF,
    		$testAns
    	});

    	$$self.$inject_state = $$props => {
    		if ('content' in $$props) $$invalidate(0, content = $$props.content);
    		if ('sort' in $$props) $$invalidate(1, sort = $$props.sort);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [content, sort, $finalanswerTF, $testAns];
    }

    class AnswerForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$W, create_fragment$W, safe_not_equal, { content: 0, sort: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AnswerForm",
    			options,
    			id: create_fragment$W.name
    		});
    	}

    	get content() {
    		throw new Error("<AnswerForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<AnswerForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sort() {
    		throw new Error("<AnswerForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<AnswerForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcListening\TaskBoard\AnswerSheet.svelte generated by Svelte v3.59.2 */

    const { console: console_1$n } = globals;
    const file$S = "srcListening\\TaskBoard\\AnswerSheet.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	child_ctx[6] = i;
    	return child_ctx;
    }

    // (34:7) {#if $result.length-1==i}
    function create_if_block$h(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "check";
    			attr_dev(button, "id", "check");
    			attr_dev(button, "class", "svelte-u8qzec");
    			add_location(button, file$S, 34, 8, 923);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Check*/ ctx[1], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(34:7) {#if $result.length-1==i}",
    		ctx
    	});

    	return block;
    }

    // (31:4) {#each $result as res,i}
    function create_each_block$g(ctx) {
    	let answerform;
    	let t;
    	let if_block_anchor;
    	let current;

    	answerform = new AnswerForm({
    			props: {
    				content: /*res*/ ctx[4],
    				sort: /*i*/ ctx[6] + 1
    			},
    			$$inline: true
    		});

    	let if_block = /*$result*/ ctx[0].length - 1 == /*i*/ ctx[6] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			create_component(answerform.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(answerform, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const answerform_changes = {};
    			if (dirty & /*$result*/ 1) answerform_changes.content = /*res*/ ctx[4];
    			answerform.$set(answerform_changes);

    			if (/*$result*/ ctx[0].length - 1 == /*i*/ ctx[6]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(answerform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(answerform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(answerform, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(31:4) {#each $result as res,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$V(ctx) {
    	let div;
    	let current;
    	let each_value = /*$result*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$g(get_each_context$g(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "id", "answersheet");
    			attr_dev(div, "class", "svelte-u8qzec");
    			add_location(div, file$S, 29, 0, 764);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*Check, $result*/ 3) {
    				each_value = /*$result*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$g(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$g(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$V.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
    	let $testAns;
    	let $finalanswerTF;
    	let $result;
    	validate_store(testAns, 'testAns');
    	component_subscribe($$self, testAns, $$value => $$invalidate(2, $testAns = $$value));
    	validate_store(finalanswerTF, 'finalanswerTF');
    	component_subscribe($$self, finalanswerTF, $$value => $$invalidate(3, $finalanswerTF = $$value));
    	validate_store(result, 'result');
    	component_subscribe($$self, result, $$value => $$invalidate(0, $result = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AnswerSheet', slots, []);

    	function Check() {
    		testAns.update(value => {
    			return [];
    		});

    		var ui = document.getElementsByClassName('answer');
    		Array.from(ui).forEach(test);

    		function test(element, index) {
    			console.log(element.value);

    			if ($result[index] == element.value) {
    				testAns.update(value => {
    					return [...value, "#08f26e"];
    				});
    			} else {
    				testAns.update(value => {
    					return [...value, "#ff0033"];
    				});
    			}
    		}

    		set_store_value(finalanswerTF, $finalanswerTF = true, $finalanswerTF);
    		console.log($testAns);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$n.warn(`<AnswerSheet> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		finalanswerTF,
    		result,
    		testAns,
    		AnswerForm,
    		Check,
    		$testAns,
    		$finalanswerTF,
    		$result
    	});

    	return [$result, Check];
    }

    class AnswerSheet extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$V, create_fragment$V, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AnswerSheet",
    			options,
    			id: create_fragment$V.name
    		});
    	}
    }

    /* srcListening\ConListening.svelte generated by Svelte v3.59.2 */
    const file$R = "srcListening\\ConListening.svelte";

    // (24:4) {#if $dictionaryDS}
    function create_if_block_1$9(ctx) {
    	let dictionary;
    	let current;
    	dictionary = new Dictionary$1({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dictionary.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dictionary, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dictionary.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dictionary.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dictionary, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(24:4) {#if $dictionaryDS}",
    		ctx
    	});

    	return block;
    }

    // (28:4) {#if $editBoard}
    function create_if_block$g(ctx) {
    	let editboard;
    	let current;
    	editboard = new EditBoard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(editboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(editboard, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(editboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(editboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(editboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(28:4) {#if $editBoard}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$U(ctx) {
    	let div0;
    	let img;
    	let img_src_value;
    	let t0;
    	let taskbar;
    	let t1;
    	let div2;
    	let taskboard;
    	let t2;
    	let textarea;
    	let t3;
    	let div1;
    	let answersheet;
    	let t4;
    	let t5;
    	let if_block1_anchor;
    	let current;
    	taskbar = new Taskbar$1({ $$inline: true });
    	taskboard = new Taskboard({ $$inline: true });
    	textarea = new Textarea({ $$inline: true });
    	answersheet = new AnswerSheet({ $$inline: true });
    	let if_block0 = /*$dictionaryDS*/ ctx[0] && create_if_block_1$9(ctx);
    	let if_block1 = /*$editBoard*/ ctx[1] && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			img = element("img");
    			t0 = space();
    			create_component(taskbar.$$.fragment);
    			t1 = space();
    			div2 = element("div");
    			create_component(taskboard.$$.fragment);
    			t2 = space();
    			create_component(textarea.$$.fragment);
    			t3 = space();
    			div1 = element("div");
    			create_component(answersheet.$$.fragment);
    			t4 = space();
    			if (if_block0) if_block0.c();
    			t5 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			if (!src_url_equal(img.src, img_src_value = "../images/withoutunderwhite.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "id", "logo");
    			attr_dev(img, "class", "svelte-10yhnqw");
    			add_location(img, file$R, 10, 8, 478);
    			attr_dev(div0, "id", "taskbar");
    			attr_dev(div0, "class", "svelte-10yhnqw");
    			add_location(div0, file$R, 9, 4, 447);
    			attr_dev(div1, "id", "contaitask");
    			attr_dev(div1, "class", "svelte-10yhnqw");
    			add_location(div1, file$R, 17, 4, 663);
    			attr_dev(div2, "id", "conLis");
    			attr_dev(div2, "class", "svelte-10yhnqw");
    			add_location(div2, file$R, 14, 4, 599);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, img);
    			append_dev(div0, t0);
    			mount_component(taskbar, div0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, div2, anchor);
    			mount_component(taskboard, div2, null);
    			append_dev(div2, t2);
    			mount_component(textarea, div2, null);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			mount_component(answersheet, div1, null);
    			insert_dev(target, t4, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t5, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$dictionaryDS*/ ctx[0]) {
    				if (if_block0) {
    					if (dirty & /*$dictionaryDS*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$9(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t5.parentNode, t5);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$editBoard*/ ctx[1]) {
    				if (if_block1) {
    					if (dirty & /*$editBoard*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$g(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(taskbar.$$.fragment, local);
    			transition_in(taskboard.$$.fragment, local);
    			transition_in(textarea.$$.fragment, local);
    			transition_in(answersheet.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(taskbar.$$.fragment, local);
    			transition_out(taskboard.$$.fragment, local);
    			transition_out(textarea.$$.fragment, local);
    			transition_out(answersheet.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			destroy_component(taskbar);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(div2);
    			destroy_component(taskboard);
    			destroy_component(textarea);
    			destroy_component(answersheet);
    			if (detaching) detach_dev(t4);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t5);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$U.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
    	let $dictionaryDS;
    	let $editBoard;
    	validate_store(dictionaryDS$1, 'dictionaryDS');
    	component_subscribe($$self, dictionaryDS$1, $$value => $$invalidate(0, $dictionaryDS = $$value));
    	validate_store(editBoard, 'editBoard');
    	component_subscribe($$self, editBoard, $$value => $$invalidate(1, $editBoard = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ConListening', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ConListening> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Taskbar: Taskbar$1,
    		Taskboard,
    		Textarea,
    		Dictionary: Dictionary$1,
    		dictionaryDS: dictionaryDS$1,
    		editBoard,
    		EditBoard,
    		AnswerSheet,
    		$dictionaryDS,
    		$editBoard
    	});

    	return [$dictionaryDS, $editBoard];
    }

    class ConListening extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$U, create_fragment$U, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ConListening",
    			options,
    			id: create_fragment$U.name
    		});
    	}
    }

    /* srcListening\Listening.svelte generated by Svelte v3.59.2 */

    function create_fragment$T(ctx) {
    	let conlistening;
    	let current;
    	conlistening = new ConListening({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(conlistening.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(conlistening, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(conlistening.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(conlistening.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(conlistening, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Listening', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Listening> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ ConListening });
    	return [];
    }

    class Listening extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Listening",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    let dictionaryDS = writable(false);
    let enterText = writable('');

    let stepDS = writable('defi');

    let choice = writable('enter');

    let LisEnter = writable(["1"]);

    let resWord = writable(['']);

    let resMean = writable(['']);
    let MaxSlide = writable(false);
    let MinSlide = writable(false);
    let onSide = writable(0);


    let AnsList =  writable([]); //ddc push owr buocws onMount 


    // Keets quar cuar nguowif dungf
    let CusList =  writable([]);

    let resScore = writable();

    let reswholekey = writable([]);// ghi cả từ cả lỗi ur ans key

    let resultTF = writable();

    let choiceOpt = writable();

    let MixRes = writable();
    // vị trí phần tử thứ để truy xuát

    let suggestTF = writable(false);
    let suggestUpdate = writable(false);
    let listwordSug = writable([]);
    let formchosedNum = writable();
    let startInput = writable();
    let endInput = writable();

    /* srcReviving\wordSuggest\wordSuggestBoard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$m } = globals;
    const file$Q = "srcReviving\\wordSuggest\\wordSuggestBoard.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (13:4) {#each $listwordSug as words}
    function create_each_block$f(ctx) {
    	let button;
    	let t_value = /*words*/ ctx[6] + "";
    	let t;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[2](/*words*/ ctx[6]);
    	}

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(t_value);
    			attr_dev(button, "class", "wordsug svelte-unof0p");
    			add_location(button, file$Q, 13, 4, 562);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*$listwordSug*/ 1 && t_value !== (t_value = /*words*/ ctx[6] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(13:4) {#each $listwordSug as words}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let div;
    	let each_value = /*$listwordSug*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "id", "wordSuggestBoard");
    			attr_dev(div, "class", "svelte-unof0p");
    			add_location(div, file$Q, 11, 0, 492);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*UpdateWord, $listwordSug*/ 3) {
    				each_value = /*$listwordSug*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let $formchosedNum;
    	let $endInput;
    	let $startInput;
    	let $listwordSug;
    	validate_store(formchosedNum, 'formchosedNum');
    	component_subscribe($$self, formchosedNum, $$value => $$invalidate(3, $formchosedNum = $$value));
    	validate_store(endInput, 'endInput');
    	component_subscribe($$self, endInput, $$value => $$invalidate(4, $endInput = $$value));
    	validate_store(startInput, 'startInput');
    	component_subscribe($$self, startInput, $$value => $$invalidate(5, $startInput = $$value));
    	validate_store(listwordSug, 'listwordSug');
    	component_subscribe($$self, listwordSug, $$value => $$invalidate(0, $listwordSug = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WordSuggestBoard', slots, []);

    	function UpdateWord(sen) {
    		let value = document.getElementById(`inputForm${$formchosedNum}`).value;
    		value = value.slice(0, $startInput) + sen + value.slice($endInput, value.length - 1);
    		console.log(value);
    		document.getElementById(`inputForm${$formchosedNum}`).value = value;
    		document.getElementById(`inputForm${$formchosedNum}`).focus();
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$m.warn(`<WordSuggestBoard> was created with unknown prop '${key}'`);
    	});

    	const click_handler = words => {
    		UpdateWord(words);
    	};

    	$$self.$capture_state = () => ({
    		endInput,
    		listwordSug,
    		startInput,
    		formchosedNum,
    		UpdateWord,
    		$formchosedNum,
    		$endInput,
    		$startInput,
    		$listwordSug
    	});

    	return [$listwordSug, UpdateWord, click_handler];
    }

    class WordSuggestBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WordSuggestBoard",
    			options,
    			id: create_fragment$S.name
    		});
    	}
    }

    /* srcReviving\TaskBar\TaskChoice.svelte generated by Svelte v3.59.2 */
    const file$P = "srcReviving\\TaskBar\\TaskChoice.svelte";

    function create_fragment$R(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "return";
    			attr_dev(button, "id", "add");
    			attr_dev(button, "class", "svelte-1n8szsg");
    			add_location(button, file$P, 7, 0, 119);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Red*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let $choice;
    	validate_store(choice, 'choice');
    	component_subscribe($$self, choice, $$value => $$invalidate(1, $choice = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TaskChoice', slots, []);

    	function Red() {
    		set_store_value(choice, $choice = 'enter', $choice);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TaskChoice> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ choice, Red, $choice });
    	return [Red];
    }

    class TaskChoice extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TaskChoice",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    /* srcReviving\TaskBar\TaskEnterBoard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$l } = globals;

    const file$O = "srcReviving\\TaskBar\\TaskEnterBoard.svelte";

    function create_fragment$Q(ctx) {
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let button2;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			button0.textContent = "add";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "remove";
    			t3 = space();
    			button2 = element("button");
    			button2.textContent = "next";
    			attr_dev(button0, "id", "add");
    			attr_dev(button0, "class", "svelte-1n8szsg");
    			add_location(button0, file$O, 67, 0, 1543);
    			attr_dev(button1, "id", "remove");
    			attr_dev(button1, "class", "svelte-1n8szsg");
    			add_location(button1, file$O, 68, 0, 1592);
    			attr_dev(button2, "id", "next");
    			attr_dev(button2, "class", "svelte-1n8szsg");
    			add_location(button2, file$O, 69, 0, 1650);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button1, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, button2, anchor);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*Add*/ ctx[0], false, false, false, false),
    					listen_dev(button1, "click", /*Remove*/ ctx[1], false, false, false, false),
    					listen_dev(button2, "click", /*next*/ ctx[2], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(button2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let $reswholekey;
    	let $LisEnter;
    	let $AnsList;
    	let $choice;
    	let $resMean;
    	let $resWord;
    	validate_store(reswholekey, 'reswholekey');
    	component_subscribe($$self, reswholekey, $$value => $$invalidate(3, $reswholekey = $$value));
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(4, $LisEnter = $$value));
    	validate_store(AnsList, 'AnsList');
    	component_subscribe($$self, AnsList, $$value => $$invalidate(5, $AnsList = $$value));
    	validate_store(choice, 'choice');
    	component_subscribe($$self, choice, $$value => $$invalidate(6, $choice = $$value));
    	validate_store(resMean, 'resMean');
    	component_subscribe($$self, resMean, $$value => $$invalidate(7, $resMean = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(8, $resWord = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TaskEnterBoard', slots, []);

    	function Add() {
    		LisEnter.update(value => {
    			return [...value, `${value.length + 1}`];
    		});

    		console.log($LisEnter);

    		resMean.update(value => {
    			value.push('');
    			return value;
    		});

    		resWord.update(value => {
    			value.push('');
    			return value;
    		});
    	}

    	function Remove() {
    		LisEnter.update(value => {
    			value.pop();
    			return value;
    		});

    		resMean.update(value => {
    			value.pop();
    			return value;
    		});

    		resWord.update(value => {
    			value.pop();
    			return value;
    		});
    	}

    	function next() {
    		let uiWord = Array.from(document.getElementsByClassName('words'));
    		let uiPart = Array.from(document.getElementsByClassName('parts'));
    		let uiMean = Array.from(document.getElementsByClassName('means'));

    		uiWord.forEach((element, i) => {
    			uiWord[i] = element.value;
    		});

    		uiPart.forEach((element, i) => {
    			uiPart[i] = element.value;
    		});

    		uiMean.forEach((element, i) => {
    			uiMean[i] = element.value;
    		});

    		set_store_value(resWord, $resWord = uiWord, $resWord);
    		set_store_value(resMean, $resMean = uiMean, $resMean);
    		set_store_value(choice, $choice = 'choices', $choice);

    		// reset Answer cuar customer 
    		CusList.update(() => {
    			return new Array($LisEnter.length).fill("");
    		});

    		//reset answer of chuong trinh de push khi add
    		set_store_value(AnsList, $AnsList = new Array($LisEnter.length), $AnsList);

    		set_store_value(reswholekey, $reswholekey = [], $reswholekey);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$l.warn(`<TaskEnterBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		AnsList,
    		CusList,
    		LisEnter,
    		choice,
    		resMean,
    		resWord,
    		reswholekey,
    		Add,
    		Remove,
    		next,
    		$reswholekey,
    		$LisEnter,
    		$AnsList,
    		$choice,
    		$resMean,
    		$resWord
    	});

    	return [Add, Remove, next];
    }

    class TaskEnterBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TaskEnterBoard",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* srcReviving\TaskBar\TaskResult.svelte generated by Svelte v3.59.2 */
    const file$N = "srcReviving\\TaskBar\\TaskResult.svelte";

    function create_fragment$P(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "home";
    			attr_dev(button, "id", "add");
    			attr_dev(button, "class", "svelte-1e4enjc");
    			add_location(button, file$N, 7, 0, 116);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Home*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let $choice;
    	validate_store(choice, 'choice');
    	component_subscribe($$self, choice, $$value => $$invalidate(1, $choice = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('TaskResult', slots, []);

    	function Home() {
    		set_store_value(choice, $choice = 'enter', $choice);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<TaskResult> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ choice, Home, $choice });
    	return [Home];
    }

    class TaskResult extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "TaskResult",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    /* srcReviving\TaskBar\Taskbar.svelte generated by Svelte v3.59.2 */
    const file$M = "srcReviving\\TaskBar\\Taskbar.svelte";

    // (27:12) {#if $suggestTF}
    function create_if_block_2$5(ctx) {
    	let previous_key = /*$suggestUpdate*/ ctx[1];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$2(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$suggestUpdate*/ 2 && safe_not_equal(previous_key, previous_key = /*$suggestUpdate*/ ctx[1])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$2(ctx);
    				key_block.c();
    				transition_in(key_block, 1);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(27:12) {#if $suggestTF}",
    		ctx
    	});

    	return block;
    }

    // (28:16) {#key $suggestUpdate}
    function create_key_block$2(ctx) {
    	let wordsuggestboard;
    	let current;
    	wordsuggestboard = new WordSuggestBoard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(wordsuggestboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wordsuggestboard, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wordsuggestboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wordsuggestboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wordsuggestboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$2.name,
    		type: "key",
    		source: "(28:16) {#key $suggestUpdate}",
    		ctx
    	});

    	return block;
    }

    // (38:8) {:else}
    function create_else_block$6(ctx) {
    	let taskresult;
    	let current;
    	taskresult = new TaskResult({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(taskresult.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(taskresult, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(taskresult.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(taskresult.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(taskresult, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(38:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (36:39) 
    function create_if_block_1$8(ctx) {
    	let taskchoice;
    	let current;
    	taskchoice = new TaskChoice({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(taskchoice.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(taskchoice, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(taskchoice.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(taskchoice.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(taskchoice, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(36:39) ",
    		ctx
    	});

    	return block;
    }

    // (34:8) {#if $choice == 'enter'}
    function create_if_block$f(ctx) {
    	let taskenterboard;
    	let current;
    	taskenterboard = new TaskEnterBoard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(taskenterboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(taskenterboard, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(taskenterboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(taskenterboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(taskenterboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(34:8) {#if $choice == 'enter'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let div2;
    	let div0;
    	let t0;
    	let div1;
    	let current_block_type_index;
    	let if_block1;
    	let t1;
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*$suggestTF*/ ctx[0] && create_if_block_2$5(ctx);
    	const if_block_creators = [create_if_block$f, create_if_block_1$8, create_else_block$6];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$choice*/ ctx[2] == 'enter') return 0;
    		if (/*$choice*/ ctx[2] == 'choices') return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div1 = element("div");
    			if_block1.c();
    			t1 = space();
    			button = element("button");
    			button.textContent = "dictionary";
    			attr_dev(div0, "id", "containsuggest");
    			attr_dev(div0, "class", "svelte-71s1wy");
    			add_location(div0, file$M, 24, 7, 472);
    			attr_dev(button, "id", "dic");
    			attr_dev(button, "class", "extrabut svelte-71s1wy");
    			add_location(button, file$M, 40, 8, 908);
    			attr_dev(div1, "id", "containgesture");
    			attr_dev(div1, "class", "svelte-71s1wy");
    			add_location(div1, file$M, 32, 7, 690);
    			attr_dev(div2, "id", "containerExtra");
    			attr_dev(div2, "class", "svelte-71s1wy");
    			add_location(div2, file$M, 22, 4, 429);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			if (if_block0) if_block0.m(div0, null);
    			append_dev(div2, t0);
    			append_dev(div2, div1);
    			if_blocks[current_block_type_index].m(div1, null);
    			append_dev(div1, t1);
    			append_dev(div1, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Dictest*/ ctx[3], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$suggestTF*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$suggestTF*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$5(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div0, null);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div1, t1);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (if_block0) if_block0.d();
    			if_blocks[current_block_type_index].d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let $dictionaryDS;
    	let $suggestTF;
    	let $suggestUpdate;
    	let $choice;
    	validate_store(dictionaryDS, 'dictionaryDS');
    	component_subscribe($$self, dictionaryDS, $$value => $$invalidate(4, $dictionaryDS = $$value));
    	validate_store(suggestTF, 'suggestTF');
    	component_subscribe($$self, suggestTF, $$value => $$invalidate(0, $suggestTF = $$value));
    	validate_store(suggestUpdate, 'suggestUpdate');
    	component_subscribe($$self, suggestUpdate, $$value => $$invalidate(1, $suggestUpdate = $$value));
    	validate_store(choice, 'choice');
    	component_subscribe($$self, choice, $$value => $$invalidate(2, $choice = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Taskbar', slots, []);

    	function Dictest() {
    		set_store_value(dictionaryDS, $dictionaryDS = true, $dictionaryDS);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Taskbar> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		choice,
    		dictionaryDS,
    		suggestTF,
    		suggestUpdate,
    		WordSuggestBoard,
    		TaskChoice,
    		TaskEnterBoard,
    		TaskResult,
    		Dictest,
    		$dictionaryDS,
    		$suggestTF,
    		$suggestUpdate,
    		$choice
    	});

    	return [$suggestTF, $suggestUpdate, $choice, Dictest];
    }

    class Taskbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Taskbar",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* srcReviving\Dictionary\BoardDic.svelte generated by Svelte v3.59.2 */
    const file$L = "srcReviving\\Dictionary\\BoardDic.svelte";

    function create_fragment$N(ctx) {
    	let div;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let button2;
    	let t5;
    	let button3;
    	let t7;
    	let button4;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			button0 = element("button");
    			button0.textContent = "defi";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "syn";
    			t3 = space();
    			button2 = element("button");
    			button2.textContent = "ant";
    			t5 = space();
    			button3 = element("button");
    			button3.textContent = "adj";
    			t7 = space();
    			button4 = element("button");
    			button4.textContent = "noun";
    			attr_dev(button0, "class", "typeDS svelte-11v8fm6");
    			add_location(button0, file$L, 35, 4, 1042);
    			attr_dev(button1, "class", "typeDS svelte-11v8fm6");
    			add_location(button1, file$L, 36, 4, 1117);
    			attr_dev(button2, "class", "typeDS svelte-11v8fm6");
    			add_location(button2, file$L, 37, 4, 1190);
    			attr_dev(button3, "class", "typeDS svelte-11v8fm6");
    			add_location(button3, file$L, 38, 4, 1263);
    			attr_dev(button4, "class", "typeDS svelte-11v8fm6");
    			add_location(button4, file$L, 39, 4, 1336);
    			attr_dev(div, "id", "containerTypeDS");
    			attr_dev(div, "class", "svelte-11v8fm6");
    			add_location(div, file$L, 34, 0, 1008);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, button0);
    			append_dev(div, t1);
    			append_dev(div, button1);
    			append_dev(div, t3);
    			append_dev(div, button2);
    			append_dev(div, t5);
    			append_dev(div, button3);
    			append_dev(div, t7);
    			append_dev(div, button4);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*click_handler*/ ctx[1], false, false, false, false),
    					listen_dev(button1, "click", /*click_handler_1*/ ctx[2], false, false, false, false),
    					listen_dev(button2, "click", /*click_handler_2*/ ctx[3], false, false, false, false),
    					listen_dev(button3, "click", /*click_handler_3*/ ctx[4], false, false, false, false),
    					listen_dev(button4, "click", /*click_handler_4*/ ctx[5], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let $stepDS;
    	validate_store(stepDS, 'stepDS');
    	component_subscribe($$self, stepDS, $$value => $$invalidate(6, $stepDS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('BoardDic', slots, []);

    	onMount(() => {
    		document.getElementsByClassName('typeDS')[0].style.backgroundColor = '#fefefe';
    		document.getElementsByClassName('typeDS')[0].style.color = '#1d1d1d';
    	});

    	function Ref(choice, k) {
    		if (choice == 'defi') {
    			set_store_value(stepDS, $stepDS = 'defi', $stepDS);
    		} else if (choice == 'syn') {
    			set_store_value(stepDS, $stepDS = 'syn', $stepDS);
    		} else if (choice == 'ant') {
    			set_store_value(stepDS, $stepDS = 'ant', $stepDS);
    		} else if (choice == 'coA') {
    			set_store_value(stepDS, $stepDS = 'coA', $stepDS);
    		} else if (choice == 'coN') {
    			set_store_value(stepDS, $stepDS = 'coN', $stepDS);
    		}

    		for (let i = 0; i <= 4; i++) {
    			if (i + 1 == k) {
    				document.getElementsByClassName('typeDS')[i].style.backgroundColor = '#fefefe';
    				document.getElementsByClassName('typeDS')[i].style.color = '#1d1d1d';
    			} else {
    				document.getElementsByClassName('typeDS')[i].style.backgroundColor = 'transparent';
    				document.getElementsByClassName('typeDS')[i].style.color = '#fefefe';
    			}
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<BoardDic> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => {
    		Ref('defi', 1);
    	};

    	const click_handler_1 = () => {
    		Ref('syn', 2);
    	};

    	const click_handler_2 = () => {
    		Ref('ant', 3);
    	};

    	const click_handler_3 = () => {
    		Ref('coA', 4);
    	};

    	const click_handler_4 = () => {
    		Ref('coN', 5);
    	};

    	$$self.$capture_state = () => ({ onMount, stepDS, Ref, $stepDS });

    	return [
    		Ref,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4
    	];
    }

    class BoardDic extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BoardDic",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    /* srcReviving\Dictionary\DefiDS.svelte generated by Svelte v3.59.2 */

    const { console: console_1$k } = globals;
    const file$K = "srcReviving\\Dictionary\\DefiDS.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (126:38) 
    function create_if_block_7(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#c780e8");
    			add_location(div, file$K, 126, 4, 3774);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(126:38) ",
    		ctx
    	});

    	return block;
    }

    // (124:43) 
    function create_if_block_6$1(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#9d94ff");
    			add_location(div, file$K, 124, 4, 3647);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(124:43) ",
    		ctx
    	});

    	return block;
    }

    // (122:42) 
    function create_if_block_5$1(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#59adf6");
    			add_location(div, file$K, 122, 4, 3515);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(122:42) ",
    		ctx
    	});

    	return block;
    }

    // (120:42) 
    function create_if_block_4$2(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#08cad1");
    			add_location(div, file$K, 120, 4, 3384);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(120:42) ",
    		ctx
    	});

    	return block;
    }

    // (118:37) 
    function create_if_block_3$2(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#42d6a4");
    			add_location(div, file$K, 118, 4, 3253);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(118:37) ",
    		ctx
    	});

    	return block;
    }

    // (116:40) 
    function create_if_block_2$4(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#f8f38d");
    			add_location(div, file$K, 116, 4, 3127);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(116:40) ",
    		ctx
    	});

    	return block;
    }

    // (114:35) 
    function create_if_block_1$7(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#ffb480");
    			add_location(div, file$K, 114, 4, 2998);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(114:35) ",
    		ctx
    	});

    	return block;
    }

    // (112:4) {#if types.type== 'noun'}
    function create_if_block$e(ctx) {
    	let div;
    	let t_value = /*types*/ ctx[4].type + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "partOfSpeech svelte-6z1hk9");
    			set_style(div, "background-color", "#ff6961");
    			add_location(div, file$K, 112, 4, 2874);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t_value !== (t_value = /*types*/ ctx[4].type + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(112:4) {#if types.type== 'noun'}",
    		ctx
    	});

    	return block;
    }

    // (129:4) {#each types.deex as defiexam}
    function create_each_block_1$1(ctx) {
    	let div2;
    	let button;
    	let t1;
    	let div0;
    	let t2_value = /*defiexam*/ ctx[7].defi + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4_value = /*defiexam*/ ctx[7].exam + "";
    	let t4;
    	let t5;
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[3](/*defiexam*/ ctx[7]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "save";
    			t1 = space();
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(button, "class", "savevo svelte-6z1hk9");
    			add_location(button, file$K, 130, 8, 3978);
    			attr_dev(div0, "class", "DefiEng svelte-6z1hk9");
    			add_location(div0, file$K, 131, 8, 4078);
    			attr_dev(div1, "class", "ExEng svelte-6z1hk9");
    			add_location(div1, file$K, 132, 8, 4132);
    			attr_dev(div2, "class", "MeaningClass svelte-6z1hk9");
    			add_location(div2, file$K, 129, 4, 3908);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, t4);
    			append_dev(div2, t5);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*fetchValue*/ 2) && t2_value !== (t2_value = /*defiexam*/ ctx[7].defi + "")) set_data_dev(t2, t2_value);
    			if ((!current || dirty & /*fetchValue*/ 2) && t4_value !== (t4_value = /*defiexam*/ ctx[7].exam + "")) set_data_dev(t4, t4_value);
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, blur, { duration: 500 }, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, blur, { duration: 500 }, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(129:4) {#each types.deex as defiexam}",
    		ctx
    	});

    	return block;
    }

    // (111:2) {#each fetchValue.board as types}
    function create_each_block$e(ctx) {
    	let t;
    	let each_1_anchor;
    	let current;

    	function select_block_type(ctx, dirty) {
    		if (/*types*/ ctx[4].type == 'noun') return create_if_block$e;
    		if (/*types*/ ctx[4].type == 'verb') return create_if_block_1$7;
    		if (/*types*/ ctx[4].type == 'adjective') return create_if_block_2$4;
    		if (/*types*/ ctx[4].type == 'adverb') return create_if_block_3$2;
    		if (/*types*/ ctx[4].type == 'preposition') return create_if_block_4$2;
    		if (/*types*/ ctx[4].type == 'conjunction') return create_if_block_5$1;
    		if (/*types*/ ctx[4].type == 'interjection') return create_if_block_6$1;
    		if (/*types*/ ctx[4].type == 'pronoun') return create_if_block_7;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);
    	let each_value_1 = /*types*/ ctx[4].deex;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(t.parentNode, t);
    				}
    			}

    			if (dirty & /*fetchValue, Saving, $enterText*/ 6) {
    				each_value_1 = /*types*/ ctx[4].deex;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(t);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(111:2) {#each fetchValue.board as types}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let div2_style_value;
    	let current;
    	let each_value = /*fetchValue*/ ctx[1].board;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*$enterText*/ ctx[2]);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "word");
    			attr_dev(div0, "class", "svelte-6z1hk9");
    			add_location(div0, file$K, 106, 4, 2746);
    			attr_dev(div1, "id", "containerWord");
    			attr_dev(div1, "class", "svelte-6z1hk9");
    			add_location(div1, file$K, 105, 2, 2714);
    			attr_dev(div2, "class", "containerPath svelte-6z1hk9");
    			attr_dev(div2, "style", div2_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div2, file$K, 104, 0, 2650);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div2, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$enterText*/ 4) set_data_dev(t0, /*$enterText*/ ctx[2]);

    			if (dirty & /*fetchValue, Saving, $enterText*/ 6) {
    				each_value = /*fetchValue*/ ctx[1].board;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$e(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$e(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (!current || dirty & /*zIndex*/ 1 && div2_style_value !== (div2_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div2, "style", div2_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Saving$1(definition, words) {
    	let vocData = JSON.parse(localStorage.getItem('vocabulary'));
    	let date = `${new Date().getUTCDate()} - ${new Date().getUTCMonth() + 1} - ${new Date().getUTCFullYear()}`;

    	if (vocData.length === 0 || vocData[0].day !== date) {
    		let newDay = {};
    		newDay["day"] = date;
    		newDay["content"] = [];
    		vocData.unshift(newDay);
    	}

    	let con = {};
    	con["word"] = words;
    	con["definition"] = definition;
    	vocData[0].content.push(con);
    	localStorage.setItem('vocabulary', JSON.stringify(vocData));
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText, 'enterText');
    	component_subscribe($$self, enterText, $$value => $$invalidate(2, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DefiDS', slots, []);
    	let zIndex = 0;

    	stepDS.subscribe(value => {
    		if (value == 'defi') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let fetchValue = { "word": "", "pronon": "", "board": [] };

    	//API DÈINITION
    	onMount(() => {
    		let huptext = $enterText;
    		var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + `${huptext}`;
    		let contaiFile;

    		fetch(link).then(res => res.json()).then(result => {
    			result.map(run1);

    			function run1(resultNew) {
    				$$invalidate(1, fetchValue.word = resultNew.word, fetchValue);
    				$$invalidate(1, fetchValue.pronon = resultNew.phonetic, fetchValue);
    				resultNew.meanings.map(run2);

    				//phonetic vs word here
    				console.log(fetchValue);
    			}

    			function run2(meaningsNew) {
    				contaiFile = { "type": "", "deex": [] };
    				contaiFile.type = meaningsNew.partOfSpeech;
    				meaningsNew.definitions.map(run3);
    				console.log(contaiFile, "finishedrun2");
    				fetchValue.board.push(contaiFile);
    			}

    			function run3(definitionsNew) {
    				console.log(definitionsNew.definition + "run3");
    				let deSam = { "defi": "", "exam": "" };
    				deSam.defi = definitionsNew.definition;

    				if (definitionsNew.example != undefined) {
    					deSam.exam = "Ex: " + definitionsNew.example;
    				} else {
    					deSam.exam = '';
    				}

    				contaiFile.deex.push(deSam);
    			}
    		}).catch(error => {
    			document.write(error);
    		}).finally(() => {
    			
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$k.warn(`<DefiDS> was created with unknown prop '${key}'`);
    	});

    	const click_handler = defiexam => {
    		Saving$1(defiexam.defi, $enterText);
    	};

    	$$self.$capture_state = () => ({
    		blur,
    		enterText,
    		stepDS,
    		onMount,
    		zIndex,
    		fetchValue,
    		Saving: Saving$1,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('fetchValue' in $$props) $$invalidate(1, fetchValue = $$props.fetchValue);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, fetchValue, $enterText, click_handler];
    }

    class DefiDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DefiDS",
    			options,
    			id: create_fragment$M.name
    		});
    	}
    }

    /* srcReviving\Dictionary\SynDS.svelte generated by Svelte v3.59.2 */
    const file$J = "srcReviving\\Dictionary\\SynDS.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$d(ctx) {
    	let each_1_anchor;
    	let each_value = /*synonymsList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*synonymsList*/ 4) {
    				each_value = /*synonymsList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$d(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$d(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each synonymsList as Syn}
    function create_each_block$d(ctx) {
    	let div;
    	let t_value = /*Syn*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "SynWord svelte-pln53j");
    			add_location(div, file$J, 37, 8, 990);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*synonymsList*/ 4 && t_value !== (t_value = /*Syn*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(37:8) {#each synonymsList as Syn}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$L(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containerSyn svelte-pln53j");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$J, 34, 4, 855);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText, 'enterText');
    	component_subscribe($$self, enterText, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SynDS', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDS.subscribe(value => {
    		if (value == 'syn') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let synonymsList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlsyn = "https://api.datamuse.com/words?rel_syn=" + huptext;

    		fetch(urlsyn).then(res => res.json()).then(result => {
    			$$invalidate(2, synonymsList = []);
    			result.map(createSyn);
    			$$invalidate(1, loaded = true);

    			function createSyn(Syn) {
    				synonymsList.push(Syn.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SynDS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS,
    		enterText,
    		onMount,
    		zIndex,
    		loaded,
    		synonymsList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('synonymsList' in $$props) $$invalidate(2, synonymsList = $$props.synonymsList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, synonymsList];
    }

    class SynDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SynDS",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    /* srcReviving\Dictionary\AntDS.svelte generated by Svelte v3.59.2 */
    const file$I = "srcReviving\\Dictionary\\AntDS.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$c(ctx) {
    	let each_1_anchor;
    	let each_value = /*antonymsList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*antonymsList*/ 4) {
    				each_value = /*antonymsList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$c(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$c(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each antonymsList as Ant}
    function create_each_block$c(ctx) {
    	let div;
    	let t_value = /*Ant*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "AntWord svelte-uizxxh");
    			add_location(div, file$I, 37, 8, 975);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*antonymsList*/ 4 && t_value !== (t_value = /*Ant*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(37:8) {#each antonymsList as Ant}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$c(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containerAnt svelte-uizxxh");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$I, 34, 4, 840);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText, 'enterText');
    	component_subscribe($$self, enterText, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AntDS', slots, []);
    	let zIndex = 0;
    	let loaded;

    	stepDS.subscribe(value => {
    		if (value == 'ant') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let antonymsList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlant = "https://api.datamuse.com/words?rel_ant=" + huptext;

    		fetch(urlant).then(res => res.json()).then(result => {
    			$$invalidate(2, antonymsList = []);
    			result.map(createAnt);
    			$$invalidate(1, loaded = true);

    			function createAnt(Ant) {
    				antonymsList.push(Ant.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AntDS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS,
    		enterText,
    		onMount,
    		zIndex,
    		loaded,
    		antonymsList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('antonymsList' in $$props) $$invalidate(2, antonymsList = $$props.antonymsList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, antonymsList];
    }

    class AntDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AntDS",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* srcReviving\Dictionary\CoADS.svelte generated by Svelte v3.59.2 */
    const file$H = "srcReviving\\Dictionary\\CoADS.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$b(ctx) {
    	let each_1_anchor;
    	let each_value = /*coAList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coAList, $enterText*/ 12) {
    				each_value = /*coAList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each coAList as coA}
    function create_each_block$b(ctx) {
    	let div;
    	let t_value = /*coA*/ ctx[4] + " " + /*$enterText*/ ctx[3] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "coAWord svelte-1uk4o7l");
    			add_location(div, file$H, 37, 8, 970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*coAList, $enterText*/ 12 && t_value !== (t_value = /*coA*/ ctx[4] + " " + /*$enterText*/ ctx[3] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(37:8) {#each coAList as coA}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$b(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containercoA svelte-1uk4o7l");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$H, 34, 4, 840);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$b(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText, 'enterText');
    	component_subscribe($$self, enterText, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CoADS', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDS.subscribe(value => {
    		if (value == 'coA') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let coAList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlcoA = "https://api.datamuse.com/words?rel_jjb=" + huptext;

    		fetch(urlcoA).then(res => res.json()).then(result => {
    			$$invalidate(2, coAList = []);
    			result.map(createcoA);
    			$$invalidate(1, loaded = true);

    			function createcoA(coA) {
    				coAList.push(coA.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CoADS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS,
    		enterText,
    		onMount,
    		zIndex,
    		loaded,
    		coAList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('coAList' in $$props) $$invalidate(2, coAList = $$props.coAList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, coAList, $enterText];
    }

    class CoADS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CoADS",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* srcReviving\Dictionary\CoNDS.svelte generated by Svelte v3.59.2 */
    const file$G = "srcReviving\\Dictionary\\CoNDS.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (36:8) {#if loaded==true}
    function create_if_block$a(ctx) {
    	let each_1_anchor;
    	let each_value = /*coNList*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$enterText, coNList*/ 12) {
    				each_value = /*coNList*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(36:8) {#if loaded==true}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#each coNList as coN}
    function create_each_block$a(ctx) {
    	let div;
    	let t_value = /*$enterText*/ ctx[3] + " " + /*coN*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "coNWord svelte-j0axn7");
    			add_location(div, file$G, 37, 8, 970);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$enterText, coNList*/ 12 && t_value !== (t_value = /*$enterText*/ ctx[3] + " " + /*coN*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(37:8) {#each coNList as coN}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let div;
    	let div_style_value;
    	let if_block = /*loaded*/ ctx[1] == true && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "containercoN svelte-j0axn7");
    			attr_dev(div, "style", div_style_value = `z-index:${/*zIndex*/ ctx[0]};`);
    			add_location(div, file$G, 34, 4, 840);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*loaded*/ ctx[1] == true) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (dirty & /*zIndex*/ 1 && div_style_value !== (div_style_value = `z-index:${/*zIndex*/ ctx[0]};`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let $enterText;
    	validate_store(enterText, 'enterText');
    	component_subscribe($$self, enterText, $$value => $$invalidate(3, $enterText = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CoNDS', slots, []);
    	let zIndex = 0;
    	let loaded; //chờ loadd thay đổi thì update

    	stepDS.subscribe(value => {
    		if (value == 'coN') {
    			$$invalidate(0, zIndex = 1);
    		} else $$invalidate(0, zIndex = 0);
    	});

    	let coNList;

    	onMount(() => {
    		$$invalidate(1, loaded = false);
    		let huptext = $enterText;
    		var urlcoN = "https://api.datamuse.com/words?rel_jja=" + huptext;

    		fetch(urlcoN).then(res => res.json()).then(result => {
    			$$invalidate(2, coNList = []);
    			result.map(createcoN);
    			$$invalidate(1, loaded = true);

    			function createcoN(coN) {
    				coNList.push(coN.word);
    			}
    		});
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CoNDS> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		stepDS,
    		enterText,
    		onMount,
    		zIndex,
    		loaded,
    		coNList,
    		$enterText
    	});

    	$$self.$inject_state = $$props => {
    		if ('zIndex' in $$props) $$invalidate(0, zIndex = $$props.zIndex);
    		if ('loaded' in $$props) $$invalidate(1, loaded = $$props.loaded);
    		if ('coNList' in $$props) $$invalidate(2, coNList = $$props.coNList);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [zIndex, loaded, coNList, $enterText];
    }

    class CoNDS extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CoNDS",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    /* srcReviving\Dictionary\NoResult.svelte generated by Svelte v3.59.2 */
    const file$F = "srcReviving\\Dictionary\\NoResult.svelte";

    function create_fragment$H(ctx) {
    	let div;
    	let div_transition;
    	let current;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Opp!! No data found.";
    			attr_dev(div, "id", "noresult");
    			attr_dev(div, "class", "svelte-1qc71ks");
    			add_location(div, file$F, 3, 0, 65);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div_transition) div_transition = create_bidirectional_transition(div, slide, { duration: 300 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('NoResult', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<NoResult> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ slide });
    	return [];
    }

    class NoResult extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NoResult",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* srcReviving\Dictionary\Dictionary.svelte generated by Svelte v3.59.2 */
    const file$E = "srcReviving\\Dictionary\\Dictionary.svelte";

    // (48:8) {#if search}
    function create_if_block$9(ctx) {
    	let previous_key = /*$enterText*/ ctx[2];
    	let key_block_anchor;
    	let current;
    	let key_block = create_key_block$1(ctx);

    	const block = {
    		c: function create() {
    			key_block.c();
    			key_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			key_block.m(target, anchor);
    			insert_dev(target, key_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$enterText*/ 4 && safe_not_equal(previous_key, previous_key = /*$enterText*/ ctx[2])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block$1(ctx);
    				key_block.c();
    				transition_in(key_block, 1);
    				key_block.m(key_block_anchor.parentNode, key_block_anchor);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(key_block_anchor);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(48:8) {#if search}",
    		ctx
    	});

    	return block;
    }

    // (60:41) 
    function create_if_block_2$3(ctx) {
    	let noresult;
    	let current;
    	noresult = new NoResult({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(noresult.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(noresult, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(noresult.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(noresult.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(noresult, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(60:41) ",
    		ctx
    	});

    	return block;
    }

    // (50:12) {#if haveornot == true}
    function create_if_block_1$6(ctx) {
    	let div1;
    	let div0;
    	let t0;
    	let boarddic;
    	let t1;
    	let defids;
    	let t2;
    	let synds;
    	let t3;
    	let antds;
    	let t4;
    	let coads;
    	let t5;
    	let conds;
    	let div1_transition;
    	let current;
    	boarddic = new BoardDic({ $$inline: true });
    	defids = new DefiDS({ $$inline: true });
    	synds = new SynDS({ $$inline: true });
    	antds = new AntDS({ $$inline: true });
    	coads = new CoADS({ $$inline: true });
    	conds = new CoNDS({ $$inline: true });

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			create_component(boarddic.$$.fragment);
    			t1 = space();
    			create_component(defids.$$.fragment);
    			t2 = space();
    			create_component(synds.$$.fragment);
    			t3 = space();
    			create_component(antds.$$.fragment);
    			t4 = space();
    			create_component(coads.$$.fragment);
    			t5 = space();
    			create_component(conds.$$.fragment);
    			attr_dev(div0, "id", "behindblur");
    			attr_dev(div0, "class", "svelte-mm8umt");
    			add_location(div0, file$E, 51, 16, 1546);
    			attr_dev(div1, "id", "contInnerDic");
    			attr_dev(div1, "class", "svelte-mm8umt");
    			add_location(div1, file$E, 50, 16, 1470);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div1, t0);
    			mount_component(boarddic, div1, null);
    			append_dev(div1, t1);
    			mount_component(defids, div1, null);
    			append_dev(div1, t2);
    			mount_component(synds, div1, null);
    			append_dev(div1, t3);
    			mount_component(antds, div1, null);
    			append_dev(div1, t4);
    			mount_component(coads, div1, null);
    			append_dev(div1, t5);
    			mount_component(conds, div1, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(boarddic.$$.fragment, local);
    			transition_in(defids.$$.fragment, local);
    			transition_in(synds.$$.fragment, local);
    			transition_in(antds.$$.fragment, local);
    			transition_in(coads.$$.fragment, local);
    			transition_in(conds.$$.fragment, local);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 500 }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(boarddic.$$.fragment, local);
    			transition_out(defids.$$.fragment, local);
    			transition_out(synds.$$.fragment, local);
    			transition_out(antds.$$.fragment, local);
    			transition_out(coads.$$.fragment, local);
    			transition_out(conds.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 500 }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(boarddic);
    			destroy_component(defids);
    			destroy_component(synds);
    			destroy_component(antds);
    			destroy_component(coads);
    			destroy_component(conds);
    			if (detaching && div1_transition) div1_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(50:12) {#if haveornot == true}",
    		ctx
    	});

    	return block;
    }

    // (49:8) {#key $enterText}
    function create_key_block$1(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_1$6, create_if_block_2$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*haveornot*/ ctx[1] == true) return 0;
    		if (/*haveornot*/ ctx[1] == false) return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block$1.name,
    		type: "key",
    		source: "(49:8) {#key $enterText}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$G(ctx) {
    	let button0;
    	let t0;
    	let div2;
    	let div0;
    	let input;
    	let t1;
    	let button1;
    	let t3;
    	let div1;
    	let div2_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*search*/ ctx[0] && create_if_block$9(ctx);

    	const block = {
    		c: function create() {
    			button0 = element("button");
    			t0 = space();
    			div2 = element("div");
    			div0 = element("div");
    			input = element("input");
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = ">>";
    			t3 = space();
    			div1 = element("div");
    			if (if_block) if_block.c();
    			attr_dev(button0, "id", "backgroundexit");
    			attr_dev(button0, "class", "svelte-mm8umt");
    			add_location(button0, file$E, 38, 0, 1037);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", "enterWord");
    			attr_dev(input, "autocomplete", "off");
    			attr_dev(input, "class", "svelte-mm8umt");
    			add_location(input, file$E, 42, 4, 1205);
    			attr_dev(button1, "id", "SearchDic");
    			attr_dev(button1, "class", "svelte-mm8umt");
    			add_location(button1, file$E, 43, 4, 1266);
    			attr_dev(div0, "id", "containSearch");
    			attr_dev(div0, "class", "svelte-mm8umt");
    			add_location(div0, file$E, 41, 4, 1174);
    			attr_dev(div1, "id", "containerDic");
    			attr_dev(div1, "class", "svelte-mm8umt");
    			add_location(div1, file$E, 46, 4, 1342);
    			attr_dev(div2, "id", "containerDictionary");
    			attr_dev(div2, "class", "svelte-mm8umt");
    			add_location(div2, file$E, 39, 0, 1096);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, input);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			if (if_block) if_block.m(div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*Exit*/ ctx[4], false, false, false, false),
    					listen_dev(button1, "click", /*change*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*search*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*search*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div1, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 500 }, true);
    				div2_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			if (!div2_transition) div2_transition = create_bidirectional_transition(div2, slide, { duration: 500 }, false);
    			div2_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div2);
    			if (if_block) if_block.d();
    			if (detaching && div2_transition) div2_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let $dictionaryDS;
    	let $enterText;
    	let $stepDS;
    	validate_store(dictionaryDS, 'dictionaryDS');
    	component_subscribe($$self, dictionaryDS, $$value => $$invalidate(5, $dictionaryDS = $$value));
    	validate_store(enterText, 'enterText');
    	component_subscribe($$self, enterText, $$value => $$invalidate(2, $enterText = $$value));
    	validate_store(stepDS, 'stepDS');
    	component_subscribe($$self, stepDS, $$value => $$invalidate(6, $stepDS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Dictionary', slots, []);
    	let search = false;
    	let haveornot = 'no';

    	function change() {
    		set_store_value(stepDS, $stepDS = 'defi', $stepDS);
    		$$invalidate(0, search = true);
    		let text = document.getElementById('enterWord').value;
    		var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + `${text}`;

    		fetch(link).then(res => {
    			if (res.ok) {
    				$$invalidate(1, haveornot = true);
    				set_store_value(enterText, $enterText = text, $enterText);
    			} else {
    				$$invalidate(1, haveornot = false);
    			}
    		});
    	}

    	function Exit() {
    		set_store_value(dictionaryDS, $dictionaryDS = false, $dictionaryDS);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Dictionary> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		dictionaryDS,
    		enterText,
    		stepDS,
    		BoardDic,
    		DefiDs: DefiDS,
    		SynDs: SynDS,
    		AntDs: AntDS,
    		CoAds: CoADS,
    		CoNds: CoNDS,
    		NoResult,
    		slide,
    		search,
    		haveornot,
    		change,
    		Exit,
    		$dictionaryDS,
    		$enterText,
    		$stepDS
    	});

    	$$self.$inject_state = $$props => {
    		if ('search' in $$props) $$invalidate(0, search = $$props.search);
    		if ('haveornot' in $$props) $$invalidate(1, haveornot = $$props.haveornot);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [search, haveornot, $enterText, change, Exit];
    }

    class Dictionary extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dictionary",
    			options,
    			id: create_fragment$G.name
    		});
    	}
    }

    /* srcReviving\Chars\CharsNext.svelte generated by Svelte v3.59.2 */

    const { console: console_1$j } = globals;
    const file$D = "srcReviving\\Chars\\CharsNext.svelte";

    function create_fragment$F(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "next";
    			attr_dev(button, "class", "next svelte-u7mpek");
    			add_location(button, file$D, 19, 0, 517);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Slide*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let $LisEnter;
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(1, $LisEnter = $$value));
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(2, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(3, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(4, $MinSlide = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CharsNext', slots, []);

    	function Slide() {
    		set_store_value(onSide, $onSide++, $onSide);

    		if ($onSide == $LisEnter.length - 1) {
    			set_store_value(MaxSlide, $MaxSlide = true, $MaxSlide);
    			console.log($onSide);
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		document.getElementById('slideContain').style.transform = "translate(" + $onSide * -100 / $LisEnter.length + "%, 0)";
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$j.warn(`<CharsNext> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		Slide,
    		$LisEnter,
    		$onSide,
    		$MaxSlide,
    		$MinSlide
    	});

    	return [Slide];
    }

    class CharsNext extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharsNext",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    /* srcReviving\Chars\CharsBoard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$i } = globals;
    const file$C = "srcReviving\\Chars\\CharsBoard.svelte";

    function create_fragment$E(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let div0_id_value;
    	let t;
    	let div1;
    	let div1_id_value;
    	let div2_id_value;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "containfuture svelte-1ibs4ws");
    			attr_dev(div0, "id", div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`);
    			add_location(div0, file$C, 143, 4, 4090);
    			attr_dev(div1, "class", "containfuture svelte-1ibs4ws");
    			attr_dev(div1, "id", div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`);
    			add_location(div1, file$C, 145, 4, 4164);
    			attr_dev(div2, "class", "titleQues svelte-1ibs4ws");
    			attr_dev(div2, "id", div2_id_value = "QuesChar" + `${/*sort*/ ctx[0]}`);
    			add_location(div2, file$C, 142, 4, 4031);
    			attr_dev(div3, "class", "containCharsBoard svelte-1ibs4ws");
    			add_location(div3, file$C, 141, 0, 3992);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sort*/ 1 && div0_id_value !== (div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div0, "id", div0_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div1_id_value !== (div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div1, "id", div1_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div2_id_value !== (div2_id_value = "QuesChar" + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div2, "id", div2_id_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CharsBoard', slots, []);
    	let { words, means, sort } = $$props;
    	let finalresult;

    	onMount(() => {
    		//algorith for pick key words
    		let lenghtmax = words.length;

    		let n = Math.floor(Math.random() * Math.round(lenghtmax / 2) + 1); //length:2, randomize 1 to n/2 find hidding numbers
    		let L = new Array(n).fill('');
    		let A = new Array(lenghtmax).fill(false);
    		let W = words.split('');

    		for (let i = 0; i < n; i++) {
    			let l = Math.floor(Math.random() * (lenghtmax - 1));
    			console.log("llsd", W[l]);

    			while (A[l] || W[l] == " ") {
    				console.log("llll", W[l]);
    				l = Math.floor(Math.random() * (lenghtmax - 1));
    			}

    			A[l] = true;

    			//     W[l] = `<input style = "padding: 1vh;
    			// background-color: #eee;
    			// width: 5vh;
    			// text-align: center;
    			// border-radius: 1vh;
    			// font-size: 6vh;
    			// font-weight: bold;" maxlength="1" id="QuesChar${sort}input${i}">`
    			W[l] = document.createElement('input');

    			W[l].style.cssText = `    width: 5vh;
    text-align: center;
    font-size: 6vh;
    height: 7vh;
    font-weight: bold;
    font-family: monospace;
    position: relative;
    border: 0px;
    background-color:#eeeeee;
    margin-inline: 0.2vh;
    color:#333333;
    border-radius: 1.5vh;
    transition:0.2s ease-in`;

    			W[l].maxLength = 1;
    			W[l].setAttribute('spellcheck', 'false');
    			W[l].setAttribute('autocomplete', 'off');
    		}

    		//     W = W.map(item => {
    		//     if (item instanceof HTMLElement) {
    		//         return item.outerHTML; // Convert the input element to its HTML representation
    		//     } else {
    		//         return item; // For other elements, just return them as is
    		//     }
    		// }).join("")
    		let d = 0;

    		let S = '';

    		for (let i = 0; i < W.length; i++) {
    			if (W[i] instanceof HTMLElement) {
    				L[d] = i;
    				S += words[i]; // lay nd cac o input
    				W[i].id = `QuesChar${sort}input${d}`;
    				W[i] = W[i].outerHTML;
    				d++;
    			}
    		}

    		AnsList.update(value => {
    			//Daps Ans
    			value[sort] = S;

    			return value;
    		});

    		W = W.join('');
    		console.log(W);

    		// document.getElementById("QuesChar"+`${sort}`).innerHTML = finalresult
    		document.getElementById('furword' + `${sort}`).innerHTML = W;

    		document.getElementById('furmean' + `${sort}`).innerHTML = means;
    		let CusAns = new Array(n).fill("");
    		let whole = words.split('');

    		for (let i = 0; i < n; i++) {
    			let p = document.getElementById(`QuesChar${sort}input${i}`);

    			p.addEventListener("focus", function () {
    				this.style.backgroundColor = '#1d1d1d';
    				this.style.color = '#fefefe';
    			});

    			p.addEventListener("blur", function () {
    				this.style.backgroundColor = '#eeeeee';
    				this.style.color = '#1d1d1d';
    			});

    			p.addEventListener("mouseout", function () {
    				this.style.backgroundColor = '#eeeeee';
    				this.style.color = '#1d1d1d';
    			});

    			p.addEventListener("mouseover", function () {
    				this.style.backgroundColor = '#535353';
    				this.style.color = '#eeeeee';
    			});

    			p.addEventListener('input', () => {
    				CusAns[i] = p.value;
    				whole[L[i]] = p.value;

    				reswholekey.update(value => {
    					value[sort] = whole.join('');
    					return value;
    				});

    				CusList.update(value => {
    					value[sort] = CusAns.join('');
    					return value;
    				});

    				if (p.value.length == 1) {
    					if (i != n - 1) {
    						console.log("d------", d);
    						document.getElementById(`QuesChar${sort}input${i + 1}`).focus();
    					}
    				}
    			});
    		}
    	});

    	$$self.$$.on_mount.push(function () {
    		if (words === undefined && !('words' in $$props || $$self.$$.bound[$$self.$$.props['words']])) {
    			console_1$i.warn("<CharsBoard> was created without expected prop 'words'");
    		}

    		if (means === undefined && !('means' in $$props || $$self.$$.bound[$$self.$$.props['means']])) {
    			console_1$i.warn("<CharsBoard> was created without expected prop 'means'");
    		}

    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console_1$i.warn("<CharsBoard> was created without expected prop 'sort'");
    		}
    	});

    	const writable_props = ['words', 'means', 'sort'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$i.warn(`<CharsBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		AnsList,
    		CusList,
    		resWord,
    		reswholekey,
    		words,
    		means,
    		sort,
    		finalresult
    	});

    	$$self.$inject_state = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    		if ('finalresult' in $$props) finalresult = $$props.finalresult;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sort, words, means];
    }

    class CharsBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, { words: 1, means: 2, sort: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharsBoard",
    			options,
    			id: create_fragment$E.name
    		});
    	}

    	get words() {
    		throw new Error("<CharsBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set words(value) {
    		throw new Error("<CharsBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get means() {
    		throw new Error("<CharsBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set means(value) {
    		throw new Error("<CharsBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sort() {
    		throw new Error("<CharsBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<CharsBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReviving\Chars\CharsBack.svelte generated by Svelte v3.59.2 */
    const file$B = "srcReviving\\Chars\\CharsBack.svelte";

    function create_fragment$D(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "back";
    			attr_dev(button, "class", "back svelte-137dgon");
    			add_location(button, file$B, 18, 2, 498);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Slide*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let $LisEnter;
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(1, $LisEnter = $$value));
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(2, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(3, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(4, $MinSlide = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CharsBack', slots, []);

    	function Slide() {
    		set_store_value(onSide, $onSide--, $onSide);

    		if ($onSide == 0) {
    			set_store_value(MinSlide, $MinSlide = true, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		document.getElementById('slideContain').style.transform = "translate(" + $onSide * -100 / $LisEnter.length + "%, 0)";
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CharsBack> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		Slide,
    		$LisEnter,
    		$onSide,
    		$MaxSlide,
    		$MinSlide
    	});

    	return [Slide];
    }

    class CharsBack extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharsBack",
    			options,
    			id: create_fragment$D.name
    		});
    	}
    }

    /* srcReviving\Chars\FinishButton.svelte generated by Svelte v3.59.2 */

    const { console: console_1$h } = globals;
    const file$A = "srcReviving\\Chars\\FinishButton.svelte";

    function create_fragment$C(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "done";
    			attr_dev(button, "class", "finish svelte-1ik6ap4");
    			add_location(button, file$A, 24, 2, 578);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Ans*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let $resScore;
    	let $AnsList;
    	let $CusList;
    	let $choice;
    	let $resWord;
    	validate_store(resScore, 'resScore');
    	component_subscribe($$self, resScore, $$value => $$invalidate(1, $resScore = $$value));
    	validate_store(AnsList, 'AnsList');
    	component_subscribe($$self, AnsList, $$value => $$invalidate(2, $AnsList = $$value));
    	validate_store(CusList, 'CusList');
    	component_subscribe($$self, CusList, $$value => $$invalidate(3, $CusList = $$value));
    	validate_store(choice, 'choice');
    	component_subscribe($$self, choice, $$value => $$invalidate(4, $choice = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(5, $resWord = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FinishButton', slots, []);

    	function Ans() {
    		console.log($CusList); //dapan cus
    		console.log($AnsList);
    		console.log($resWord); //dapsan c
    		set_store_value(choice, $choice = 'result', $choice);
    		let d = 0;
    		let resTF = new Array($CusList.length).fill(false);

    		for (let i = 0; i < $CusList.length; i++) {
    			if ($CusList[i] == $AnsList[i]) {
    				resTF[i] = true;
    				d++;
    			}
    		}

    		resultTF.update(() => {
    			return resTF;
    		});

    		set_store_value(resScore, $resScore = d, $resScore);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$h.warn(`<FinishButton> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		CusList,
    		AnsList,
    		resWord,
    		choice,
    		resScore,
    		resultTF,
    		Ans,
    		$resScore,
    		$AnsList,
    		$CusList,
    		$choice,
    		$resWord
    	});

    	return [Ans];
    }

    class FinishButton extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FinishButton",
    			options,
    			id: create_fragment$C.name
    		});
    	}
    }

    /* srcReviving\Chars\CharsContain.svelte generated by Svelte v3.59.2 */
    const file$z = "srcReviving\\Chars\\CharsContain.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	child_ctx[8] = i;
    	return child_ctx;
    }

    // (25:4) {:else}
    function create_else_block$5(ctx) {
    	let charsback;
    	let t;
    	let charsnext;
    	let current;
    	charsback = new CharsBack({ $$inline: true });
    	charsnext = new CharsNext({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(charsback.$$.fragment);
    			t = space();
    			create_component(charsnext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charsback, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(charsnext, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charsback.$$.fragment, local);
    			transition_in(charsnext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charsback.$$.fragment, local);
    			transition_out(charsnext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charsback, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(charsnext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(25:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (23:24) 
    function create_if_block_1$5(ctx) {
    	let charsnext;
    	let current;
    	charsnext = new CharsNext({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(charsnext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charsnext, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charsnext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charsnext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charsnext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(23:24) ",
    		ctx
    	});

    	return block;
    }

    // (20:4) {#if $MaxSlide}
    function create_if_block$8(ctx) {
    	let charsback;
    	let t;
    	let finishbutton;
    	let current;
    	charsback = new CharsBack({ $$inline: true });
    	finishbutton = new FinishButton({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(charsback.$$.fragment);
    			t = space();
    			create_component(finishbutton.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charsback, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(finishbutton, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charsback.$$.fragment, local);
    			transition_in(finishbutton.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charsback.$$.fragment, local);
    			transition_out(finishbutton.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charsback, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(finishbutton, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(20:4) {#if $MaxSlide}",
    		ctx
    	});

    	return block;
    }

    // (32:12) {#each $LisEnter as element,i}
    function create_each_block$9(ctx) {
    	let charsboard;
    	let current;

    	charsboard = new CharsBoard({
    			props: {
    				words: /*$resWord*/ ctx[3][/*i*/ ctx[8]],
    				means: /*$resMean*/ ctx[4][/*i*/ ctx[8]],
    				sort: /*i*/ ctx[8]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(charsboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charsboard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const charsboard_changes = {};
    			if (dirty & /*$resWord*/ 8) charsboard_changes.words = /*$resWord*/ ctx[3][/*i*/ ctx[8]];
    			if (dirty & /*$resMean*/ 16) charsboard_changes.means = /*$resMean*/ ctx[4][/*i*/ ctx[8]];
    			charsboard.$set(charsboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charsboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charsboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charsboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(32:12) {#each $LisEnter as element,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let div2;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div1;
    	let div0;
    	let current;
    	const if_block_creators = [create_if_block$8, create_if_block_1$5, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$MaxSlide*/ ctx[0]) return 0;
    		if (/*$MinSlide*/ ctx[1]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = /*$LisEnter*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if_block.c();
    			t = space();
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "slideContain");
    			attr_dev(div0, "class", "svelte-rjdouv");
    			add_location(div0, file$z, 30, 8, 777);
    			attr_dev(div1, "id", "containCharsSlide");
    			attr_dev(div1, "class", "svelte-rjdouv");
    			add_location(div1, file$z, 29, 4, 738);
    			attr_dev(div2, "id", "containChars");
    			attr_dev(div2, "class", "svelte-rjdouv");
    			add_location(div2, file$z, 18, 0, 517);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			if_blocks[current_block_type_index].m(div2, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div2, t);
    			}

    			if (dirty & /*$resWord, $resMean, $LisEnter*/ 28) {
    				each_value = /*$LisEnter*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	let $LisEnter;
    	let $resWord;
    	let $resMean;
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(5, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(0, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(1, $MinSlide = $$value));
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(2, $LisEnter = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(3, $resWord = $$value));
    	validate_store(resMean, 'resMean');
    	component_subscribe($$self, resMean, $$value => $$invalidate(4, $resMean = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('CharsContain', slots, []);

    	onMount(() => {
    		if ($LisEnter.length == 1) {
    			set_store_value(MaxSlide, $MaxSlide = true, $MaxSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = true, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		set_store_value(onSide, $onSide = 0, $onSide);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<CharsContain> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		CharsNext,
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		resMean,
    		resWord,
    		CharsBoard,
    		onMount,
    		CharsBack,
    		FinishButton,
    		$onSide,
    		$MaxSlide,
    		$MinSlide,
    		$LisEnter,
    		$resWord,
    		$resMean
    	});

    	return [$MaxSlide, $MinSlide, $LisEnter, $resWord, $resMean];
    }

    class CharsContain extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CharsContain",
    			options,
    			id: create_fragment$B.name
    		});
    	}
    }

    /* srcReviving\ChoicesPanel\ChoicesPanel.svelte generated by Svelte v3.59.2 */

    const { console: console_1$g } = globals;
    const file$y = "srcReviving\\ChoicesPanel\\ChoicesPanel.svelte";

    function create_fragment$A(ctx) {
    	let div1;
    	let div0;
    	let button0;
    	let t1;
    	let button1;
    	let t3;
    	let button2;
    	let t5;
    	let button3;
    	let div1_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			button0 = element("button");
    			button0.textContent = "chars";
    			t1 = space();
    			button1 = element("button");
    			button1.textContent = "words/clauses";
    			t3 = space();
    			button2 = element("button");
    			button2.textContent = "meanings";
    			t5 = space();
    			button3 = element("button");
    			button3.textContent = "mix";
    			attr_dev(button0, "class", "choices svelte-1j7w0qq");
    			add_location(button0, file$y, 39, 4, 798);
    			attr_dev(button1, "class", "choices svelte-1j7w0qq");
    			add_location(button1, file$y, 40, 4, 863);
    			attr_dev(button2, "class", "choices svelte-1j7w0qq");
    			add_location(button2, file$y, 41, 4, 936);
    			attr_dev(button3, "class", "choices svelte-1j7w0qq");
    			add_location(button3, file$y, 42, 4, 1004);
    			attr_dev(div0, "id", "containeChoice");
    			attr_dev(div0, "class", "svelte-1j7w0qq");
    			add_location(div0, file$y, 38, 4, 765);
    			attr_dev(div1, "id", "choicespanel");
    			attr_dev(div1, "class", "svelte-1j7w0qq");
    			add_location(div1, file$y, 37, 0, 701);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, button0);
    			append_dev(div0, t1);
    			append_dev(div0, button1);
    			append_dev(div0, t3);
    			append_dev(div0, button2);
    			append_dev(div0, t5);
    			append_dev(div0, button3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*Chars*/ ctx[0], false, false, false, false),
    					listen_dev(button1, "click", /*Words*/ ctx[1], false, false, false, false),
    					listen_dev(button2, "click", /*Means*/ ctx[2], false, false, false, false),
    					listen_dev(button3, "click", /*Mix*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 500 }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 500 }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let $AnsList;
    	let $LisEnter;
    	let $MixRes;
    	let $choiceOpt;
    	let $choice;
    	validate_store(AnsList, 'AnsList');
    	component_subscribe($$self, AnsList, $$value => $$invalidate(4, $AnsList = $$value));
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(5, $LisEnter = $$value));
    	validate_store(MixRes, 'MixRes');
    	component_subscribe($$self, MixRes, $$value => $$invalidate(6, $MixRes = $$value));
    	validate_store(choiceOpt, 'choiceOpt');
    	component_subscribe($$self, choiceOpt, $$value => $$invalidate(7, $choiceOpt = $$value));
    	validate_store(choice, 'choice');
    	component_subscribe($$self, choice, $$value => $$invalidate(8, $choice = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ChoicesPanel', slots, []);

    	function Chars() {
    		set_store_value(choice, $choice = 'chars', $choice);
    		set_store_value(choiceOpt, $choiceOpt = 'chars', $choiceOpt);
    	}

    	function Words() {
    		set_store_value(choice, $choice = 'words', $choice);
    		set_store_value(choiceOpt, $choiceOpt = 'words', $choiceOpt);
    	}

    	function Means() {
    		set_store_value(choice, $choice = 'means', $choice);
    		set_store_value(choiceOpt, $choiceOpt = 'means', $choiceOpt);
    	}

    	function Mix() {
    		set_store_value(choice, $choice = 'mix', $choice);
    		set_store_value(choiceOpt, $choiceOpt = 'mix', $choiceOpt);
    		set_store_value(MixRes, $MixRes = [], $MixRes);

    		MixRes.update(value => {
    			for (let i = 0; i < $LisEnter.length; i++) {
    				let r = Math.floor(Math.random() * 3);
    				value.push(r);
    			}

    			console.log(value);
    			return value;
    		});

    		set_store_value(AnsList, $AnsList = [], $AnsList);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$g.warn(`<ChoicesPanel> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		AnsList,
    		LisEnter,
    		MixRes,
    		choice,
    		choiceOpt,
    		slide,
    		Chars,
    		Words,
    		Means,
    		Mix,
    		$AnsList,
    		$LisEnter,
    		$MixRes,
    		$choiceOpt,
    		$choice
    	});

    	return [Chars, Words, Means, Mix];
    }

    class ChoicesPanel extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ChoicesPanel",
    			options,
    			id: create_fragment$A.name
    		});
    	}
    }

    /* srcReviving\Means\MeansBack.svelte generated by Svelte v3.59.2 */
    const file$x = "srcReviving\\Means\\MeansBack.svelte";

    function create_fragment$z(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "back";
    			attr_dev(button, "class", "back svelte-1qlx3ib");
    			add_location(button, file$x, 18, 2, 498);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Slide*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let $LisEnter;
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(1, $LisEnter = $$value));
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(2, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(3, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(4, $MinSlide = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MeansBack', slots, []);

    	function Slide() {
    		set_store_value(onSide, $onSide--, $onSide);

    		if ($onSide == 0) {
    			set_store_value(MinSlide, $MinSlide = true, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		document.getElementById('slideContain').style.transform = "translate(" + $onSide * -100 / $LisEnter.length + "%, 0)";
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MeansBack> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		Slide,
    		$LisEnter,
    		$onSide,
    		$MaxSlide,
    		$MinSlide
    	});

    	return [Slide];
    }

    class MeansBack extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MeansBack",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* srcReviving\Means\FinishButtonMeans.svelte generated by Svelte v3.59.2 */

    const { console: console_1$f } = globals;

    const file$w = "srcReviving\\Means\\FinishButtonMeans.svelte";

    function create_fragment$y(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "done";
    			attr_dev(button, "class", "finish svelte-97zs4o");
    			add_location(button, file$w, 34, 2, 827);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Ans*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let $resScore;
    	let $AnsList;
    	let $CusList;
    	let $choice;
    	let $resWord;
    	let $LisEnter;
    	validate_store(resScore, 'resScore');
    	component_subscribe($$self, resScore, $$value => $$invalidate(1, $resScore = $$value));
    	validate_store(AnsList, 'AnsList');
    	component_subscribe($$self, AnsList, $$value => $$invalidate(2, $AnsList = $$value));
    	validate_store(CusList, 'CusList');
    	component_subscribe($$self, CusList, $$value => $$invalidate(3, $CusList = $$value));
    	validate_store(choice, 'choice');
    	component_subscribe($$self, choice, $$value => $$invalidate(4, $choice = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(5, $resWord = $$value));
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(6, $LisEnter = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FinishButtonMeans', slots, []);

    	function Ans() {
    		CusList.update(value => {
    			for (let i = 0; i < $LisEnter.length; i++) {
    				value[i] = document.getElementById('inputMeans' + `${i}`).value;
    				console.log(value);
    			}

    			return value;
    		});

    		console.log($CusList); //dapan cus
    		console.log($AnsList);
    		console.log($resWord); //dapsan c
    		set_store_value(choice, $choice = 'result', $choice);
    		let d = 0;
    		let resTF = new Array($CusList.length).fill(false);

    		for (let i = 0; i < $CusList.length; i++) {
    			if ($CusList[i] == $AnsList[i]) {
    				resTF[i] = true;
    				d++;
    			}
    		}

    		resultTF.update(() => {
    			return resTF;
    		});

    		set_store_value(resScore, $resScore = d, $resScore);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$f.warn(`<FinishButtonMeans> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		CusList,
    		AnsList,
    		resWord,
    		choice,
    		resScore,
    		resultTF,
    		LisEnter,
    		Ans,
    		$resScore,
    		$AnsList,
    		$CusList,
    		$choice,
    		$resWord,
    		$LisEnter
    	});

    	return [Ans];
    }

    class FinishButtonMeans extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FinishButtonMeans",
    			options,
    			id: create_fragment$y.name
    		});
    	}
    }

    /* srcReviving\Means\MeansNext.svelte generated by Svelte v3.59.2 */

    const { console: console_1$e } = globals;
    const file$v = "srcReviving\\Means\\MeansNext.svelte";

    function create_fragment$x(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "next";
    			attr_dev(button, "class", "next svelte-1g47150");
    			add_location(button, file$v, 19, 0, 517);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Slide*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let $LisEnter;
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(1, $LisEnter = $$value));
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(2, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(3, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(4, $MinSlide = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MeansNext', slots, []);

    	function Slide() {
    		set_store_value(onSide, $onSide++, $onSide);

    		if ($onSide == $LisEnter.length - 1) {
    			set_store_value(MaxSlide, $MaxSlide = true, $MaxSlide);
    			console.log($onSide);
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		document.getElementById('slideContain').style.transform = "translate(" + $onSide * -100 / $LisEnter.length + "%, 0)";
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$e.warn(`<MeansNext> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		Slide,
    		$LisEnter,
    		$onSide,
    		$MaxSlide,
    		$MinSlide
    	});

    	return [Slide];
    }

    class MeansNext extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MeansNext",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* srcReviving\Means\MeansBoard.svelte generated by Svelte v3.59.2 */
    const file$u = "srcReviving\\Means\\MeansBoard.svelte";

    function create_fragment$w(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let div0_id_value;
    	let t;
    	let div1;
    	let div1_id_value;
    	let div2_id_value;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "containfuture svelte-1m2h4n3");
    			attr_dev(div0, "id", div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`);
    			add_location(div0, file$u, 45, 8, 1172);
    			attr_dev(div1, "class", "containfuture svelte-1m2h4n3");
    			attr_dev(div1, "id", div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`);
    			add_location(div1, file$u, 47, 8, 1246);
    			attr_dev(div2, "class", "titleQues svelte-1m2h4n3");
    			attr_dev(div2, "id", div2_id_value = "QuesMean" + `${/*sort*/ ctx[0]}`);
    			add_location(div2, file$u, 44, 4, 1109);
    			attr_dev(div3, "class", "containMeansBoard svelte-1m2h4n3");
    			add_location(div3, file$u, 43, 0, 1070);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sort*/ 1 && div0_id_value !== (div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div0, "id", div0_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div1_id_value !== (div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div1, "id", div1_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div2_id_value !== (div2_id_value = "QuesMean" + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div2, "id", div2_id_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MeansBoard', slots, []);
    	let { words, means, sort } = $$props;
    	let finalresult;

    	onMount(() => {
    		//algorith for pick words
    		//answer
    		AnsList.update(value => {
    			return [...value, means];
    		});

    		let r = document.createElement('input');

    		r.style.cssText = `    background-color: rgb(238, 238, 238);
    width: 50%;
    border-radius: 1vh;
    font-size: 6vh;
    font-weight: bold;
    padding: 1vh;
    color:#333333;
    text-align: center;`;

    		r.id = 'inputMeans' + `${sort}`;
    		r.maxLenght = means.length;
    		r.setAttribute('autocomplete', 'off');
    		r.setAttribute('spellcheck', 'false');

    		//finalresult = `${words} (${parts}) ${r.outerHTML}`
    		// document.getElementById("QuesMean"+`${sort}`).innerHTML = finalresult
    		document.getElementById('furword' + `${sort}`).innerHTML = words;

    		document.getElementById('furmean' + `${sort}`).innerHTML = r.outerHTML;
    	});

    	$$self.$$.on_mount.push(function () {
    		if (words === undefined && !('words' in $$props || $$self.$$.bound[$$self.$$.props['words']])) {
    			console.warn("<MeansBoard> was created without expected prop 'words'");
    		}

    		if (means === undefined && !('means' in $$props || $$self.$$.bound[$$self.$$.props['means']])) {
    			console.warn("<MeansBoard> was created without expected prop 'means'");
    		}

    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console.warn("<MeansBoard> was created without expected prop 'sort'");
    		}
    	});

    	const writable_props = ['words', 'means', 'sort'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MeansBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		AnsList,
    		CusList,
    		resMean,
    		reswholekey,
    		words,
    		means,
    		sort,
    		finalresult
    	});

    	$$self.$inject_state = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    		if ('finalresult' in $$props) finalresult = $$props.finalresult;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sort, words, means];
    }

    class MeansBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, { words: 1, means: 2, sort: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MeansBoard",
    			options,
    			id: create_fragment$w.name
    		});
    	}

    	get words() {
    		throw new Error("<MeansBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set words(value) {
    		throw new Error("<MeansBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get means() {
    		throw new Error("<MeansBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set means(value) {
    		throw new Error("<MeansBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sort() {
    		throw new Error("<MeansBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<MeansBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReviving\Means\MeansContain.svelte generated by Svelte v3.59.2 */
    const file$t = "srcReviving\\Means\\MeansContain.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (27:4) {:else}
    function create_else_block$4(ctx) {
    	let meansback;
    	let t;
    	let meansnext;
    	let current;
    	meansback = new MeansBack({ $$inline: true });
    	meansnext = new MeansNext({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(meansback.$$.fragment);
    			t = space();
    			create_component(meansnext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(meansback, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(meansnext, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(meansback.$$.fragment, local);
    			transition_in(meansnext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(meansback.$$.fragment, local);
    			transition_out(meansnext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(meansback, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(meansnext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(27:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (25:24) 
    function create_if_block_1$4(ctx) {
    	let meansnext;
    	let current;
    	meansnext = new MeansNext({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(meansnext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(meansnext, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(meansnext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(meansnext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(meansnext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(25:24) ",
    		ctx
    	});

    	return block;
    }

    // (22:4) {#if $MaxSlide}
    function create_if_block$7(ctx) {
    	let meansback;
    	let t;
    	let finishbuttonmeans;
    	let current;
    	meansback = new MeansBack({ $$inline: true });
    	finishbuttonmeans = new FinishButtonMeans({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(meansback.$$.fragment);
    			t = space();
    			create_component(finishbuttonmeans.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(meansback, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(finishbuttonmeans, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(meansback.$$.fragment, local);
    			transition_in(finishbuttonmeans.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(meansback.$$.fragment, local);
    			transition_out(finishbuttonmeans.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(meansback, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(finishbuttonmeans, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(22:4) {#if $MaxSlide}",
    		ctx
    	});

    	return block;
    }

    // (34:12) {#each $LisEnter as element,i}
    function create_each_block$8(ctx) {
    	let meansboard;
    	let current;

    	meansboard = new MeansBoard({
    			props: {
    				words: /*$resWord*/ ctx[3][/*i*/ ctx[9]],
    				means: /*$resMean*/ ctx[4][/*i*/ ctx[9]],
    				sort: /*i*/ ctx[9]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(meansboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(meansboard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const meansboard_changes = {};
    			if (dirty & /*$resWord*/ 8) meansboard_changes.words = /*$resWord*/ ctx[3][/*i*/ ctx[9]];
    			if (dirty & /*$resMean*/ 16) meansboard_changes.means = /*$resMean*/ ctx[4][/*i*/ ctx[9]];
    			meansboard.$set(meansboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(meansboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(meansboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(meansboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(34:12) {#each $LisEnter as element,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let div2;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div1;
    	let div0;
    	let current;
    	const if_block_creators = [create_if_block$7, create_if_block_1$4, create_else_block$4];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$MaxSlide*/ ctx[0]) return 0;
    		if (/*$MinSlide*/ ctx[1]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = /*$LisEnter*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if_block.c();
    			t = space();
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "slideContain");
    			attr_dev(div0, "class", "svelte-16twj5p");
    			add_location(div0, file$t, 32, 8, 817);
    			attr_dev(div1, "id", "containMeansSlide");
    			attr_dev(div1, "class", "svelte-16twj5p");
    			add_location(div1, file$t, 31, 4, 778);
    			attr_dev(div2, "id", "containMeans");
    			attr_dev(div2, "class", "svelte-16twj5p");
    			add_location(div2, file$t, 20, 0, 552);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			if_blocks[current_block_type_index].m(div2, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div2, t);
    			}

    			if (dirty & /*$resWord, $resMean, $LisEnter*/ 28) {
    				each_value = /*$LisEnter*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	let $LisEnter;
    	let $AnsList;
    	let $resWord;
    	let $resMean;
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(5, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(0, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(1, $MinSlide = $$value));
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(2, $LisEnter = $$value));
    	validate_store(AnsList, 'AnsList');
    	component_subscribe($$self, AnsList, $$value => $$invalidate(6, $AnsList = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(3, $resWord = $$value));
    	validate_store(resMean, 'resMean');
    	component_subscribe($$self, resMean, $$value => $$invalidate(4, $resMean = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MeansContain', slots, []);
    	set_store_value(AnsList, $AnsList = [], $AnsList);

    	onMount(() => {
    		if ($LisEnter.length == 1) {
    			set_store_value(MaxSlide, $MaxSlide = true, $MaxSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = true, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		set_store_value(onSide, $onSide = 0, $onSide);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MeansContain> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		AnsList,
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		resMean,
    		resWord,
    		onMount,
    		MeansBack,
    		FinishButtonMeans,
    		MeansNext,
    		MeansBoard,
    		$onSide,
    		$MaxSlide,
    		$MinSlide,
    		$LisEnter,
    		$AnsList,
    		$resWord,
    		$resMean
    	});

    	return [$MaxSlide, $MinSlide, $LisEnter, $resWord, $resMean];
    }

    class MeansContain extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MeansContain",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* srcReviving\Mix\MixBack.svelte generated by Svelte v3.59.2 */
    const file$s = "srcReviving\\Mix\\MixBack.svelte";

    function create_fragment$u(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "back";
    			attr_dev(button, "class", "back svelte-137dgon");
    			add_location(button, file$s, 18, 2, 498);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Slide*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let $LisEnter;
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(1, $LisEnter = $$value));
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(2, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(3, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(4, $MinSlide = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MixBack', slots, []);

    	function Slide() {
    		set_store_value(onSide, $onSide--, $onSide);

    		if ($onSide == 0) {
    			set_store_value(MinSlide, $MinSlide = true, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		document.getElementById('slideContain').style.transform = "translate(" + $onSide * -100 / $LisEnter.length + "%, 0)";
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MixBack> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		Slide,
    		$LisEnter,
    		$onSide,
    		$MaxSlide,
    		$MinSlide
    	});

    	return [Slide];
    }

    class MixBack extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MixBack",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* srcReviving\Mix\FinishButtonMix.svelte generated by Svelte v3.59.2 */

    const { console: console_1$d } = globals;

    const file$r = "srcReviving\\Mix\\FinishButtonMix.svelte";

    function create_fragment$t(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "done";
    			attr_dev(button, "class", "finish svelte-1ik6ap4");
    			add_location(button, file$r, 40, 2, 961);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Ans*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let $resScore;
    	let $AnsList;
    	let $CusList;
    	let $choice;
    	let $resWord;
    	let $MixRes;
    	let $LisEnter;
    	validate_store(resScore, 'resScore');
    	component_subscribe($$self, resScore, $$value => $$invalidate(1, $resScore = $$value));
    	validate_store(AnsList, 'AnsList');
    	component_subscribe($$self, AnsList, $$value => $$invalidate(2, $AnsList = $$value));
    	validate_store(CusList, 'CusList');
    	component_subscribe($$self, CusList, $$value => $$invalidate(3, $CusList = $$value));
    	validate_store(choice, 'choice');
    	component_subscribe($$self, choice, $$value => $$invalidate(4, $choice = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(5, $resWord = $$value));
    	validate_store(MixRes, 'MixRes');
    	component_subscribe($$self, MixRes, $$value => $$invalidate(6, $MixRes = $$value));
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(7, $LisEnter = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FinishButtonMix', slots, []);

    	function Ans() {
    		CusList.update(value => {
    			console.log(value, "value");

    			for (let i = 0; i < $LisEnter.length; i++) {
    				if ($MixRes[i] != 0) {
    					value[i] = document.getElementById('inputMixs' + `${i}`).value;
    				}
    			}

    			return value;
    		});

    		console.log($CusList); //dapan cus
    		console.log($resWord); //dapsan c
    		set_store_value(choice, $choice = 'result', $choice);
    		let d = 0;
    		let resTF = new Array($CusList.length).fill(false);

    		for (let i = 0; i < $CusList.length; i++) {
    			console.log($CusList[i], ":::::", $AnsList[i]);

    			if ($CusList[i] == $AnsList[i]) {
    				resTF[i] = true;
    				d++;
    			}
    		}

    		resultTF.update(() => {
    			return resTF;
    		});

    		set_store_value(resScore, $resScore = d, $resScore);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$d.warn(`<FinishButtonMix> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		CusList,
    		AnsList,
    		resWord,
    		choice,
    		resScore,
    		resultTF,
    		LisEnter,
    		choiceOpt,
    		MixRes,
    		Ans,
    		$resScore,
    		$AnsList,
    		$CusList,
    		$choice,
    		$resWord,
    		$MixRes,
    		$LisEnter
    	});

    	return [Ans];
    }

    class FinishButtonMix extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FinishButtonMix",
    			options,
    			id: create_fragment$t.name
    		});
    	}
    }

    /* srcReviving\Mix\MixNext.svelte generated by Svelte v3.59.2 */

    const { console: console_1$c } = globals;
    const file$q = "srcReviving\\Mix\\MixNext.svelte";

    function create_fragment$s(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "next";
    			attr_dev(button, "class", "next svelte-69hwns");
    			add_location(button, file$q, 19, 0, 517);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Slide*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $LisEnter;
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(1, $LisEnter = $$value));
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(2, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(3, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(4, $MinSlide = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MixNext', slots, []);

    	function Slide() {
    		set_store_value(onSide, $onSide++, $onSide);

    		if ($onSide == $LisEnter.length - 1) {
    			set_store_value(MaxSlide, $MaxSlide = true, $MaxSlide);
    			console.log($onSide);
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		document.getElementById('slideContain').style.transform = "translate(" + $onSide * -100 / $LisEnter.length + "%, 0)";
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$c.warn(`<MixNext> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		Slide,
    		$LisEnter,
    		$onSide,
    		$MaxSlide,
    		$MinSlide
    	});

    	return [Slide];
    }

    class MixNext extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MixNext",
    			options,
    			id: create_fragment$s.name
    		});
    	}
    }

    /* srcReviving\Mix\MKeyBoard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$b } = globals;
    const file$p = "srcReviving\\Mix\\MKeyBoard.svelte";

    function create_fragment$r(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let div0_id_value;
    	let t;
    	let div1;
    	let div1_id_value;
    	let div2_id_value;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "containfuture svelte-1i7y2eq");
    			attr_dev(div0, "id", div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`);
    			add_location(div0, file$p, 139, 4, 4057);
    			attr_dev(div1, "class", "containfuture svelte-1i7y2eq");
    			attr_dev(div1, "id", div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`);
    			add_location(div1, file$p, 141, 4, 4129);
    			attr_dev(div2, "class", "titleQues svelte-1i7y2eq");
    			attr_dev(div2, "id", div2_id_value = "QuesMix" + `${/*sort*/ ctx[0]}`);
    			add_location(div2, file$p, 137, 6, 3997);
    			attr_dev(div3, "class", "containMixsBoard svelte-1i7y2eq");
    			add_location(div3, file$p, 136, 2, 3957);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sort*/ 1 && div0_id_value !== (div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div0, "id", div0_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div1_id_value !== (div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div1, "id", div1_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div2_id_value !== (div2_id_value = "QuesMix" + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div2, "id", div2_id_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MKeyBoard', slots, []);
    	let { words, means, sort } = $$props;
    	let finalresult;

    	onMount(() => {
    		//algorith for pick key words
    		let lenghtmax = words.length;

    		let n = Math.floor(Math.random() * Math.round(lenghtmax / 2) + 1); //length:2, randomize 1 to n/2 find hidding numbers
    		let L = new Array(n).fill('');
    		let A = new Array(lenghtmax).fill(false);
    		let W = words.split('');

    		for (let i = 0; i < n; i++) {
    			let l = Math.floor(Math.random() * (lenghtmax - 1));

    			while (A[l]) {
    				l = Math.floor(Math.random() * (lenghtmax - 1));
    			}

    			A[l] = true;

    			//     W[l] = `<input style = "padding: 1vh;
    			// background-color: #eee;
    			// width: 5vh;
    			// text-align: center;
    			// border-radius: 1vh;
    			// font-size: 6vh;
    			// font-weight: bold;" maxlength="1" id="QuesMix${sort}input${i}">`
    			W[l] = document.createElement('input');

    			W[l].style.cssText = `    width: 5vh;
    text-align: center;
    font-size: 6vh;
    height: 7vh;
    font-weight: bold;
    font-family: monospace;
    position: relative;
    border: 0px;
    background-color:#eeeeee;
    color:#333333;
    margin-inline: 0.2vh;
   
    border-radius: 1.5vh;
    transition:0.2s ease-in`;

    			W[l].maxLength = 1;
    			W[l].setAttribute('spellcheck', 'false');
    			W[l].setAttribute('autocomplete', 'off');
    		}

    		//     W = W.map(item => {
    		//     if (item instanceof HTMLElement) {
    		//         return item.outerHTML; // Convert the input element to its HTML representation
    		//     } else {
    		//         return item; // For other elements, just return them as is
    		//     }
    		// }).join("")
    		let d = 0;

    		for (let i = 0; i < W.length; i++) {
    			if (W[i] instanceof HTMLElement) {
    				L[d] = i;
    				W[i].id = `QuesMix${sort}input${d}`;
    				W[i] = W[i].outerHTML;
    				d++;
    			}
    		}

    		AnsList.update(value => {
    			//Daps Ans
    			return [...value, words];
    		});

    		W = W.join('');
    		console.log(W);

    		// finalresult = W + " ("+parts+") "+means
    		//document.getElementById("QuesMix"+`${sort}`).innerHTML = finalresult
    		document.getElementById('furword' + `${sort}`).innerHTML = W;

    		document.getElementById('furmean' + `${sort}`).innerHTML = means;
    		let CusAns = new Array(n).fill("");
    		let whole = words.split('');

    		for (let i = 0; i < n; i++) {
    			let p = document.getElementById(`QuesMix${sort}input${i}`);

    			p.addEventListener("focus", function () {
    				this.style.backgroundColor = '#1d1d1d';
    				this.style.color = '#fefefe';
    			});

    			p.addEventListener("blur", function () {
    				this.style.backgroundColor = '#eeeeee';
    				this.style.color = '#1d1d1d';
    			});

    			p.addEventListener("mouseout", function () {
    				this.style.backgroundColor = '#eeeeee';
    				this.style.color = '#1d1d1d';
    			});

    			p.addEventListener("mouseover", function () {
    				this.style.backgroundColor = '#535353';
    				this.style.color = '#eeeeee';
    			});

    			p.addEventListener('input', () => {
    				CusAns[i] = p.value;
    				whole[L[i]] = p.value;

    				CusList.update(value => {
    					value[sort] = whole.join('');
    					return value;
    				});

    				if (p.value.length == 1) {
    					if (i != n - 1) {
    						console.log("d------", d);
    						document.getElementById(`QuesMix${sort}input${i + 1}`).focus();
    					}
    				}
    			});
    		}
    	});

    	$$self.$$.on_mount.push(function () {
    		if (words === undefined && !('words' in $$props || $$self.$$.bound[$$self.$$.props['words']])) {
    			console_1$b.warn("<MKeyBoard> was created without expected prop 'words'");
    		}

    		if (means === undefined && !('means' in $$props || $$self.$$.bound[$$self.$$.props['means']])) {
    			console_1$b.warn("<MKeyBoard> was created without expected prop 'means'");
    		}

    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console_1$b.warn("<MKeyBoard> was created without expected prop 'sort'");
    		}
    	});

    	const writable_props = ['words', 'means', 'sort'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$b.warn(`<MKeyBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		AnsList,
    		CusList,
    		resWord,
    		reswholekey,
    		words,
    		means,
    		sort,
    		finalresult
    	});

    	$$self.$inject_state = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    		if ('finalresult' in $$props) finalresult = $$props.finalresult;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sort, words, means];
    }

    class MKeyBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, { words: 1, means: 2, sort: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MKeyBoard",
    			options,
    			id: create_fragment$r.name
    		});
    	}

    	get words() {
    		throw new Error("<MKeyBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set words(value) {
    		throw new Error("<MKeyBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get means() {
    		throw new Error("<MKeyBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set means(value) {
    		throw new Error("<MKeyBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sort() {
    		throw new Error("<MKeyBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<MKeyBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReviving\Mix\MWordBoard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$a } = globals;
    const file$o = "srcReviving\\Mix\\MWordBoard.svelte";

    function create_fragment$q(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let div0_id_value;
    	let t;
    	let div1;
    	let div1_id_value;
    	let div2_id_value;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "containfuture svelte-4uvssx");
    			attr_dev(div0, "id", div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`);
    			add_location(div0, file$o, 45, 8, 1228);
    			attr_dev(div1, "class", "containfuture svelte-4uvssx");
    			attr_dev(div1, "id", div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`);
    			add_location(div1, file$o, 47, 8, 1307);
    			attr_dev(div2, "class", "titleQues svelte-4uvssx");
    			attr_dev(div2, "id", div2_id_value = "QuesMix" + `${/*sort*/ ctx[0]}`);
    			add_location(div2, file$o, 44, 6, 1166);
    			attr_dev(div3, "class", "containMixsBoard svelte-4uvssx");
    			add_location(div3, file$o, 43, 2, 1126);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sort*/ 1 && div0_id_value !== (div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div0, "id", div0_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div1_id_value !== (div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div1, "id", div1_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div2_id_value !== (div2_id_value = "QuesMix" + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div2, "id", div2_id_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props, $$invalidate) {
    	let $CusList;
    	validate_store(CusList, 'CusList');
    	component_subscribe($$self, CusList, $$value => $$invalidate(3, $CusList = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MWordBoard', slots, []);
    	let { words, means, sort } = $$props;
    	let finalresult;

    	onMount(() => {
    		console.log($CusList);

    		//algorith for pick words
    		//answer
    		AnsList.update(value => {
    			return [...value, words];
    		});

    		let r = document.createElement('input');

    		r.style.cssText = `background-color: rgb(238, 238, 238);
    width: 50%;
    border-radius: 1vh;
    font-size: 6vh;
    font-weight: bold;
    padding: 1vh;
    color:#333333;
    text-align: center;`;

    		r.id = 'inputMixs' + `${sort}`;
    		r.maxLenght = words.length;
    		r.setAttribute('autocomplete', 'off');
    		r.setAttribute('spellcheck', 'false');

    		// finalresult = `${r.outerHTML} (${parts}) ${means}`
    		// document.getElementById("QuesMix"+`${sort}`).innerHTML = finalresult
    		document.getElementById('furword' + `${sort}`).innerHTML = r.outerHTML;

    		document.getElementById('furmean' + `${sort}`).innerHTML = means;
    	});

    	$$self.$$.on_mount.push(function () {
    		if (words === undefined && !('words' in $$props || $$self.$$.bound[$$self.$$.props['words']])) {
    			console_1$a.warn("<MWordBoard> was created without expected prop 'words'");
    		}

    		if (means === undefined && !('means' in $$props || $$self.$$.bound[$$self.$$.props['means']])) {
    			console_1$a.warn("<MWordBoard> was created without expected prop 'means'");
    		}

    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console_1$a.warn("<MWordBoard> was created without expected prop 'sort'");
    		}
    	});

    	const writable_props = ['words', 'means', 'sort'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$a.warn(`<MWordBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		AnsList,
    		CusList,
    		words,
    		means,
    		sort,
    		finalresult,
    		$CusList
    	});

    	$$self.$inject_state = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    		if ('finalresult' in $$props) finalresult = $$props.finalresult;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sort, words, means];
    }

    class MWordBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, { words: 1, means: 2, sort: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MWordBoard",
    			options,
    			id: create_fragment$q.name
    		});
    	}

    	get words() {
    		throw new Error("<MWordBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set words(value) {
    		throw new Error("<MWordBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get means() {
    		throw new Error("<MWordBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set means(value) {
    		throw new Error("<MWordBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sort() {
    		throw new Error("<MWordBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<MWordBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReviving\Mix\MMeanBoard.svelte generated by Svelte v3.59.2 */
    const file$n = "srcReviving\\Mix\\MMeanBoard.svelte";

    function create_fragment$p(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let div0_id_value;
    	let t;
    	let div1;
    	let div1_id_value;
    	let div2_id_value;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "containfuture svelte-4363ea");
    			attr_dev(div0, "id", div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`);
    			add_location(div0, file$n, 44, 8, 1229);
    			attr_dev(div1, "class", "containfuture svelte-4363ea");
    			attr_dev(div1, "id", div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`);
    			add_location(div1, file$n, 46, 8, 1310);
    			attr_dev(div2, "class", "titleQues svelte-4363ea");
    			attr_dev(div2, "id", div2_id_value = "QuesMix" + `${/*sort*/ ctx[0]}`);
    			add_location(div2, file$n, 43, 6, 1167);
    			attr_dev(div3, "class", "containMixsBoard svelte-4363ea");
    			add_location(div3, file$n, 42, 2, 1127);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sort*/ 1 && div0_id_value !== (div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div0, "id", div0_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div1_id_value !== (div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div1, "id", div1_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div2_id_value !== (div2_id_value = "QuesMix" + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div2, "id", div2_id_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MMeanBoard', slots, []);
    	let { words, means, sort } = $$props;
    	let finalresult;

    	onMount(() => {
    		//algorith for pick words
    		//answer
    		AnsList.update(value => {
    			return [...value, means];
    		});

    		let r = document.createElement('input');

    		r.style.cssText = `background-color: rgb(238, 238, 238);
    width: 50%;
    border-radius: 1vh;
    font-size: 6vh;
    font-weight: bold;
    padding: 1vh;
    color:#333333;
    text-align: center;`;

    		r.id = 'inputMixs' + `${sort}`;
    		r.maxLenght = means.length;
    		r.setAttribute('autocomplete', 'off');
    		r.setAttribute('spellcheck', 'false');

    		//finalresult = `${words} (${parts}) ${r.outerHTML}`
    		//document.getElementById("QuesMix"+`${sort}`).innerHTML = finalresult
    		document.getElementById('furword' + `${sort}`).innerHTML = words;

    		document.getElementById('furmean' + `${sort}`).innerHTML = r.outerHTML;
    	});

    	$$self.$$.on_mount.push(function () {
    		if (words === undefined && !('words' in $$props || $$self.$$.bound[$$self.$$.props['words']])) {
    			console.warn("<MMeanBoard> was created without expected prop 'words'");
    		}

    		if (means === undefined && !('means' in $$props || $$self.$$.bound[$$self.$$.props['means']])) {
    			console.warn("<MMeanBoard> was created without expected prop 'means'");
    		}

    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console.warn("<MMeanBoard> was created without expected prop 'sort'");
    		}
    	});

    	const writable_props = ['words', 'means', 'sort'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MMeanBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		AnsList,
    		CusList,
    		resMean,
    		reswholekey,
    		words,
    		means,
    		sort,
    		finalresult
    	});

    	$$self.$inject_state = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    		if ('finalresult' in $$props) finalresult = $$props.finalresult;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sort, words, means];
    }

    class MMeanBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { words: 1, means: 2, sort: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MMeanBoard",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get words() {
    		throw new Error("<MMeanBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set words(value) {
    		throw new Error("<MMeanBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get means() {
    		throw new Error("<MMeanBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set means(value) {
    		throw new Error("<MMeanBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sort() {
    		throw new Error("<MMeanBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<MMeanBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReviving\Mix\MixContain.svelte generated by Svelte v3.59.2 */

    const { console: console_1$9 } = globals;
    const file$m = "srcReviving\\Mix\\MixContain.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	child_ctx[11] = i;
    	return child_ctx;
    }

    // (31:4) {:else}
    function create_else_block$3(ctx) {
    	let mixback;
    	let t;
    	let mixnext;
    	let current;
    	mixback = new MixBack({ $$inline: true });
    	mixnext = new MixNext({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(mixback.$$.fragment);
    			t = space();
    			create_component(mixnext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mixback, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(mixnext, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mixback.$$.fragment, local);
    			transition_in(mixnext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mixback.$$.fragment, local);
    			transition_out(mixnext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mixback, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(mixnext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(31:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (29:24) 
    function create_if_block_4$1(ctx) {
    	let mixnext;
    	let current;
    	mixnext = new MixNext({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(mixnext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mixnext, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mixnext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mixnext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mixnext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(29:24) ",
    		ctx
    	});

    	return block;
    }

    // (26:4) {#if $MaxSlide}
    function create_if_block_3$1(ctx) {
    	let mixback;
    	let t;
    	let finishbuttonmix;
    	let current;
    	mixback = new MixBack({ $$inline: true });
    	finishbuttonmix = new FinishButtonMix({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(mixback.$$.fragment);
    			t = space();
    			create_component(finishbuttonmix.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mixback, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(finishbuttonmix, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mixback.$$.fragment, local);
    			transition_in(finishbuttonmix.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mixback.$$.fragment, local);
    			transition_out(finishbuttonmix.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mixback, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(finishbuttonmix, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(26:4) {#if $MaxSlide}",
    		ctx
    	});

    	return block;
    }

    // (43:42) 
    function create_if_block_2$2(ctx) {
    	let mmeanboard;
    	let current;

    	mmeanboard = new MMeanBoard({
    			props: {
    				words: /*$resWord*/ ctx[3][/*i*/ ctx[11]],
    				means: /*$resMean*/ ctx[4][/*i*/ ctx[11]],
    				sort: /*i*/ ctx[11]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mmeanboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mmeanboard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mmeanboard_changes = {};
    			if (dirty & /*$resWord*/ 8) mmeanboard_changes.words = /*$resWord*/ ctx[3][/*i*/ ctx[11]];
    			if (dirty & /*$resMean*/ 16) mmeanboard_changes.means = /*$resMean*/ ctx[4][/*i*/ ctx[11]];
    			mmeanboard.$set(mmeanboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mmeanboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mmeanboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mmeanboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(43:42) ",
    		ctx
    	});

    	return block;
    }

    // (41:42) 
    function create_if_block_1$3(ctx) {
    	let mwordboard;
    	let current;

    	mwordboard = new MWordBoard({
    			props: {
    				words: /*$resWord*/ ctx[3][/*i*/ ctx[11]],
    				means: /*$resMean*/ ctx[4][/*i*/ ctx[11]],
    				sort: /*i*/ ctx[11]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mwordboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mwordboard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mwordboard_changes = {};
    			if (dirty & /*$resWord*/ 8) mwordboard_changes.words = /*$resWord*/ ctx[3][/*i*/ ctx[11]];
    			if (dirty & /*$resMean*/ 16) mwordboard_changes.means = /*$resMean*/ ctx[4][/*i*/ ctx[11]];
    			mwordboard.$set(mwordboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mwordboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mwordboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mwordboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(41:42) ",
    		ctx
    	});

    	return block;
    }

    // (39:16) {#if $MixRes[i] == 0}
    function create_if_block$6(ctx) {
    	let mkeyboard;
    	let current;

    	mkeyboard = new MKeyBoard({
    			props: {
    				words: /*$resWord*/ ctx[3][/*i*/ ctx[11]],
    				means: /*$resMean*/ ctx[4][/*i*/ ctx[11]],
    				sort: /*i*/ ctx[11]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(mkeyboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mkeyboard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const mkeyboard_changes = {};
    			if (dirty & /*$resWord*/ 8) mkeyboard_changes.words = /*$resWord*/ ctx[3][/*i*/ ctx[11]];
    			if (dirty & /*$resMean*/ 16) mkeyboard_changes.means = /*$resMean*/ ctx[4][/*i*/ ctx[11]];
    			mkeyboard.$set(mkeyboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mkeyboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mkeyboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mkeyboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(39:16) {#if $MixRes[i] == 0}",
    		ctx
    	});

    	return block;
    }

    // (38:12) {#each $MixRes as element,i}
    function create_each_block$7(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$6, create_if_block_1$3, create_if_block_2$2];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*$MixRes*/ ctx[2][/*i*/ ctx[11]] == 0) return 0;
    		if (/*$MixRes*/ ctx[2][/*i*/ ctx[11]] == 1) return 1;
    		if (/*$MixRes*/ ctx[2][/*i*/ ctx[11]] == 2) return 2;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type_1(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(target, anchor);
    			}

    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					} else {
    						if_block.p(ctx, dirty);
    					}

    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(38:12) {#each $MixRes as element,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let div2;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div1;
    	let div0;
    	let current;
    	const if_block_creators = [create_if_block_3$1, create_if_block_4$1, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$MaxSlide*/ ctx[0]) return 0;
    		if (/*$MinSlide*/ ctx[1]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = /*$MixRes*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if_block.c();
    			t = space();
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "slideContain");
    			attr_dev(div0, "class", "svelte-1pv1e2n");
    			add_location(div0, file$m, 36, 8, 936);
    			attr_dev(div1, "id", "containMixsSlide");
    			attr_dev(div1, "class", "svelte-1pv1e2n");
    			add_location(div1, file$m, 35, 4, 898);
    			attr_dev(div2, "id", "containMixs");
    			attr_dev(div2, "class", "svelte-1pv1e2n");
    			add_location(div2, file$m, 24, 0, 683);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			if_blocks[current_block_type_index].m(div2, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div2, t);
    			}

    			if (dirty & /*$resWord, $resMean, $MixRes*/ 28) {
    				each_value = /*$MixRes*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $CusList;
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	let $LisEnter;
    	let $AnsList;
    	let $MixRes;
    	let $resWord;
    	let $resMean;
    	validate_store(CusList, 'CusList');
    	component_subscribe($$self, CusList, $$value => $$invalidate(5, $CusList = $$value));
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(6, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(0, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(1, $MinSlide = $$value));
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(7, $LisEnter = $$value));
    	validate_store(AnsList, 'AnsList');
    	component_subscribe($$self, AnsList, $$value => $$invalidate(8, $AnsList = $$value));
    	validate_store(MixRes, 'MixRes');
    	component_subscribe($$self, MixRes, $$value => $$invalidate(2, $MixRes = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(3, $resWord = $$value));
    	validate_store(resMean, 'resMean');
    	component_subscribe($$self, resMean, $$value => $$invalidate(4, $resMean = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MixContain', slots, []);
    	set_store_value(AnsList, $AnsList = [], $AnsList);

    	onMount(() => {
    		if ($LisEnter.length == 1) {
    			set_store_value(MaxSlide, $MaxSlide = true, $MaxSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = true, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		set_store_value(onSide, $onSide = 0, $onSide);
    		console.log($CusList);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$9.warn(`<MixContain> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		AnsList,
    		CusList,
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		MixRes,
    		onSide,
    		resMean,
    		resWord,
    		onMount,
    		MixBack,
    		FinishButtonMix,
    		MixNext,
    		MKeyBoard,
    		MWordBoard,
    		MMeanBoard,
    		$CusList,
    		$onSide,
    		$MaxSlide,
    		$MinSlide,
    		$LisEnter,
    		$AnsList,
    		$MixRes,
    		$resWord,
    		$resMean
    	});

    	return [$MaxSlide, $MinSlide, $MixRes, $resWord, $resMean];
    }

    class MixContain extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MixContain",
    			options,
    			id: create_fragment$o.name
    		});
    	}
    }

    /* srcReviving\Result\AnsBoard.svelte generated by Svelte v3.59.2 */
    const file$l = "srcReviving\\Result\\AnsBoard.svelte";

    // (23:8) {:else }
    function create_else_block$2(ctx) {
    	let div;
    	let t_value = /*$CusList*/ ctx[6][/*sort*/ ctx[0]] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "truefalse svelte-1x79st9");
    			set_style(div, "background-color", /*color*/ ctx[1]);
    			add_location(div, file$l, 23, 8, 772);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$CusList, sort*/ 65 && t_value !== (t_value = /*$CusList*/ ctx[6][/*sort*/ ctx[0]] + "")) set_data_dev(t, t_value);

    			if (dirty & /*color*/ 2) {
    				set_style(div, "background-color", /*color*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(23:8) {:else }",
    		ctx
    	});

    	return block;
    }

    // (21:8) {#if $choiceOpt == 'chars'}
    function create_if_block$5(ctx) {
    	let div;
    	let t_value = /*$reswholekey*/ ctx[5][/*sort*/ ctx[0]] + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "truefalse svelte-1x79st9");
    			set_style(div, "background-color", /*color*/ ctx[1]);
    			add_location(div, file$l, 21, 8, 660);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$reswholekey, sort*/ 33 && t_value !== (t_value = /*$reswholekey*/ ctx[5][/*sort*/ ctx[0]] + "")) set_data_dev(t, t_value);

    			if (dirty & /*color*/ 2) {
    				set_style(div, "background-color", /*color*/ ctx[1]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(21:8) {#if $choiceOpt == 'chars'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let div3;
    	let div0;
    	let t0_value = /*$resWord*/ ctx[2][/*sort*/ ctx[0]] + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = /*$resMean*/ ctx[3][/*sort*/ ctx[0]] + "";
    	let t2;
    	let t3;
    	let div2;
    	let div2_intro;
    	let div3_intro;

    	function select_block_type(ctx, dirty) {
    		if (/*$choiceOpt*/ ctx[4] == 'chars') return create_if_block$5;
    		return create_else_block$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div2 = element("div");
    			if_block.c();
    			attr_dev(div0, "class", "ansWords svelte-1x79st9");
    			add_location(div0, file$l, 16, 4, 457);
    			attr_dev(div1, "class", "ansMeans svelte-1x79st9");
    			add_location(div1, file$l, 18, 4, 511);
    			attr_dev(div2, "class", "yourAns svelte-1x79st9");
    			add_location(div2, file$l, 19, 4, 563);
    			attr_dev(div3, "class", "ansboard svelte-1x79st9");
    			add_location(div3, file$l, 15, 0, 400);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, t0);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, t2);
    			append_dev(div3, t3);
    			append_dev(div3, div2);
    			if_block.m(div2, null);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$resWord, sort*/ 5 && t0_value !== (t0_value = /*$resWord*/ ctx[2][/*sort*/ ctx[0]] + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*$resMean, sort*/ 9 && t2_value !== (t2_value = /*$resMean*/ ctx[3][/*sort*/ ctx[0]] + "")) set_data_dev(t2, t2_value);

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div2, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (!div2_intro) {
    				add_render_callback(() => {
    					div2_intro = create_in_transition(div2, blur, { duration: 1000 });
    					div2_intro.start();
    				});
    			}

    			if (!div3_intro) {
    				add_render_callback(() => {
    					div3_intro = create_in_transition(div3, slide, { duration: 1000 });
    					div3_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $resultTF;
    	let $resWord;
    	let $resMean;
    	let $choiceOpt;
    	let $reswholekey;
    	let $CusList;
    	validate_store(resultTF, 'resultTF');
    	component_subscribe($$self, resultTF, $$value => $$invalidate(7, $resultTF = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(2, $resWord = $$value));
    	validate_store(resMean, 'resMean');
    	component_subscribe($$self, resMean, $$value => $$invalidate(3, $resMean = $$value));
    	validate_store(choiceOpt, 'choiceOpt');
    	component_subscribe($$self, choiceOpt, $$value => $$invalidate(4, $choiceOpt = $$value));
    	validate_store(reswholekey, 'reswholekey');
    	component_subscribe($$self, reswholekey, $$value => $$invalidate(5, $reswholekey = $$value));
    	validate_store(CusList, 'CusList');
    	component_subscribe($$self, CusList, $$value => $$invalidate(6, $CusList = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('AnsBoard', slots, []);
    	let { sort } = $$props;
    	let color;

    	onMount(() => {
    		if ($resultTF[sort]) {
    			$$invalidate(1, color = '#139487');
    		} else {
    			$$invalidate(1, color = '#ff6464');
    		}
    	});

    	$$self.$$.on_mount.push(function () {
    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console.warn("<AnsBoard> was created without expected prop 'sort'");
    		}
    	});

    	const writable_props = ['sort'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<AnsBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		choice,
    		resWord,
    		resMean,
    		CusList,
    		reswholekey,
    		resultTF,
    		choiceOpt,
    		slide,
    		blur,
    		sort,
    		color,
    		$resultTF,
    		$resWord,
    		$resMean,
    		$choiceOpt,
    		$reswholekey,
    		$CusList
    	});

    	$$self.$inject_state = $$props => {
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    		if ('color' in $$props) $$invalidate(1, color = $$props.color);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sort, color, $resWord, $resMean, $choiceOpt, $reswholekey, $CusList];
    }

    class AnsBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { sort: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "AnsBoard",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get sort() {
    		throw new Error("<AnsBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<AnsBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReviving\Result\ResultContain.svelte generated by Svelte v3.59.2 */
    const file$k = "srcReviving\\Result\\ResultContain.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	child_ctx[4] = i;
    	return child_ctx;
    }

    // (17:8) {#each $LisEnter as element,i}
    function create_each_block$6(ctx) {
    	let ansboard;
    	let current;

    	ansboard = new AnsBoard({
    			props: { sort: /*i*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(ansboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(ansboard, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ansboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ansboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(ansboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(17:8) {#each $LisEnter as element,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div7;
    	let div1;
    	let div0;
    	let t0;
    	let t1;
    	let t2_value = /*$LisEnter*/ ctx[1].length + "";
    	let t2;
    	let t3;
    	let div5;
    	let div2;
    	let t5;
    	let div3;
    	let t7;
    	let div4;
    	let t9;
    	let div6;
    	let current;
    	let each_value = /*$LisEnter*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div7 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(/*$resScore*/ ctx[0]);
    			t1 = text(" of ");
    			t2 = text(t2_value);
    			t3 = space();
    			div5 = element("div");
    			div2 = element("div");
    			div2.textContent = "WORDS/CLAUSES";
    			t5 = space();
    			div3 = element("div");
    			div3.textContent = "MEANINGS";
    			t7 = space();
    			div4 = element("div");
    			div4.textContent = "YOUR ANSWER";
    			t9 = space();
    			div6 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "score");
    			attr_dev(div0, "class", "svelte-830yll");
    			add_location(div0, file$k, 7, 8, 180);
    			attr_dev(div1, "id", "statusContain");
    			attr_dev(div1, "class", "svelte-830yll");
    			add_location(div1, file$k, 6, 4, 145);
    			attr_dev(div2, "class", "restile svelte-830yll");
    			add_location(div2, file$k, 11, 8, 295);
    			attr_dev(div3, "class", "restile svelte-830yll");
    			add_location(div3, file$k, 12, 8, 347);
    			attr_dev(div4, "class", "restile svelte-830yll");
    			add_location(div4, file$k, 13, 8, 394);
    			attr_dev(div5, "id", "resTiltle");
    			attr_dev(div5, "class", "svelte-830yll");
    			add_location(div5, file$k, 10, 4, 263);
    			attr_dev(div6, "id", "resContain");
    			attr_dev(div6, "class", "svelte-830yll");
    			add_location(div6, file$k, 15, 4, 452);
    			attr_dev(div7, "id", "bigContain");
    			attr_dev(div7, "class", "svelte-830yll");
    			add_location(div7, file$k, 5, 0, 116);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div7, anchor);
    			append_dev(div7, div1);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div0, t1);
    			append_dev(div0, t2);
    			append_dev(div7, t3);
    			append_dev(div7, div5);
    			append_dev(div5, div2);
    			append_dev(div5, t5);
    			append_dev(div5, div3);
    			append_dev(div5, t7);
    			append_dev(div5, div4);
    			append_dev(div7, t9);
    			append_dev(div7, div6);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div6, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$resScore*/ 1) set_data_dev(t0, /*$resScore*/ ctx[0]);
    			if ((!current || dirty & /*$LisEnter*/ 2) && t2_value !== (t2_value = /*$LisEnter*/ ctx[1].length + "")) set_data_dev(t2, t2_value);

    			if (dirty & /*$LisEnter*/ 2) {
    				each_value = /*$LisEnter*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$6(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$6(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div6, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div7);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $resScore;
    	let $LisEnter;
    	validate_store(resScore, 'resScore');
    	component_subscribe($$self, resScore, $$value => $$invalidate(0, $resScore = $$value));
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(1, $LisEnter = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ResultContain', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ResultContain> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LisEnter,
    		resScore,
    		AnsBoard,
    		$resScore,
    		$LisEnter
    	});

    	return [$resScore, $LisEnter];
    }

    class ResultContain extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ResultContain",
    			options,
    			id: create_fragment$m.name
    		});
    	}
    }

    /* srcReviving\Words\WordsBack.svelte generated by Svelte v3.59.2 */
    const file$j = "srcReviving\\Words\\WordsBack.svelte";

    function create_fragment$l(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "back";
    			attr_dev(button, "class", "back svelte-o6eikp");
    			add_location(button, file$j, 18, 2, 498);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Slide*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let $LisEnter;
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(1, $LisEnter = $$value));
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(2, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(3, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(4, $MinSlide = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WordsBack', slots, []);

    	function Slide() {
    		set_store_value(onSide, $onSide--, $onSide);

    		if ($onSide == 0) {
    			set_store_value(MinSlide, $MinSlide = true, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		document.getElementById('slideContain').style.transform = "translate(" + $onSide * -100 / $LisEnter.length + "%, 0)";
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WordsBack> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		Slide,
    		$LisEnter,
    		$onSide,
    		$MaxSlide,
    		$MinSlide
    	});

    	return [Slide];
    }

    class WordsBack extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WordsBack",
    			options,
    			id: create_fragment$l.name
    		});
    	}
    }

    /* srcReviving\Words\FinishButtonWords.svelte generated by Svelte v3.59.2 */

    const { console: console_1$8 } = globals;

    const file$i = "srcReviving\\Words\\FinishButtonWords.svelte";

    function create_fragment$k(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "done";
    			attr_dev(button, "class", "finish svelte-1ik6ap4");
    			add_location(button, file$i, 33, 2, 818);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Ans*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $resScore;
    	let $AnsList;
    	let $CusList;
    	let $choice;
    	let $resWord;
    	let $LisEnter;
    	validate_store(resScore, 'resScore');
    	component_subscribe($$self, resScore, $$value => $$invalidate(1, $resScore = $$value));
    	validate_store(AnsList, 'AnsList');
    	component_subscribe($$self, AnsList, $$value => $$invalidate(2, $AnsList = $$value));
    	validate_store(CusList, 'CusList');
    	component_subscribe($$self, CusList, $$value => $$invalidate(3, $CusList = $$value));
    	validate_store(choice, 'choice');
    	component_subscribe($$self, choice, $$value => $$invalidate(4, $choice = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(5, $resWord = $$value));
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(6, $LisEnter = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FinishButtonWords', slots, []);

    	function Ans() {
    		CusList.update(value => {
    			for (let i = 0; i < $LisEnter.length; i++) {
    				value[i] = document.getElementById('inputWords' + `${i}`).value;
    				console.log(value);
    			}

    			return value;
    		});

    		console.log($CusList); //dapan cus
    		console.log($AnsList);
    		console.log($resWord); //dapsan c
    		set_store_value(choice, $choice = 'result', $choice);
    		let d = 0;
    		let resTF = new Array($CusList.length).fill(false);

    		for (let i = 0; i < $CusList.length; i++) {
    			if ($CusList[i] == $AnsList[i]) {
    				resTF[i] = true;
    				d++;
    			}
    		}

    		resultTF.update(() => {
    			return resTF;
    		});

    		set_store_value(resScore, $resScore = d, $resScore);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$8.warn(`<FinishButtonWords> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		CusList,
    		AnsList,
    		resWord,
    		choice,
    		resScore,
    		resultTF,
    		LisEnter,
    		Ans,
    		$resScore,
    		$AnsList,
    		$CusList,
    		$choice,
    		$resWord,
    		$LisEnter
    	});

    	return [Ans];
    }

    class FinishButtonWords extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FinishButtonWords",
    			options,
    			id: create_fragment$k.name
    		});
    	}
    }

    /* srcReviving\Words\WordsNext.svelte generated by Svelte v3.59.2 */

    const { console: console_1$7 } = globals;
    const file$h = "srcReviving\\Words\\WordsNext.svelte";

    function create_fragment$j(ctx) {
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			button.textContent = "next";
    			attr_dev(button, "class", "next svelte-pcbnng");
    			add_location(button, file$h, 19, 0, 517);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Slide*/ ctx[0], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
    	let $LisEnter;
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(1, $LisEnter = $$value));
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(2, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(3, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(4, $MinSlide = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WordsNext', slots, []);

    	function Slide() {
    		set_store_value(onSide, $onSide++, $onSide);

    		if ($onSide == $LisEnter.length - 1) {
    			set_store_value(MaxSlide, $MaxSlide = true, $MaxSlide);
    			console.log($onSide);
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = false, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		document.getElementById('slideContain').style.transform = "translate(" + $onSide * -100 / $LisEnter.length + "%, 0)";
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$7.warn(`<WordsNext> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		Slide,
    		$LisEnter,
    		$onSide,
    		$MaxSlide,
    		$MinSlide
    	});

    	return [Slide];
    }

    class WordsNext extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WordsNext",
    			options,
    			id: create_fragment$j.name
    		});
    	}
    }

    /* srcReviving\Words\WordsBoard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$6 } = globals;
    const file$g = "srcReviving\\Words\\WordsBoard.svelte";

    function create_fragment$i(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let div0_id_value;
    	let t;
    	let div1;
    	let div1_id_value;
    	let div2_id_value;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t = space();
    			div1 = element("div");
    			attr_dev(div0, "class", "containfuture svelte-l561lp");
    			attr_dev(div0, "id", div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`);
    			add_location(div0, file$g, 47, 8, 1150);
    			attr_dev(div1, "class", "containfuture svelte-l561lp");
    			attr_dev(div1, "id", div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`);
    			add_location(div1, file$g, 49, 8, 1232);
    			attr_dev(div2, "class", "titleQues svelte-l561lp");
    			attr_dev(div2, "id", div2_id_value = "QuesWord" + `${/*sort*/ ctx[0]}`);
    			add_location(div2, file$g, 46, 4, 1087);
    			attr_dev(div3, "class", "containWordsBoard svelte-l561lp");
    			add_location(div3, file$g, 45, 0, 1048);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*sort*/ 1 && div0_id_value !== (div0_id_value = 'furword' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div0, "id", div0_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div1_id_value !== (div1_id_value = 'furmean' + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div1, "id", div1_id_value);
    			}

    			if (dirty & /*sort*/ 1 && div2_id_value !== (div2_id_value = "QuesWord" + `${/*sort*/ ctx[0]}`)) {
    				attr_dev(div2, "id", div2_id_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $AnsList;
    	validate_store(AnsList, 'AnsList');
    	component_subscribe($$self, AnsList, $$value => $$invalidate(3, $AnsList = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WordsBoard', slots, []);
    	let { words, means, sort } = $$props;
    	let finalresult;

    	onMount(() => {
    		//algorith for pick words
    		//answer
    		AnsList.update(value => {
    			return [...value, words];
    		});

    		console.log("valueeeee", $AnsList);
    		let r = document.createElement('input');

    		r.style.cssText = `    background-color: rgb(238, 238, 238);
    width: 50%;
    border-radius: 1vh;
    font-size: 6vh;
    font-weight: bold;
    padding: 1vh;
    color:#333333;
    text-align: center;`;

    		r.id = 'inputWords' + `${sort}`;
    		r.maxLenght = words.length;
    		r.setAttribute('autocomplete', 'off');
    		r.setAttribute('spellcheck', 'false');

    		//finalresult = `${r.outerHTML} (${parts}) ${means}`
    		document.getElementById('furword' + `${sort}`).innerHTML = r.outerHTML;

    		document.getElementById('furmean' + `${sort}`).innerHTML = means;
    	});

    	$$self.$$.on_mount.push(function () {
    		if (words === undefined && !('words' in $$props || $$self.$$.bound[$$self.$$.props['words']])) {
    			console_1$6.warn("<WordsBoard> was created without expected prop 'words'");
    		}

    		if (means === undefined && !('means' in $$props || $$self.$$.bound[$$self.$$.props['means']])) {
    			console_1$6.warn("<WordsBoard> was created without expected prop 'means'");
    		}

    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console_1$6.warn("<WordsBoard> was created without expected prop 'sort'");
    		}
    	});

    	const writable_props = ['words', 'means', 'sort'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$6.warn(`<WordsBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		AnsList,
    		CusList,
    		resWord,
    		reswholekey,
    		words,
    		means,
    		sort,
    		finalresult,
    		$AnsList
    	});

    	$$self.$inject_state = $$props => {
    		if ('words' in $$props) $$invalidate(1, words = $$props.words);
    		if ('means' in $$props) $$invalidate(2, means = $$props.means);
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    		if ('finalresult' in $$props) finalresult = $$props.finalresult;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sort, words, means];
    }

    class WordsBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { words: 1, means: 2, sort: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WordsBoard",
    			options,
    			id: create_fragment$i.name
    		});
    	}

    	get words() {
    		throw new Error("<WordsBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set words(value) {
    		throw new Error("<WordsBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get means() {
    		throw new Error("<WordsBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set means(value) {
    		throw new Error("<WordsBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sort() {
    		throw new Error("<WordsBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<WordsBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReviving\Words\WordsContain.svelte generated by Svelte v3.59.2 */
    const file$f = "srcReviving\\Words\\WordsContain.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	child_ctx[9] = i;
    	return child_ctx;
    }

    // (28:4) {:else}
    function create_else_block$1(ctx) {
    	let wordsback;
    	let t;
    	let wordsnext;
    	let current;
    	wordsback = new WordsBack({ $$inline: true });
    	wordsnext = new WordsNext({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(wordsback.$$.fragment);
    			t = space();
    			create_component(wordsnext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wordsback, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(wordsnext, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wordsback.$$.fragment, local);
    			transition_in(wordsnext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wordsback.$$.fragment, local);
    			transition_out(wordsnext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wordsback, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(wordsnext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(28:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (26:24) 
    function create_if_block_1$2(ctx) {
    	let wordsnext;
    	let current;
    	wordsnext = new WordsNext({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(wordsnext.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wordsnext, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wordsnext.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wordsnext.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wordsnext, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(26:24) ",
    		ctx
    	});

    	return block;
    }

    // (23:4) {#if $MaxSlide}
    function create_if_block$4(ctx) {
    	let wordsback;
    	let t;
    	let finishbuttonwords;
    	let current;
    	wordsback = new WordsBack({ $$inline: true });
    	finishbuttonwords = new FinishButtonWords({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(wordsback.$$.fragment);
    			t = space();
    			create_component(finishbuttonwords.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wordsback, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(finishbuttonwords, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wordsback.$$.fragment, local);
    			transition_in(finishbuttonwords.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wordsback.$$.fragment, local);
    			transition_out(finishbuttonwords.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wordsback, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(finishbuttonwords, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(23:4) {#if $MaxSlide}",
    		ctx
    	});

    	return block;
    }

    // (35:12) {#each $LisEnter as element,i}
    function create_each_block$5(ctx) {
    	let wordsboard;
    	let current;

    	wordsboard = new WordsBoard({
    			props: {
    				words: /*$resWord*/ ctx[3][/*i*/ ctx[9]],
    				means: /*$resMean*/ ctx[4][/*i*/ ctx[9]],
    				sort: /*i*/ ctx[9]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(wordsboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wordsboard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const wordsboard_changes = {};
    			if (dirty & /*$resWord*/ 8) wordsboard_changes.words = /*$resWord*/ ctx[3][/*i*/ ctx[9]];
    			if (dirty & /*$resMean*/ 16) wordsboard_changes.means = /*$resMean*/ ctx[4][/*i*/ ctx[9]];
    			wordsboard.$set(wordsboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wordsboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wordsboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wordsboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(35:12) {#each $LisEnter as element,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div2;
    	let current_block_type_index;
    	let if_block;
    	let t;
    	let div1;
    	let div0;
    	let current;
    	const if_block_creators = [create_if_block$4, create_if_block_1$2, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$MaxSlide*/ ctx[0]) return 0;
    		if (/*$MinSlide*/ ctx[1]) return 1;
    		return 2;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let each_value = /*$LisEnter*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			if_block.c();
    			t = space();
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "id", "slideContain");
    			attr_dev(div0, "class", "svelte-rq7aib");
    			add_location(div0, file$f, 33, 8, 822);
    			attr_dev(div1, "id", "containWordsSlide");
    			attr_dev(div1, "class", "svelte-rq7aib");
    			add_location(div1, file$f, 32, 4, 783);
    			attr_dev(div2, "id", "containWords");
    			attr_dev(div2, "class", "svelte-rq7aib");
    			add_location(div2, file$f, 21, 0, 557);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			if_blocks[current_block_type_index].m(div2, null);
    			append_dev(div2, t);
    			append_dev(div2, div1);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(div2, t);
    			}

    			if (dirty & /*$resWord, $resMean, $LisEnter*/ 28) {
    				each_value = /*$LisEnter*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			if_blocks[current_block_type_index].d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $onSide;
    	let $MaxSlide;
    	let $MinSlide;
    	let $LisEnter;
    	let $AnsList;
    	let $resWord;
    	let $resMean;
    	validate_store(onSide, 'onSide');
    	component_subscribe($$self, onSide, $$value => $$invalidate(5, $onSide = $$value));
    	validate_store(MaxSlide, 'MaxSlide');
    	component_subscribe($$self, MaxSlide, $$value => $$invalidate(0, $MaxSlide = $$value));
    	validate_store(MinSlide, 'MinSlide');
    	component_subscribe($$self, MinSlide, $$value => $$invalidate(1, $MinSlide = $$value));
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(2, $LisEnter = $$value));
    	validate_store(AnsList, 'AnsList');
    	component_subscribe($$self, AnsList, $$value => $$invalidate(6, $AnsList = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(3, $resWord = $$value));
    	validate_store(resMean, 'resMean');
    	component_subscribe($$self, resMean, $$value => $$invalidate(4, $resMean = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WordsContain', slots, []);
    	set_store_value(AnsList, $AnsList = [], $AnsList);

    	onMount(() => {
    		if ($LisEnter.length == 1) {
    			set_store_value(MaxSlide, $MaxSlide = true, $MaxSlide);
    		} else {
    			set_store_value(MinSlide, $MinSlide = true, $MinSlide);
    			set_store_value(MaxSlide, $MaxSlide = false, $MaxSlide);
    		}

    		set_store_value(onSide, $onSide = 0, $onSide);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<WordsContain> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		AnsList,
    		LisEnter,
    		MaxSlide,
    		MinSlide,
    		onSide,
    		resMean,
    		resWord,
    		onMount,
    		WordsBack,
    		FinishButtonWords,
    		WordsNext,
    		WordsBoard,
    		$onSide,
    		$MaxSlide,
    		$MinSlide,
    		$LisEnter,
    		$AnsList,
    		$resWord,
    		$resMean
    	});

    	return [$MaxSlide, $MinSlide, $LisEnter, $resWord, $resMean];
    }

    class WordsContain extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WordsContain",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    let wordlist = ["the", "of", "and", "to", "a", "in", "for", "is", "on", "that", "by", "this", "with", "i", "you", "it", "not", "or", "be", "are", "from", "at", "as", "your", "all", "have", "new", "more", "an", "was", "we", "will", "home", "can", "us", "about", "if", "page", "my", "has", "search", "free", "but", "our", "one", "other", "do", "no", "information", "time", "they", "site", "he", "up", "may", "what", "which", "their", "news", "out", "use", "any", "there", "see", "only", "so", "his", "when", "contact", "here", "business", "who", "web", "also", "now", "help", "get", "pm", "view", "online", "c", "e", "first", "am", "been", "would", "how", "were", "me", "s", "services", "some", "these", "click", "its", "like", "service", "x", "than", "find", "price", "date", "back", "top", "people", "had", "list", "name", "just", "over", "state", "year", "day", "into", "email", "two", "health", "n", "world", "re", "next", "used", "go", "b", "work", "last", "most", "products", "music", "buy", "data", "make", "them", "should", "product", "system", "post", "her", "city", "t", "add", "policy", "number", "such", "please", "available", "copyright", "support", "message", "after", "best", "software", "then", "jan", "good", "video", "well", "d", "where", "info", "rights", "public", "books", "high", "school", "through", "m", "each", "links", "she", "review", "years", "order", "very", "privacy", "book", "items", "company", "r", "read", "group", "sex", "need", "many", "user", "said", "de", "does", "set", "under", "general", "research", "university", "january", "mail", "full", "map", "reviews", "program", "life", "know", "games", "way", "days", "management", "p", "part", "could", "great", "united", "hotel", "real", "f", "item", "international", "center", "ebay", "must", "store", "travel", "comments", "made", "development", "report", "off", "member", "details", "line", "terms", "before", "hotels", "did", "send", "right", "type", "because", "local", "those", "using", "results", "office", "education", "national", "car", "design", "take", "posted", "internet", "address", "community", "within", "states", "area", "want", "phone", "dvd", "shipping", "reserved", "subject", "between", "forum", "family", "l", "long", "based", "w", "code", "show", "o", "even", "black", "check", "special", "prices", "website", "index", "being", "women", "much", "sign", "file", "link", "open", "today", "technology", "south", "case", "project", "same", "pages", "uk", "version", "section", "own", "found", "sports", "house", "related", "security", "both", "county", "american", "photo", "game", "members", "power", "while", "care", "network", "down", "computer", "systems", "three", "total", "place", "end", "following", "download", "h", "him", "without", "per", "access", "think", "north", "resources", "current", "posts", "big", "media", "law", "control", "water", "history", "pictures", "size", "art", "personal", "since", "including", "guide", "shop", "directory", "board", "location", "change", "white", "text", "small", "rating", "rate", "government", "children", "during", "usa", "return", "students", "v", "shopping", "account", "times", "sites", "level", "digital", "profile", "previous", "form", "events", "love", "old", "john", "main", "call", "hours", "image", "department", "title", "description", "non", "k", "y", "insurance", "another", "why", "shall", "property", "class", "cd", "still", "money", "quality", "every", "listing", "content", "country", "private", "little", "visit", "save", "tools", "low", "reply", "customer", "december", "compare", "movies", "include", "college", "value", "article", "york", "man", "card", "jobs", "provide", "j", "food", "source", "author", "different", "press", "u", "learn", "sale", "around", "print", "course", "job", "canada", "process", "teen", "room", "stock", "training", "too", "credit", "point", "join", "science", "men", "categories", "advanced", "west", "sales", "look", "english", "left", "team", "estate", "box", "conditions", "select", "windows", "photos", "gay", "thread", "week", "category", "note", "live", "large", "gallery", "table", "register", "however", "june", "october", "november", "market", "library", "really", "action", "start", "series", "model", "features", "air", "industry", "plan", "human", "provided", "tv", "yes", "required", "second", "hot", "accessories", "cost", "movie", "forums", "march", "la", "september", "better", "say", "questions", "july", "yahoo", "going", "medical", "test", "friend", "come", "dec", "server", "pc", "study", "application", "cart", "staff", "articles", "san", "feedback", "again", "play", "looking", "issues", "april", "never", "users", "complete", "street", "topic", "comment", "financial", "things", "working", "against", "standard", "tax", "person", "below", "mobile", "less", "got", "blog", "party", "payment", "equipment", "login", "student", "let", "programs", "offers", "legal", "above", "recent", "park", "stores", "side", "act", "problem", "red", "give", "memory", "performance", "social", "q", "august", "quote", "language", "story", "sell", "options", "experience", "rates", "create", "key", "body", "young", "america", "important", "field", "few", "east", "paper", "single", "ii", "age", "activities", "club", "example", "girls", "additional", "password", "z", "latest", "something", "road", "gift", "question", "changes", "night", "ca", "hard", "texas", "oct", "pay", "four", "poker", "status", "browse", "issue", "range", "building", "seller", "court", "february", "always", "result", "audio", "light", "write", "war", "nov", "offer", "blue", "groups", "al", "easy", "given", "files", "event", "release", "analysis", "request", "fax", "china", "making", "picture", "needs", "possible", "might", "professional", "yet", "month", "major", "star", "areas", "future", "space", "committee", "hand", "sun", "cards", "problems", "london", "washington", "meeting", "rss", "become", "interest", "id", "child", "keep", "enter", "california", "porn", "share", "similar", "garden", "schools", "million", "added", "reference", "companies", "listed", "baby", "learning", "energy", "run", "delivery", "net", "popular", "term", "film", "stories", "put", "computers", "journal", "reports", "co", "try", "welcome", "central", "images", "president", "notice", "god", "original", "head", "radio", "until", "cell", "color", "self", "council", "away", "includes", "track", "australia", "discussion", "archive", "once", "others", "entertainment", "agreement", "format", "least", "society", "months", "log", "safety", "friends", "sure", "faq", "trade", "edition", "cars", "messages", "marketing", "tell", "further", "updated", "association", "able", "having", "provides", "david", "fun", "already", "green", "studies", "close", "common", "drive", "specific", "several", "gold", "feb", "living", "sep", "collection", "called", "short", "arts", "lot", "ask", "display", "limited", "powered", "solutions", "means", "director", "daily", "beach", "past", "natural", "whether", "due", "et", "electronics", "five", "upon", "period", "planning", "database", "says", "official", "weather", "mar", "land", "average", "done", "technical", "window", "france", "pro", "region", "island", "record", "direct", "microsoft", "conference", "environment", "records", "st", "district", "calendar", "costs", "style", "url", "front", "statement", "update", "parts", "aug", "ever", "downloads", "early", "miles", "sound", "resource", "present", "applications", "either", "ago", "document", "word", "works", "material", "bill", "apr", "written", "talk", "federal", "hosting", "rules", "final", "adult", "tickets", "thing", "centre", "requirements", "via", "cheap", "nude", "kids", "finance", "true", "minutes", "else", "mark", "third", "rock", "gifts", "europe", "reading", "topics", "bad", "individual", "tips", "plus", "auto", "cover", "usually", "edit", "together", "videos", "percent", "fast", "function", "fact", "unit", "getting", "global", "tech", "meet", "far", "economic", "en", "player", "projects", "lyrics", "often", "subscribe", "submit", "germany", "amount", "watch", "included", "feel", "though", "bank", "risk", "thanks", "everything", "deals", "various", "words", "linux", "jul", "production", "commercial", "james", "weight", "town", "heart", "advertising", "received", "choose", "treatment", "newsletter", "archives", "points", "knowledge", "magazine", "error", "camera", "jun", "girl", "currently", "construction", "toys", "registered", "clear", "golf", "receive", "domain", "methods", "chapter", "makes", "protection", "policies", "loan", "wide", "beauty", "manager", "india", "position", "taken", "sort", "listings", "models", "michael", "known", "half", "cases", "step", "engineering", "florida", "simple", "quick", "none", "wireless", "license", "paul", "friday", "lake", "whole", "annual", "published", "later", "basic", "sony", "shows", "corporate", "google", "church", "method", "purchase", "customers", "active", "response", "practice", "hardware", "figure", "materials", "fire", "holiday", "chat", "enough", "designed", "along", "among", "death", "writing", "speed", "html", "countries", "loss", "face", "brand", "discount", "higher", "effects", "created", "remember", "standards", "oil", "bit", "yellow", "political", "increase", "advertise", "kingdom", "base", "near", "environmental", "thought", "stuff", "french", "storage", "oh", "japan", "doing", "loans", "shoes", "entry", "stay", "nature", "orders", "availability", "africa", "summary", "turn", "mean", "growth", "notes", "agency", "king", "monday", "european", "activity", "copy", "although", "drug", "pics", "western", "income", "force", "cash", "employment", "overall", "bay", "river", "commission", "ad", "package", "contents", "seen", "players", "engine", "port", "album", "regional", "stop", "supplies", "started", "administration", "bar", "institute", "views", "plans", "double", "dog", "build", "screen", "exchange", "types", "soon", "sponsored", "lines", "electronic", "continue", "across", "benefits", "needed", "season", "apply", "someone", "held", "ny", "anything", "printer", "condition", "effective", "believe", "organization", "effect", "asked", "eur", "mind", "sunday", "selection", "casino", "pdf", "lost", "tour", "menu", "volume", "cross", "anyone", "mortgage", "hope", "silver", "corporation", "wish", "inside", "solution", "mature", "role", "rather", "weeks", "addition", "came", "supply", "nothing", "certain", "usr", "executive", "running", "lower", "necessary", "union", "jewelry", "according", "dc", "clothing", "mon", "com", "particular", "fine", "names", "robert", "homepage", "hour", "gas", "skills", "six", "bush", "islands", "advice", "career", "military", "rental", "decision", "leave", "british", "teens", "pre", "huge", "sat", "woman", "facilities", "zip", "bid", "kind", "sellers", "middle", "move", "cable", "opportunities", "taking", "values", "division", "coming", "tuesday", "object", "lesbian", "appropriate", "machine", "logo", "length", "actually", "nice", "score", "statistics", "client", "ok", "returns", "capital", "follow", "sample", "investment", "sent", "shown", "saturday", "christmas", "england", "culture", "band", "flash", "ms", "lead", "george", "choice", "went", "starting", "registration", "fri", "thursday", "courses", "consumer", "hi", "airport", "foreign", "artist", "outside", "furniture", "levels", "channel", "letter", "mode", "phones", "ideas", "wednesday", "structure", "fund", "summer", "allow", "degree", "contract", "button", "releases", "wed", "homes", "super", "male", "matter", "custom", "virginia", "almost", "took", "located", "multiple", "asian", "distribution", "editor", "inn", "industrial", "cause", "potential", "song", "cnet", "ltd", "los", "hp", "focus", "late", "fall", "featured", "idea", "rooms", "female", "responsible", "inc", "communications", "win", "associated", "thomas", "primary", "cancer", "numbers", "reason", "tool", "browser", "spring", "foundation", "answer", "voice", "eg", "friendly", "schedule", "documents", "communication", "purpose", "feature", "bed", "comes", "police", "everyone", "independent", "ip", "approach", "cameras", "brown", "physical", "operating", "hill", "maps", "medicine", "deal", "hold", "ratings", "chicago", "forms", "glass", "happy", "tue", "smith", "wanted", "developed", "thank", "safe", "unique", "survey", "prior", "telephone", "sport", "ready", "feed", "animal", "sources", "mexico", "population", "pa", "regular", "secure", "navigation", "operations", "therefore", "ass", "simply", "evidence", "station", "christian", "round", "paypal", "favorite", "understand", "option", "master", "valley", "recently", "probably", "thu", "rentals", "sea", "built", "publications", "blood", "cut", "worldwide", "improve", "connection", "publisher", "hall", "larger", "anti", "networks", "earth", "parents", "nokia", "impact", "transfer", "introduction", "kitchen", "strong", "tel", "carolina", "wedding", "properties", "hospital", "ground", "overview", "ship", "accommodation", "owners", "disease", "tx", "excellent", "paid", "italy", "perfect", "hair", "opportunity", "kit", "classic", "basis", "command", "cities", "william", "express", "anal", "award", "distance", "tree", "peter", "assessment", "ensure", "thus", "wall", "ie", "involved", "el", "extra", "especially", "interface", "pussy", "partners", "budget", "rated", "guides", "success", "maximum", "ma", "operation", "existing", "quite", "selected", "boy", "amazon", "patients", "restaurants", "beautiful", "warning", "wine", "locations", "horse", "vote", "forward", "flowers", "stars", "significant", "lists", "technologies", "owner", "retail", "animals", "useful", "directly", "manufacturer", "ways", "est", "son", "providing", "rule", "mac", "housing", "takes", "iii", "gmt", "bring", "catalog", "searches", "max", "trying", "mother", "authority", "considered", "told", "xml", "traffic", "programme", "joined", "input", "strategy", "feet", "agent", "valid", "bin", "modern", "senior", "ireland", "sexy", "teaching", "door", "grand", "testing", "trial", "charge", "units", "instead", "canadian", "cool", "normal", "wrote", "enterprise", "ships", "entire", "educational", "md", "leading", "metal", "positive", "fl", "fitness", "chinese", "opinion", "mb", "asia", "football", "abstract", "uses", "output", "funds", "mr", "greater", "likely", "develop", "employees", "artists", "alternative", "processing", "responsibility", "resolution", "java", "guest", "seems", "publication", "pass", "relations", "trust", "van", "contains", "session", "multi", "photography", "republic", "fees", "components", "vacation", "century", "academic", "assistance", "completed", "skin", "graphics", "indian", "prev", "ads", "mary", "il", "expected", "ring", "grade", "dating", "pacific", "mountain", "organizations", "pop", "filter", "mailing", "vehicle", "longer", "consider", "int", "northern", "behind", "panel", "floor", "german", "buying", "match", "proposed", "default", "require", "iraq", "boys", "outdoor", "deep", "morning", "otherwise", "allows", "rest", "protein", "plant", "reported", "hit", "transportation", "mm", "pool", "mini", "politics", "partner", "disclaimer", "authors", "boards", "faculty", "parties", "fish", "membership", "mission", "eye", "string", "sense", "modified", "pack", "released", "stage", "internal", "goods", "recommended", "born", "unless", "richard", "detailed", "japanese", "race", "approved", "background", "target", "except", "character", "usb", "maintenance", "ability", "maybe", "functions", "ed", "moving", "brands", "places", "php", "pretty", "trademarks", "phentermine", "spain", "southern", "yourself", "etc", "winter", "rape", "battery", "youth", "pressure", "submitted", "boston", "incest", "debt", "keywords", "medium", "television", "interested", "core", "break", "purposes", "throughout", "sets", "dance", "wood", "msn", "itself", "defined", "papers", "playing", "awards", "fee", "studio", "reader", "virtual", "device", "established", "answers", "rent", "las", "remote", "dark", "programming", "external", "apple", "le", "regarding", "instructions", "min", "offered", "theory", "enjoy", "remove", "aid", "surface", "minimum", "visual", "host", "variety", "teachers", "isbn", "martin", "manual", "block", "subjects", "agents", "increased", "repair", "fair", "civil", "steel", "understanding", "songs", "fixed", "wrong", "beginning", "hands", "associates", "finally", "az", "updates", "desktop", "classes", "paris", "ohio", "gets", "sector", "capacity", "requires", "jersey", "un", "fat", "fully", "father", "electric", "saw", "instruments", "quotes", "officer", "driver", "businesses", "dead", "respect", "unknown", "specified", "restaurant", "mike", "trip", "pst", "worth", "mi", "procedures", "poor", "teacher", "xxx", "eyes", "relationship", "workers", "farm", "fucking", "georgia", "peace", "traditional", "campus", "tom", "showing", "creative", "coast", "benefit", "progress", "funding", "devices", "lord", "grant", "sub", "agree", "fiction", "hear", "sometimes", "watches", "careers", "beyond", "goes", "families", "led", "museum", "themselves", "fan", "transport", "interesting", "blogs", "wife", "evaluation", "accepted", "former", "implementation", "ten", "hits", "zone", "complex", "th", "cat", "galleries", "references", "die", "presented", "jack", "flat", "flow", "agencies", "literature", "respective", "parent", "spanish", "michigan", "columbia", "setting", "dr", "scale", "stand", "economy", "highest", "helpful", "monthly", "critical", "frame", "musical", "definition", "secretary", "angeles", "networking", "path", "australian", "employee", "chief", "gives", "kb", "bottom", "magazines", "packages", "detail", "francisco", "laws", "changed", "pet", "heard", "begin", "individuals", "colorado", "royal", "clean", "switch", "russian", "largest", "african", "guy", "titles", "relevant", "guidelines", "justice", "connect", "bible", "dev", "cup", "basket", "applied", "weekly", "vol", "installation", "described", "demand", "pp", "suite", "vegas", "na", "square", "chris", "attention", "advance", "skip", "diet", "army", "auction", "gear", "lee", "os", "difference", "allowed", "correct", "charles", "nation", "selling", "lots", "piece", "sheet", "firm", "seven", "older", "illinois", "regulations", "elements", "species", "jump", "cells", "module", "resort", "facility", "random", "pricing", "dvds", "certificate", "minister", "motion", "looks", "fashion", "directions", "visitors", "documentation", "monitor", "trading", "forest", "calls", "whose", "coverage", "couple", "giving", "chance", "vision", "ball", "ending", "clients", "actions", "listen", "discuss", "accept", "automotive", "naked", "goal", "successful", "sold", "wind", "communities", "clinical", "situation", "sciences", "markets", "lowest", "highly", "publishing", "appear", "emergency", "developing", "lives", "currency", "leather", "determine", "milf", "temperature", "palm", "announcements", "patient", "actual", "historical", "stone", "bob", "commerce", "ringtones", "perhaps", "persons", "difficult", "scientific", "satellite", "fit", "tests", "village", "accounts", "amateur", "ex", "met", "pain", "xbox", "particularly", "factors", "coffee", "www", "settings", "cum", "buyer", "cultural", "steve", "easily", "oral", "ford", "poster", "edge", "functional", "root", "au", "fi", "closed", "holidays", "ice", "pink", "zealand", "balance", "monitoring", "graduate", "replies", "shot", "nc", "architecture", "initial", "label", "thinking", "scott", "llc", "sec", "recommend", "canon", "hardcore", "league", "waste", "minute", "bus", "provider", "optional", "dictionary", "cold", "accounting", "manufacturing", "sections", "chair", "fishing", "effort", "phase", "fields", "bag", "fantasy", "po", "letters", "motor", "va", "professor", "context", "install", "shirt", "apparel", "generally", "continued", "foot", "mass", "crime", "count", "breast", "techniques", "ibm", "rd", "johnson", "sc", "quickly", "dollars", "websites", "religion", "claim", "driving", "permission", "surgery", "patch", "heat", "wild", "measures", "generation", "kansas", "miss", "chemical", "doctor", "task", "reduce", "brought", "himself", "nor", "component", "enable", "exercise", "bug", "santa", "mid", "guarantee", "leader", "diamond", "israel", "se", "processes", "soft", "servers", "alone", "meetings", "seconds", "jones", "arizona", "keyword", "interests", "flight", "congress", "fuel", "username", "walk", "fuck", "produced", "italian", "paperback", "classifieds", "wait", "supported", "pocket", "saint", "rose", "freedom", "argument", "competition", "creating", "jim", "drugs", "joint", "premium", "providers", "fresh", "characters", "attorney", "upgrade", "di", "factor", "growing", "thousands", "km", "stream", "apartments", "pick", "hearing", "eastern", "auctions", "therapy", "entries", "dates", "generated", "signed", "upper", "administrative", "serious", "prime", "samsung", "limit", "began", "louis", "steps", "errors", "shops", "bondage", "del", "efforts", "informed", "ga", "ac", "thoughts", "creek", "ft", "worked", "quantity", "urban", "practices", "sorted", "reporting", "essential", "myself", "tours", "platform", "load", "affiliate", "labor", "immediately", "admin", "nursing", "defense", "machines", "designated", "tags", "heavy", "covered", "recovery", "joe", "guys", "integrated", "configuration", "cock", "merchant", "comprehensive", "expert", "universal", "protect", "drop", "solid", "cds", "presentation", "languages", "became", "orange", "compliance", "vehicles", "prevent", "theme", "rich", "im", "campaign", "marine", "improvement", "vs", "guitar", "finding", "pennsylvania", "examples", "ipod", "saying", "spirit", "ar", "claims", "porno", "challenge", "motorola", "acceptance", "strategies", "mo", "seem", "affairs", "touch", "intended", "towards", "sa", "goals", "hire", "election", "suggest", "branch", "charges", "serve", "affiliates", "reasons", "magic", "mount", "smart", "talking", "gave", "ones", "latin", "multimedia", "xp", "tits", "avoid", "certified", "manage", "corner", "rank", "computing", "oregon", "element", "birth", "virus", "abuse", "interactive", "requests", "separate", "quarter", "procedure", "leadership", "tables", "define", "racing", "religious", "facts", "breakfast", "kong", "column", "plants", "faith", "chain", "developer", "identify", "avenue", "missing", "died", "approximately", "domestic", "sitemap", "recommendations", "moved", "houston", "reach", "comparison", "mental", "viewed", "moment", "extended", "sequence", "inch", "attack", "sorry", "centers", "opening", "damage", "lab", "reserve", "recipes", "cvs", "gamma", "plastic", "produce", "snow", "placed", "truth", "counter", "failure", "follows", "eu", "weekend", "dollar", "camp", "ontario", "automatically", "des", "minnesota", "films", "bridge", "native", "fill", "williams", "movement", "printing", "baseball", "owned", "approval", "draft", "chart", "played", "contacts", "cc", "jesus", "readers", "clubs", "lcd", "wa", "jackson", "equal", "adventure", "matching", "offering", "shirts", "profit", "leaders", "posters", "institutions", "assistant", "variable", "ave", "dj", "advertisement", "expect", "parking", "headlines", "yesterday", "compared", "determined", "wholesale", "workshop", "russia", "gone", "codes", "kinds", "extension", "seattle", "statements", "golden", "completely", "teams", "fort", "cm", "wi", "lighting", "senate", "forces", "funny", "brother", "gene", "turned", "portable", "tried", "electrical", "applicable", "disc", "returned", "pattern", "ct", "hentai", "boat", "named", "theatre", "laser", "earlier", "manufacturers", "sponsor", "classical", "icon", "warranty", "dedicated", "indiana", "direction", "harry", "basketball", "objects", "ends", "delete", "evening", "assembly", "nuclear", "taxes", "mouse", "signal", "criminal", "issued", "brain", "sexual", "wisconsin", "powerful", "dream", "obtained", "false", "da", "cast", "flower", "felt", "personnel", "passed", "supplied", "identified", "falls", "pic", "soul", "aids", "opinions", "promote", "stated", "stats", "hawaii", "professionals", "appears", "carry", "flag", "decided", "nj", "covers", "hr", "em", "advantage", "hello", "designs", "maintain", "tourism", "priority", "newsletters", "adults", "clips", "savings", "iv", "graphic", "atom", "payments", "rw", "estimated", "binding", "brief", "ended", "winning", "eight", "anonymous", "iron", "straight", "script", "served", "wants", "miscellaneous", "prepared", "void", "dining", "alert", "integration", "atlanta", "dakota", "tag", "interview", "mix", "framework", "disk", "installed", "queen", "vhs", "credits", "clearly", "fix", "handle", "sweet", "desk", "criteria", "pubmed", "dave", "massachusetts", "diego", "hong", "vice", "associate", "ne", "truck", "behavior", "enlarge", "ray", "frequently", "revenue", "measure", "changing", "votes", "du", "duty", "looked", "discussions", "bear", "gain", "festival", "laboratory", "ocean", "flights", "experts", "signs", "lack", "depth", "iowa", "whatever", "logged", "laptop", "vintage", "train", "exactly", "dry", "explore", "maryland", "spa", "concept", "nearly", "eligible", "checkout", "reality", "forgot", "handling", "origin", "knew", "gaming", "feeds", "billion", "destination", "scotland", "faster", "intelligence", "dallas", "bought", "con", "ups", "nations", "route", "followed", "specifications", "broken", "tripadvisor", "frank", "alaska", "zoom", "blow", "battle", "residential", "anime", "speak", "decisions", "industries", "protocol", "query", "clip", "partnership", "editorial", "nt", "expression", "es", "equity", "provisions", "speech", "wire", "principles", "suggestions", "rural", "shared", "sounds", "replacement", "tape", "strategic", "judge", "spam", "economics", "acid", "bytes", "cent", "forced", "compatible", "fight", "apartment", "height", "null", "zero", "speaker", "filed", "gb", "netherlands", "obtain", "bc", "consulting", "recreation", "offices", "designer", "remain", "managed", "pr", "failed", "marriage", "roll", "korea", "banks", "fr", "participants", "secret", "bath", "aa", "kelly", "leads", "negative", "austin", "favorites", "toronto", "theater", "springs", "missouri", "andrew", "var", "perform", "healthy", "translation", "estimates", "font", "assets", "injury", "mt", "joseph", "ministry", "drivers", "lawyer", "figures", "married", "protected", "proposal", "sharing", "philadelphia", "portal", "waiting", "birthday", "beta", "fail", "gratis", "banking", "officials", "brian", "toward", "won", "slightly", "assist", "conduct", "contained", "lingerie", "shemale", "legislation", "calling", "parameters", "jazz", "serving", "bags", "profiles", "miami", "comics", "matters", "houses", "doc", "postal", "relationships", "tennessee", "wear", "controls", "breaking", "combined", "ultimate", "wales", "representative", "frequency", "introduced", "minor", "finish", "departments", "residents", "noted", "displayed", "mom", "reduced", "physics", "rare", "spent", "performed", "extreme", "samples", "davis", "daniel", "bars", "reviewed", "row", "oz", "forecast", "removed", "helps", "singles", "administrator", "cycle", "amounts", "contain", "accuracy", "dual", "rise", "usd", "sleep", "mg", "bird", "pharmacy", "brazil", "creation", "static", "scene", "hunter", "addresses", "lady", "crystal", "famous", "writer", "chairman", "violence", "fans", "oklahoma", "speakers", "drink", "academy", "dynamic", "gender", "eat", "permanent", "agriculture", "dell", "cleaning", "constitutes", "portfolio", "practical", "delivered", "collectibles", "infrastructure", "exclusive", "seat", "concerns", "colour", "vendor", "originally", "intel", "utilities", "philosophy", "regulation", "officers", "reduction", "aim", "bids", "referred", "supports", "nutrition", "recording", "regions", "junior", "toll", "les", "cape", "ann", "rings", "meaning", "tip", "secondary", "wonderful", "mine", "ladies", "henry", "ticket", "announced", "guess", "agreed", "prevention", "whom", "ski", "soccer", "math", "import", "posting", "presence", "instant", "mentioned", "automatic", "healthcare", "viewing", "maintained", "ch", "increasing", "majority", "connected", "christ", "dan", "dogs", "sd", "directors", "aspects", "austria", "ahead", "moon", "participation", "scheme", "utility", "preview", "fly", "manner", "matrix", "containing", "combination", "devel", "amendment", "despite", "strength", "guaranteed", "turkey", "libraries", "proper", "distributed", "degrees", "singapore", "enterprises", "delta", "fear", "seeking", "inches", "phoenix", "rs", "convention", "shares", "principal", "daughter", "standing", "voyeur", "comfort", "colors", "wars", "cisco", "ordering", "kept", "alpha", "appeal", "cruise", "bonus", "certification", "previously", "hey", "bookmark", "buildings", "specials", "beat", "disney", "household", "batteries", "adobe", "smoking", "bbc", "becomes", "drives", "arms", "alabama", "tea", "improved", "trees", "avg", "achieve", "positions", "dress", "subscription", "dealer", "contemporary", "sky", "utah", "nearby", "rom", "carried", "happen", "exposure", "panasonic", "hide", "permalink", "signature", "gambling", "refer", "miller", "provision", "outdoors", "clothes", "caused", "luxury", "babes", "frames", "viagra", "certainly", "indeed", "newspaper", "toy", "circuit", "layer", "printed", "slow", "removal", "easier", "src", "liability", "trademark", "hip", "printers", "faqs", "nine", "adding", "kentucky", "mostly", "eric", "spot", "taylor", "trackback", "prints", "spend", "factory", "interior", "revised", "grow", "americans", "optical", "promotion", "relative", "amazing", "clock", "dot", "hiv", "identity", "suites", "conversion", "feeling", "hidden", "reasonable", "victoria", "serial", "relief", "revision", "broadband", "influence", "ratio", "pda", "importance", "rain", "onto", "dsl", "planet", "webmaster", "copies", "recipe", "zum", "permit", "seeing", "proof", "dna", "diff", "tennis", "bass", "prescription", "bedroom", "empty", "instance", "hole", "pets", "ride", "licensed", "orlando", "specifically", "tim", "bureau", "maine", "sql", "represent", "conservation", "pair", "ideal", "specs", "recorded", "don", "pieces", "finished", "parks", "dinner", "lawyers", "sydney", "stress", "cream", "ss", "runs", "trends", "yeah", "discover", "sexo", "ap", "patterns", "boxes", "louisiana", "hills", "javascript", "fourth", "nm", "advisor", "mn", "marketplace", "nd", "evil", "aware", "wilson", "shape", "evolution", "irish", "certificates", "objectives", "stations", "suggested", "gps", "op", "remains", "acc", "greatest", "firms", "concerned", "euro", "operator", "structures", "generic", "encyclopedia", "usage", "cap", "ink", "charts", "continuing", "mixed", "census", "interracial", "peak", "tn", "competitive", "exist", "wheel", "transit", "dick", "suppliers", "salt", "compact", "poetry", "lights", "tracking", "angel", "bell", "keeping", "preparation", "attempt", "receiving", "matches", "accordance", "width", "noise", "engines", "forget", "array", "discussed", "accurate", "stephen", "elizabeth", "climate", "reservations", "pin", "playstation", "alcohol", "greek", "instruction", "managing", "annotation", "sister", "raw", "differences", "walking", "explain", "smaller", "newest", "establish", "gnu", "happened", "expressed", "jeff", "extent", "sharp", "lesbians", "ben", "lane", "paragraph", "kill", "mathematics", "aol", "compensation", "ce", "export", "managers", "aircraft", "modules", "sweden", "conflict", "conducted", "versions", "employer", "occur", "percentage", "knows", "mississippi", "describe", "concern", "backup", "requested", "citizens", "connecticut", "heritage", "personals", "immediate", "holding", "trouble", "spread", "coach", "kevin", "agricultural", "expand", "supporting", "audience", "assigned", "jordan", "collections", "ages", "participate", "plug", "specialist", "cook", "affect", "virgin", "experienced", "investigation", "raised", "hat", "institution", "directed", "dealers", "searching", "sporting", "helping", "perl", "affected", "lib", "bike", "totally", "plate", "expenses", "indicate", "blonde", "ab", "proceedings", "favourite", "transmission", "anderson", "utc", "characteristics", "der", "lose", "organic", "seek", "experiences", "albums", "cheats", "extremely", "verzeichnis", "contracts", "guests", "hosted", "diseases", "concerning", "developers", "equivalent", "chemistry", "tony", "neighborhood", "nevada", "kits", "thailand", "variables", "agenda", "anyway", "continues", "tracks", "advisory", "cam", "curriculum", "logic", "template", "prince", "circle", "soil", "grants", "anywhere", "psychology", "responses", "atlantic", "wet", "circumstances", "edward", "investor", "identification", "ram", "leaving", "wildlife", "appliances", "matt", "elementary", "cooking", "speaking", "sponsors", "fox", "unlimited", "respond", "sizes", "plain", "exit", "entered", "iran", "arm", "keys", "launch", "wave", "checking", "costa", "belgium", "printable", "holy", "acts", "guidance", "mesh", "trail", "enforcement", "symbol", "crafts", "highway", "buddy", "hardcover", "observed", "dean", "setup", "poll", "booking", "glossary", "fiscal", "celebrity", "styles", "denver", "unix", "filled", "bond", "channels", "ericsson", "appendix", "notify", "blues", "chocolate", "pub", "portion", "scope", "hampshire", "supplier", "cables", "cotton", "bluetooth", "controlled", "requirement", "authorities", "biology", "dental", "killed", "border", "ancient", "debate", "representatives", "starts", "pregnancy", "causes", "arkansas", "biography", "leisure", "attractions", "learned", "transactions", "notebook", "explorer", "historic", "attached", "opened", "tm", "husband", "disabled", "authorized", "crazy", "upcoming", "britain", "concert", "retirement", "scores", "financing", "efficiency", "sp", "comedy", "adopted", "efficient", "weblog", "linear", "commitment", "specialty", "bears", "jean", "hop", "carrier", "edited", "constant", "visa", "mouth", "jewish", "meter", "linked", "portland", "interviews", "concepts", "nh", "gun", "reflect", "pure", "deliver", "wonder", "hell", "lessons", "fruit", "begins", "qualified", "reform", "lens", "alerts", "treated", "discovery", "draw", "mysql", "classified", "relating", "assume", "confidence", "alliance", "fm", "confirm", "warm", "neither", "lewis", "howard", "offline", "leaves", "engineer", "lifestyle", "consistent", "replace", "clearance", "connections", "inventory", "converter", "suck", "organisation", "babe", "checks", "reached", "becoming", "blowjob", "safari", "objective", "indicated", "sugar", "crew", "legs", "sam", "stick", "securities", "allen", "pdt", "relation", "enabled", "genre", "slide", "montana", "volunteer", "tested", "rear", "democratic", "enhance", "switzerland", "exact", "bound", "parameter", "adapter", "processor", "node", "formal", "dimensions", "contribute", "lock", "hockey", "storm", "micro", "colleges", "laptops", "mile", "showed", "challenges", "editors", "mens", "threads", "bowl", "supreme", "brothers", "recognition", "presents", "ref", "tank", "submission", "dolls", "estimate", "encourage", "navy", "kid", "regulatory", "inspection", "consumers", "cancel", "limits", "territory", "transaction", "manchester", "weapons", "paint", "delay", "pilot", "outlet", "contributions", "continuous", "db", "czech", "resulting", "cambridge", "initiative", "novel", "pan", "execution", "disability", "increases", "ultra", "winner", "idaho", "contractor", "ph", "episode", "examination", "potter", "dish", "plays", "bulletin", "ia", "pt", "indicates", "modify", "oxford", "adam", "truly", "epinions", "painting", "committed", "extensive", "affordable", "universe", "candidate", "databases", "patent", "slot", "psp", "outstanding", "ha", "eating", "perspective", "planned", "watching", "lodge", "messenger", "mirror", "tournament", "consideration", "ds", "discounts", "sterling", "sessions", "kernel", "boobs", "stocks", "buyers", "journals", "gray", "catalogue", "ea", "jennifer", "antonio", "charged", "broad", "taiwan", "und", "chosen", "demo", "greece", "lg", "swiss", "sarah", "clark", "labour", "hate", "terminal", "publishers", "nights", "behalf", "caribbean", "liquid", "rice", "nebraska", "loop", "salary", "reservation", "foods", "gourmet", "guard", "properly", "orleans", "saving", "nfl", "remaining", "empire", "resume", "twenty", "newly", "raise", "prepare", "avatar", "gary", "depending", "illegal", "expansion", "vary", "hundreds", "rome", "arab", "lincoln", "helped", "premier", "tomorrow", "purchased", "milk", "decide", "consent", "drama", "visiting", "performing", "downtown", "keyboard", "contest", "collected", "nw", "bands", "boot", "suitable", "ff", "absolutely", "millions", "lunch", "dildo", "audit", "push", "chamber", "guinea", "findings", "muscle", "featuring", "iso", "implement", "clicking", "scheduled", "polls", "typical", "tower", "yours", "sum", "misc", "calculator", "significantly", "chicken", "temporary", "attend", "shower", "alan", "sending", "jason", "tonight", "dear", "sufficient", "holdem", "shell", "province", "catholic", "oak", "vat", "awareness", "vancouver", "governor", "beer", "seemed", "contribution", "measurement", "swimming", "spyware", "formula", "constitution", "packaging", "solar", "jose", "catch", "jane", "pakistan", "ps", "reliable", "consultation", "northwest", "sir", "doubt", "earn", "finder", "unable", "periods", "classroom", "tasks", "democracy", "attacks", "kim", "wallpaper", "merchandise", "const", "resistance", "doors", "symptoms", "resorts", "biggest", "memorial", "visitor", "twin", "forth", "insert", "baltimore", "gateway", "ky", "dont", "alumni", "drawing", "candidates", "charlotte", "ordered", "biological", "fighting", "transition", "happens", "preferences", "spy", "romance", "instrument", "bruce", "split", "themes", "powers", "heaven", "br", "bits", "pregnant", "twice", "classification", "focused", "egypt", "physician", "hollywood", "bargain", "wikipedia", "cellular", "norway", "vermont", "asking", "blocks", "normally", "lo", "spiritual", "hunting", "diabetes", "suit", "ml", "shift", "chip", "res", "sit", "bodies", "photographs", "cutting", "wow", "simon", "writers", "marks", "flexible", "loved", "favourites", "mapping", "numerous", "relatively", "birds", "satisfaction", "represents", "char", "indexed", "pittsburgh", "superior", "preferred", "saved", "paying", "cartoon", "shots", "intellectual", "moore", "granted", "choices", "carbon", "spending", "comfortable", "magnetic", "interaction", "listening", "effectively", "registry", "crisis", "outlook", "massive", "denmark", "employed", "bright", "treat", "header", "cs", "poverty", "formed", "piano", "echo", "que", "grid", "sheets", "patrick", "experimental", "puerto", "revolution", "consolidation", "displays", "plasma", "allowing", "earnings", "voip", "mystery", "landscape", "dependent", "mechanical", "journey", "delaware", "bidding", "consultants", "risks", "banner", "applicant", "charter", "fig", "barbara", "cooperation", "counties", "acquisition", "ports", "implemented", "sf", "directories", "recognized", "dreams", "blogger", "notification", "kg", "licensing", "stands", "teach", "occurred", "textbooks", "rapid", "pull", "hairy", "diversity", "cleveland", "ut", "reverse", "deposit", "seminar", "investments", "latina", "nasa", "wheels", "sexcam", "specify", "accessibility", "dutch", "sensitive", "templates", "formats", "tab", "depends", "boots", "holds", "router", "concrete", "si", "editing", "poland", "folder", "womens", "css", "completion", "upload", "pulse", "universities", "technique", "contractors", "milfhunter", "voting", "courts", "notices", "subscriptions", "calculate", "mc", "detroit", "alexander", "broadcast", "converted", "metro", "toshiba", "anniversary", "improvements", "strip", "specification", "pearl", "accident", "nick", "accessible", "accessory", "resident", "plot", "qty", "possibly", "airline", "typically", "representation", "regard", "pump", "exists", "arrangements", "smooth", "conferences", "uniprotkb", "beastiality", "strike", "consumption", "birmingham", "flashing", "lp", "narrow", "afternoon", "threat", "surveys", "sitting", "putting", "consultant", "controller", "ownership", "committees", "penis", "legislative", "researchers", "vietnam", "trailer", "anne", "castle", "gardens", "missed", "malaysia", "unsubscribe", "antique", "labels", "willing", "bio", "molecular", "upskirt", "acting", "heads", "stored", "exam", "logos", "residence", "attorneys", "milfs", "antiques", "density", "hundred", "ryan", "operators", "strange", "sustainable", "philippines", "statistical", "beds", "breasts", "mention", "innovation", "pcs", "employers", "grey", "parallel", "honda", "amended", "operate", "bills", "bold", "bathroom", "stable", "opera", "definitions", "von", "doctors", "lesson", "cinema", "asset", "ag", "scan", "elections", "drinking", "blowjobs", "reaction", "blank", "enhanced", "entitled", "severe", "generate", "stainless", "newspapers", "hospitals", "vi", "deluxe", "humor", "aged", "monitors", "exception", "lived", "duration", "bulk", "successfully", "indonesia", "pursuant", "sci", "fabric", "edt", "visits", "primarily", "tight", "domains", "capabilities", "pmid", "contrast", "recommendation", "flying", "recruitment", "sin", "berlin", "cute", "organized", "ba", "para", "siemens", "adoption", "improving", "cr", "expensive", "meant", "capture", "pounds", "buffalo", "organisations", "plane", "pg", "explained", "seed", "programmes", "desire", "expertise", "mechanism", "camping", "ee", "jewellery", "meets", "welfare", "peer", "caught", "eventually", "marked", "driven", "measured", "medline", "bottle", "agreements", "considering", "innovative", "marshall", "massage", "rubber", "conclusion", "closing", "tampa", "thousand", "meat", "legend", "grace", "susan", "ing", "ks", "adams", "python", "monster", "alex", "bang", "villa", "bone", "columns", "disorders", "bugs", "collaboration", "hamilton", "detection", "ftp", "cookies", "inner", "formation", "tutorial", "med", "engineers", "entity", "cruises", "gate", "holder", "proposals", "moderator", "sw", "tutorials", "settlement", "portugal", "lawrence", "roman", "duties", "valuable", "erotic", "tone", "collectables", "ethics", "forever", "dragon", "busy", "captain", "fantastic", "imagine", "brings", "heating", "leg", "neck", "hd", "wing", "governments", "purchasing", "scripts", "abc", "stereo", "appointed", "taste", "dealing", "commit", "tiny", "operational", "rail", "airlines", "liberal", "livecam", "jay", "trips", "gap", "sides", "tube", "turns", "corresponding", "descriptions", "cache", "belt", "jacket", "determination", "animation", "oracle", "er", "matthew", "lease", "productions", "aviation", "hobbies", "proud", "excess", "disaster", "console", "commands", "jr", "telecommunications", "instructor", "giant", "achieved", "injuries", "shipped", "bestiality", "seats", "approaches", "biz", "alarm", "voltage", "anthony", "nintendo", "usual", "loading", "stamps", "appeared", "franklin", "angle", "rob", "vinyl", "highlights", "mining", "designers", "melbourne", "ongoing", "worst", "imaging", "betting", "scientists", "liberty", "wyoming", "blackjack", "argentina", "era", "convert", "possibility", "analyst", "commissioner", "dangerous", "garage", "exciting", "reliability", "thongs", "gcc", "unfortunately", "respectively", "volunteers", "attachment", "ringtone", "finland", "morgan", "derived", "pleasure", "honor", "asp", "oriented", "eagle", "desktops", "pants", "columbus", "nurse", "prayer", "appointment", "workshops", "hurricane", "quiet", "luck", "postage", "producer", "represented", "mortgages", "dial", "responsibilities", "cheese", "comic", "carefully", "jet", "productivity", "investors", "crown", "par", "underground", "diagnosis", "maker", "crack", "principle", "picks", "vacations", "gang", "semester", "calculated", "cumshot", "fetish", "applies", "casinos", "appearance", "smoke", "apache", "filters", "incorporated", "nv", "craft", "cake", "notebooks", "apart", "fellow", "blind", "lounge", "mad", "algorithm", "semi", "coins", "andy", "gross", "strongly", "cafe", "valentine", "hilton", "ken", "proteins", "horror", "su", "exp", "familiar", "capable", "douglas", "debian", "till", "involving", "pen", "investing", "christopher", "admission", "epson", "shoe", "elected", "carrying", "victory", "sand", "madison", "terrorism", "joy", "editions", "cpu", "mainly", "ethnic", "ran", "parliament", "actor", "finds", "seal", "situations", "fifth", "allocated", "citizen", "vertical", "corrections", "structural", "municipal", "describes", "prize", "sr", "occurs", "jon", "absolute", "disabilities", "consists", "anytime", "substance", "prohibited", "addressed", "lies", "pipe", "soldiers", "nr", "guardian", "lecture", "simulation", "layout", "initiatives", "ill", "concentration", "classics", "lbs", "lay", "interpretation", "horses", "lol", "dirty", "deck", "wayne", "donate", "taught", "bankruptcy", "mp", "worker", "optimization", "alive", "temple", "substances", "prove", "discovered", "wings", "breaks", "genetic", "restrictions", "participating", "waters", "promise", "thin", "exhibition", "prefer", "ridge", "cabinet", "modem", "harris", "mph", "bringing", "sick", "dose", "evaluate", "tiffany", "tropical", "collect", "bet", "composition", "toyota", "streets", "nationwide", "vector", "definitely", "shaved", "turning", "buffer", "purple", "existence", "commentary", "larry", "limousines", "developments", "def", "immigration", "destinations", "lets", "mutual", "pipeline", "necessarily", "syntax", "li", "attribute", "prison", "skill", "chairs", "nl", "everyday", "apparently", "surrounding", "mountains", "moves", "popularity", "inquiry", "ethernet", "checked", "exhibit", "throw", "trend", "sierra", "visible", "cats", "desert", "postposted", "ya", "oldest", "rhode", "nba", "busty", "coordinator", "obviously", "mercury", "steven", "handbook", "greg", "navigate", "worse", "summit", "victims", "epa", "spaces", "fundamental", "burning", "escape", "coupons", "somewhat", "receiver", "substantial", "tr", "progressive", "cialis", "bb", "boats", "glance", "scottish", "championship", "arcade", "richmond", "sacramento", "impossible", "ron", "russell", "tells", "obvious", "fiber", "depression", "graph", "covering", "platinum", "judgment", "bedrooms", "talks", "filing", "foster", "modeling", "passing", "awarded", "testimonials", "trials", "tissue", "nz", "memorabilia", "clinton", "masters", "bonds", "cartridge", "alberta", "explanation", "folk", "org", "commons", "cincinnati", "subsection", "fraud", "electricity", "permitted", "spectrum", "arrival", "okay", "pottery", "emphasis", "roger", "aspect", "workplace", "awesome", "mexican", "confirmed", "counts", "priced", "wallpapers", "hist", "crash", "lift", "desired", "inter", "closer", "assumes", "heights", "shadow", "riding", "infection", "firefox", "lisa", "expense", "grove", "eligibility", "venture", "clinic", "korean", "healing", "princess", "mall", "entering", "packet", "spray", "studios", "involvement", "dad", "buttons", "placement", "observations", "vbulletin", "funded", "thompson", "winners", "extend", "roads", "subsequent", "pat", "dublin", "rolling", "fell", "motorcycle", "yard", "disclosure", "establishment", "memories", "nelson", "te", "arrived", "creates", "faces", "tourist", "cocks", "av", "mayor", "murder", "sean", "adequate", "senator", "yield", "presentations", "grades", "cartoons", "pour", "digest", "reg", "lodging", "tion", "dust", "hence", "wiki", "entirely", "replaced", "radar", "rescue", "undergraduate", "losses", "combat", "reducing", "stopped", "occupation", "lakes", "butt", "donations", "associations", "citysearch", "closely", "radiation", "diary", "seriously", "kings", "shooting", "kent", "adds", "nsw", "ear", "flags", "pci", "baker", "launched", "elsewhere", "pollution", "conservative", "guestbook", "shock", "effectiveness", "walls", "abroad", "ebony", "tie", "ward", "drawn", "arthur", "ian", "visited", "roof", "walker", "demonstrate", "atmosphere", "suggests", "kiss", "beast", "ra", "operated", "experiment", "targets", "overseas", "purchases", "dodge", "counsel", "federation", "pizza", "invited", "yards", "assignment", "chemicals", "gordon", "mod", "farmers", "rc", "queries", "bmw", "rush", "ukraine", "absence", "nearest", "cluster", "vendors", "mpeg", "whereas", "yoga", "serves", "woods", "surprise", "lamp", "rico", "partial", "shoppers", "phil", "everybody", "couples", "nashville", "ranking", "jokes", "cst", "http", "ceo", "simpson", "twiki", "sublime", "counseling", "palace", "acceptable", "satisfied", "glad", "wins", "measurements", "verify", "globe", "trusted", "copper", "milwaukee", "rack", "medication", "warehouse", "shareware", "ec", "rep", "dicke", "kerry", "receipt", "supposed", "ordinary", "nobody", "ghost", "violation", "configure", "stability", "mit", "applying", "southwest", "boss", "pride", "institutional", "expectations", "independence", "knowing", "reporter", "metabolism", "keith", "champion", "cloudy", "linda", "ross", "personally", "chile", "anna", "plenty", "solo", "sentence", "throat", "ignore", "maria", "uniform", "excellence", "wealth", "tall", "rm", "somewhere", "vacuum", "dancing", "attributes", "recognize", "brass", "writes", "plaza", "pdas", "outcomes", "survival", "quest", "publish", "sri", "screening", "toe", "thumbnail", "trans", "jonathan", "whenever", "nova", "lifetime", "api", "pioneer", "booty", "forgotten", "acrobat", "plates", "acres", "venue", "athletic", "thermal", "essays", "behaviour", "vital", "telling", "fairly", "coastal", "config", "cf", "charity", "intelligent", "edinburgh", "vt", "excel", "modes", "obligation", "campbell", "wake", "stupid", "harbor", "hungary", "traveler", "urw", "segment", "realize", "regardless", "lan", "enemy", "puzzle", "rising", "aluminum", "wells", "wishlist", "opens", "insight", "sms", "shit", "restricted", "republican", "secrets", "lucky", "latter", "merchants", "thick", "trailers", "repeat", "syndrome", "philips", "attendance", "penalty", "drum", "glasses", "enables", "nec", "iraqi", "builder", "vista", "jessica", "chips", "terry", "flood", "foto", "ease", "arguments", "amsterdam", "orgy", "arena", "adventures", "pupils", "stewart", "announcement", "tabs", "outcome", "xx", "appreciate", "expanded", "casual", "grown", "polish", "lovely", "extras", "gm", "centres", "jerry", "clause", "smile", "lands", "ri", "troops", "indoor", "bulgaria", "armed", "broker", "charger", "regularly", "believed", "pine", "cooling", "tend", "gulf", "rt", "rick", "trucks", "cp", "mechanisms", "divorce", "laura", "shopper", "tokyo", "partly", "nikon", "customize", "tradition", "candy", "pills", "tiger", "donald", "folks", "sensor", "exposed", "telecom", "hunt", "angels", "deputy", "indicators", "sealed", "thai", "emissions", "physicians", "loaded", "fred", "complaint", "scenes", "experiments", "balls", "afghanistan", "dd", "boost", "spanking", "scholarship", "governance", "mill", "founded", "supplements", "chronic", "icons", "tranny", "moral", "den", "catering", "aud", "finger", "keeps", "pound", "locate", "camcorder", "pl", "trained", "burn", "implementing", "roses", "labs", "ourselves", "bread", "tobacco", "wooden", "motors", "tough", "roberts", "incident", "gonna", "dynamics", "lie", "crm", "rf", "conversation", "decrease", "cumshots", "chest", "pension", "billy", "revenues", "emerging", "worship", "bukkake", "capability", "ak", "fe", "craig", "herself", "producing", "churches", "precision", "damages", "reserves", "contributed", "solve", "shorts", "reproduction", "minority", "td", "diverse", "amp", "ingredients", "sb", "ah", "johnny", "sole", "franchise", "recorder", "complaints", "facing", "sm", "nancy", "promotions", "tones", "passion", "rehabilitation", "maintaining", "sight", "laid", "clay", "defence", "patches", "weak", "refund", "usc", "towns", "environments", "trembl", "divided", "blvd", "reception", "amd", "wise", "emails", "cyprus", "wv", "odds", "correctly", "insider", "seminars", "consequences", "makers", "hearts", "geography", "appearing", "integrity", "worry", "ns", "discrimination", "eve", "carter", "legacy", "marc", "pleased", "danger", "vitamin", "widely", "processed", "phrase", "genuine", "raising", "implications", "functionality", "paradise", "hybrid", "reads", "roles", "intermediate", "emotional", "sons", "leaf", "pad", "glory", "platforms", "ja", "bigger", "billing", "diesel", "versus", "combine", "overnight", "geographic", "exceed", "bs", "rod", "saudi", "fault", "cuba", "hrs", "preliminary", "districts", "introduce", "silk", "promotional", "kate", "chevrolet", "babies", "bi", "karen", "compiled", "romantic", "revealed", "specialists", "generator", "albert", "examine", "jimmy", "graham", "suspension", "bristol", "margaret", "compaq", "sad", "correction", "wolf", "slowly", "authentication", "communicate", "rugby", "supplement", "showtimes", "cal", "portions", "infant", "promoting", "sectors", "samuel", "fluid", "grounds", "fits", "kick", "regards", "meal", "ta", "hurt", "machinery", "bandwidth", "unlike", "equation", "baskets", "probability", "pot", "dimension", "wright", "img", "barry", "proven", "schedules", "admissions", "cached", "warren", "slip", "studied", "reviewer", "involves", "quarterly", "rpm", "profits", "devil", "grass", "comply", "marie", "florist", "illustrated", "cherry", "continental", "alternate", "deutsch", "achievement", "limitations", "kenya", "webcam", "cuts", "funeral", "nutten", "earrings", "enjoyed", "automated", "chapters", "pee", "charlie", "quebec", "nipples", "passenger", "convenient", "dennis", "mars", "francis", "tvs", "sized", "manga", "noticed", "socket", "silent", "literary", "egg", "mhz", "signals", "caps", "orientation", "pill", "theft", "childhood", "swing", "symbols", "lat", "meta", "humans", "analog", "facial", "choosing", "talent", "dated", "flexibility", "seeker", "wisdom", "shoot", "boundary", "mint", "packard", "offset", "payday", "philip", "elite", "gi", "spin", "holders", "believes", "swedish", "poems", "deadline", "jurisdiction", "robot", "displaying", "witness", "collins", "equipped", "stages", "encouraged", "sur", "winds", "powder", "broadway", "acquired", "assess", "wash", "cartridges", "stones", "entrance", "gnome", "roots", "declaration", "losing", "attempts", "gadgets", "noble", "glasgow", "automation", "impacts", "rev", "gospel", "advantages", "shore", "loves", "induced", "ll", "knight", "preparing", "loose", "aims", "recipient", "linking", "extensions", "appeals", "cl", "earned", "illness", "islamic", "athletics", "southeast", "ieee", "ho", "alternatives", "pending", "parker", "determining", "lebanon", "corp", "personalized", "kennedy", "gt", "sh", "conditioning", "teenage", "soap", "ae", "triple", "cooper", "nyc", "vincent", "jam", "secured", "unusual", "answered", "partnerships", "destruction", "slots", "increasingly", "migration", "disorder", "routine", "toolbar", "basically", "rocks", "conventional", "titans", "applicants", "wearing", "axis", "sought", "genes", "mounted", "habitat", "firewall", "median", "guns", "scanner", "herein", "occupational", "animated", "horny", "judicial", "rio", "hs", "adjustment", "hero", "integer", "treatments", "bachelor", "attitude", "camcorders", "engaged", "falling", "basics", "montreal", "carpet", "rv", "struct", "lenses", "binary", "genetics", "attended", "difficulty", "punk", "collective", "coalition", "pi", "dropped", "enrollment", "duke", "walter", "ai", "pace", "besides", "wage", "producers", "ot", "collector", "arc", "hosts", "interfaces", "advertisers", "moments", "atlas", "strings", "dawn", "representing", "observation", "feels", "torture", "carl", "deleted", "coat", "mitchell", "mrs", "rica", "restoration", "convenience", "returning", "ralph", "opposition", "container", "yr", "defendant", "warner", "confirmation", "app", "embedded", "inkjet", "supervisor", "wizard", "corps", "actors", "liver", "peripherals", "liable", "brochure", "morris", "bestsellers", "petition", "eminem", "recall", "antenna", "picked", "assumed", "departure", "minneapolis", "belief", "killing", "bikini", "memphis", "shoulder", "decor", "lookup", "texts", "harvard", "brokers", "roy", "ion", "diameter", "ottawa", "doll", "ic", "podcast", "tit", "seasons", "peru", "interactions", "refine", "bidder", "singer", "evans", "herald", "literacy", "fails", "aging", "nike", "intervention", "pissing", "fed", "plugin", "attraction", "diving", "invite", "modification", "alice", "latinas", "suppose", "customized", "reed", "involve", "moderate", "terror", "younger", "thirty", "mice", "opposite", "understood", "rapidly", "dealtime", "ban", "temp", "intro", "mercedes", "zus", "assurance", "fisting", "clerk", "happening", "vast", "mills", "outline", "amendments", "tramadol", "holland", "receives", "jeans", "metropolitan", "compilation", "verification", "fonts", "ent", "odd", "wrap", "refers", "mood", "favor", "veterans", "quiz", "mx", "sigma", "gr", "attractive", "xhtml", "occasion", "recordings", "jefferson", "victim", "demands", "sleeping", "careful", "ext", "beam", "gardening", "obligations", "arrive", "orchestra", "sunset", "tracked", "moreover", "minimal", "polyphonic", "lottery", "tops", "framed", "aside", "outsourcing", "licence", "adjustable", "allocation", "michelle", "essay", "discipline", "amy", "ts", "demonstrated", "dialogue", "identifying", "alphabetical", "camps", "declared", "dispatched", "aaron", "handheld", "trace", "disposal", "shut", "florists", "packs", "ge", "installing", "switches", "romania", "voluntary", "ncaa", "thou", "consult", "phd", "greatly", "blogging", "mask", "cycling", "midnight", "ng", "commonly", "pe", "photographer", "inform", "turkish", "coal", "cry", "messaging", "pentium", "quantum", "murray", "intent", "tt", "zoo", "largely", "pleasant", "announce", "constructed", "additions", "requiring", "spoke", "aka", "arrow", "engagement", "sampling", "rough", "weird", "tee", "refinance", "lion", "inspired", "holes", "weddings", "blade", "suddenly", "oxygen", "cookie", "meals", "canyon", "goto", "meters", "merely", "calendars", "arrangement", "conclusions", "passes", "bibliography", "pointer", "compatibility", "stretch", "durham", "furthermore", "permits", "cooperative", "muslim", "xl", "neil", "sleeve", "netscape", "cleaner", "cricket", "beef", "feeding", "stroke", "township", "rankings", "measuring", "cad", "hats", "robin", "robinson", "jacksonville", "strap", "headquarters", "sharon", "crowd", "tcp", "transfers", "surf", "olympic", "transformation", "remained", "attachments", "dv", "dir", "entities", "customs", "administrators", "personality", "rainbow", "hook", "roulette", "decline", "gloves", "israeli", "medicare", "cord", "skiing", "cloud", "facilitate", "subscriber", "valve", "val", "hewlett", "explains", "proceed", "flickr", "feelings", "knife", "jamaica", "priorities", "shelf", "bookstore", "timing", "liked", "parenting", "adopt", "denied", "fotos", "incredible", "britney", "freeware", "fucked", "donation", "outer", "crop", "deaths", "rivers", "commonwealth", "pharmaceutical", "manhattan", "tales", "katrina", "workforce", "islam", "nodes", "tu", "fy", "thumbs", "seeds", "cited", "lite", "ghz", "hub", "targeted", "organizational", "skype", "realized", "twelve", "founder", "decade", "gamecube", "rr", "dispute", "portuguese", "tired", "titten", "adverse", "everywhere", "excerpt", "eng", "steam", "discharge", "ef", "drinks", "ace", "voices", "acute", "halloween", "climbing", "stood", "sing", "tons", "perfume", "carol", "honest", "albany", "hazardous", "restore", "stack", "methodology", "somebody", "sue", "ep", "housewares", "reputation", "resistant", "democrats", "recycling", "hang", "gbp", "curve", "creator", "amber", "qualifications", "museums", "coding", "slideshow", "tracker", "variation", "passage", "transferred", "trunk", "hiking", "lb", "damn", "pierre", "jelsoft", "headset", "photograph", "oakland", "colombia", "waves", "camel", "distributor", "lamps", "underlying", "hood", "wrestling", "suicide", "archived", "photoshop", "jp", "chi", "bt", "arabia", "gathering", "projection", "juice", "chase", "mathematical", "logical", "sauce", "fame", "extract", "specialized", "diagnostic", "panama", "indianapolis", "af", "payable", "corporations", "courtesy", "criticism", "automobile", "confidential", "rfc", "statutory", "accommodations", "athens", "northeast", "downloaded", "judges", "sl", "seo", "retired", "isp", "remarks", "detected", "decades", "paintings", "walked", "arising", "nissan", "bracelet", "ins", "eggs", "juvenile", "injection", "yorkshire", "populations", "protective", "afraid", "acoustic", "railway", "cassette", "initially", "indicator", "pointed", "hb", "jpg", "causing", "mistake", "norton", "locked", "eliminate", "tc", "fusion", "mineral", "sunglasses", "ruby", "steering", "beads", "fortune", "preference", "canvas", "threshold", "parish", "claimed", "screens", "cemetery", "planner", "croatia", "flows", "stadium", "venezuela", "exploration", "mins", "fewer", "sequences", "coupon", "nurses", "ssl", "stem", "proxy", "gangbang", "astronomy", "lanka", "opt", "edwards", "drew", "contests", "flu", "translate", "announces", "mlb", "costume", "tagged", "berkeley", "voted", "killer", "bikes", "gates", "adjusted", "rap", "tune", "bishop", "pulled", "corn", "gp", "shaped", "compression", "seasonal", "establishing", "farmer", "counters", "puts", "constitutional", "grew", "perfectly", "tin", "slave", "instantly", "cultures", "norfolk", "coaching", "examined", "trek", "encoding", "litigation", "submissions", "oem", "heroes", "painted", "lycos", "ir", "zdnet", "broadcasting", "horizontal", "artwork", "cosmetic", "resulted", "portrait", "terrorist", "informational", "ethical", "carriers", "ecommerce", "mobility", "floral", "builders", "ties", "struggle", "schemes", "suffering", "neutral", "fisher", "rat", "spears", "prospective", "dildos", "bedding", "ultimately", "joining", "heading", "equally", "artificial", "bearing", "spectacular", "coordination", "connector", "brad", "combo", "seniors", "worlds", "guilty", "affiliated", "activation", "naturally", "haven", "tablet", "jury", "dos", "tail", "subscribers", "charm", "lawn", "violent", "mitsubishi", "underwear", "basin", "soup", "potentially", "ranch", "constraints", "crossing", "inclusive", "dimensional", "cottage", "drunk", "considerable", "crimes", "resolved", "mozilla", "byte", "toner", "nose", "latex", "branches", "anymore", "oclc", "delhi", "holdings", "alien", "locator", "selecting", "processors", "pantyhose", "plc", "broke", "nepal", "zimbabwe", "difficulties", "juan", "complexity", "msg", "constantly", "browsing", "resolve", "barcelona", "presidential", "documentary", "cod", "territories", "melissa", "moscow", "thesis", "thru", "jews", "nylon", "palestinian", "discs", "rocky", "bargains", "frequent", "trim", "nigeria", "ceiling", "pixels", "ensuring", "hispanic", "cv", "cb", "legislature", "hospitality", "gen", "anybody", "procurement", "diamonds", "espn", "fleet", "untitled", "bunch", "totals", "marriott", "singing", "theoretical", "afford", "exercises", "starring", "referral", "nhl", "surveillance", "optimal", "quit", "distinct", "protocols", "lung", "highlight", "substitute", "inclusion", "hopefully", "brilliant", "turner", "sucking", "cents", "reuters", "ti", "fc", "gel", "todd", "spoken", "omega", "evaluated", "stayed", "civic", "assignments", "fw", "manuals", "doug", "sees", "termination", "watched", "saver", "thereof", "grill", "households", "gs", "redeem", "rogers", "grain", "aaa", "authentic", "regime", "wanna", "wishes", "bull", "montgomery", "architectural", "louisville", "depend", "differ", "macintosh", "movements", "ranging", "monica", "repairs", "breath", "amenities", "virtually", "cole", "mart", "candle", "hanging", "colored", "authorization", "tale", "verified", "lynn", "formerly", "projector", "bp", "situated", "comparative", "std", "seeks", "herbal", "loving", "strictly", "routing", "docs", "stanley", "psychological", "surprised", "retailer", "vitamins", "elegant", "gains", "renewal", "vid", "genealogy", "opposed", "deemed", "scoring", "expenditure", "panties", "brooklyn", "liverpool", "sisters", "critics", "connectivity", "spots", "oo", "algorithms", "hacker", "madrid", "similarly", "margin", "coin", "bbw", "solely", "fake", "salon", "collaborative", "norman", "fda", "excluding", "turbo", "headed", "voters", "cure", "madonna", "commander", "arch", "ni", "murphy", "thinks", "thats", "suggestion", "hdtv", "soldier", "phillips", "asin", "aimed", "justin", "bomb", "harm", "interval", "mirrors", "spotlight", "tricks", "reset", "brush", "investigate", "thy", "expansys", "panels", "repeated", "assault", "connecting", "spare", "logistics", "deer", "kodak", "tongue", "bowling", "tri", "danish", "pal", "monkey", "proportion", "filename", "skirt", "florence", "invest", "honey", "um", "analyses", "drawings", "significance", "scenario", "ye", "fs", "lovers", "atomic", "approx", "symposium", "arabic", "gauge", "essentials", "junction", "protecting", "nn", "faced", "mat", "rachel", "solving", "transmitted", "weekends", "screenshots", "produces", "oven", "ted", "intensive", "chains", "kingston", "sixth", "engage", "deviant", "noon", "switching", "quoted", "adapters", "correspondence", "farms", "imports", "supervision", "cheat", "bronze", "expenditures", "sandy", "separation", "testimony", "suspect", "celebrities", "macro", "sender", "mandatory", "boundaries", "crucial", "syndication", "gym", "celebration", "kde", "adjacent", "filtering", "tuition", "spouse", "exotic", "viewer", "signup", "threats", "luxembourg", "puzzles", "reaching", "vb", "damaged", "cams", "receptor", "piss", "laugh", "joel", "surgical", "destroy", "citation", "pitch", "autos", "yo", "premises", "perry", "proved", "offensive", "imperial", "dozen", "benjamin", "deployment", "teeth", "cloth", "studying", "colleagues", "stamp", "lotus", "salmon", "olympus", "separated", "proc", "cargo", "tan", "directive", "fx", "salem", "mate", "dl", "starter", "upgrades", "likes", "butter", "pepper", "weapon", "luggage", "burden", "chef", "tapes", "zones", "races", "isle", "stylish", "slim", "maple", "luke", "grocery", "offshore", "governing", "retailers", "depot", "kenneth", "comp", "alt", "pie", "blend", "harrison", "ls", "julie", "occasionally", "cbs", "attending", "emission", "pete", "spec", "finest", "realty", "janet", "bow", "penn", "recruiting", "apparent", "instructional", "phpbb", "autumn", "traveling", "probe", "midi", "permissions", "biotechnology", "toilet", "ranked", "jackets", "routes", "packed", "excited", "outreach", "helen", "mounting", "recover", "tied", "lopez", "balanced", "prescribed", "catherine", "timely", "talked", "upskirts", "debug", "delayed", "chuck", "reproduced", "hon", "dale", "explicit", "calculation", "villas", "ebook", "consolidated", "boob", "exclude", "peeing", "occasions", "brooks", "equations", "newton", "oils", "sept", "exceptional", "anxiety", "bingo", "whilst", "spatial", "respondents", "unto", "lt", "ceramic", "prompt", "precious", "minds", "annually", "considerations", "scanners", "atm", "xanax", "eq", "pays", "cox", "fingers", "sunny", "ebooks", "delivers", "je", "queensland", "necklace", "musicians", "leeds", "composite", "unavailable", "cedar", "arranged", "lang", "theaters", "advocacy", "raleigh", "stud", "fold", "essentially", "designing", "threaded", "uv", "qualify", "fingering", "blair", "hopes", "assessments", "cms", "mason", "diagram", "burns", "pumps", "slut", "ejaculation", "footwear", "sg", "vic", "beijing", "peoples", "victor", "mario", "pos", "attach", "licenses", "utils", "removing", "advised", "brunswick", "spider", "phys", "ranges", "pairs", "sensitivity", "trails", "preservation", "hudson", "isolated", "calgary", "interim", "assisted", "divine", "streaming", "approve", "chose", "compound", "intensity", "technological", "syndicate", "abortion", "dialog", "venues", "blast", "wellness", "calcium", "newport", "antivirus", "addressing", "pole", "discounted", "indians", "shield", "harvest", "membrane", "prague", "previews", "bangladesh", "constitute", "locally", "concluded", "pickup", "desperate", "mothers", "nascar", "iceland", "demonstration", "governmental", "manufactured", "candles", "graduation", "mega", "bend", "sailing", "variations", "moms", "sacred", "addiction", "morocco", "chrome", "tommy", "springfield", "refused", "brake", "exterior", "greeting", "ecology", "oliver", "congo", "glen", "botswana", "nav", "delays", "synthesis", "olive", "undefined", "unemployment", "cyber", "verizon", "scored", "enhancement", "newcastle", "clone", "dicks", "velocity", "lambda", "relay", "composed", "tears", "performances", "oasis", "baseline", "cab", "angry", "fa", "societies", "silicon", "brazilian", "identical", "petroleum", "compete", "ist", "norwegian", "lover", "belong", "honolulu", "beatles", "lips", "escort", "retention", "exchanges", "pond", "rolls", "thomson", "barnes", "soundtrack", "wondering", "malta", "daddy", "lc", "ferry", "rabbit", "profession", "seating", "dam", "cnn", "separately", "physiology", "lil", "collecting", "das", "exports", "omaha", "tire", "participant", "scholarships", "recreational", "dominican", "chad", "electron", "loads", "friendship", "heather", "passport", "motel", "unions", "treasury", "warrant", "sys", "solaris", "frozen", "occupied", "josh", "royalty", "scales", "rally", "observer", "sunshine", "strain", "drag", "ceremony", "somehow", "arrested", "expanding", "provincial", "investigations", "icq", "ripe", "yamaha", "rely", "medications", "hebrew", "gained", "rochester", "dying", "laundry", "stuck", "solomon", "placing", "stops", "homework", "adjust", "assessed", "advertiser", "enabling", "encryption", "filling", "downloadable", "sophisticated", "imposed", "silence", "scsi", "focuses", "soviet", "possession", "cu", "laboratories", "treaty", "vocal", "trainer", "organ", "stronger", "volumes", "advances", "vegetables", "lemon", "toxic", "dns", "thumbnails", "darkness", "pty", "ws", "nuts", "nail", "bizrate", "vienna", "implied", "span", "stanford", "sox", "stockings", "joke", "respondent", "packing", "statute", "rejected", "satisfy", "destroyed", "shelter", "chapel", "gamespot", "manufacture", "layers", "wordpress", "guided", "vulnerability", "accountability", "celebrate", "accredited", "appliance", "compressed", "bahamas", "powell", "mixture", "zoophilia", "bench", "univ", "tub", "rider", "scheduling", "radius", "perspectives", "mortality", "logging", "hampton", "christians", "borders", "therapeutic", "pads", "butts", "inns", "bobby", "impressive", "sheep", "accordingly", "architect", "railroad", "lectures", "challenging", "wines", "nursery", "harder", "cups", "ash", "microwave", "cheapest", "accidents", "travesti", "relocation", "stuart", "contributors", "salvador", "ali", "salad", "np", "monroe", "tender", "violations", "foam", "temperatures", "paste", "clouds", "competitions", "discretion", "tft", "tanzania", "preserve", "jvc", "poem", "vibrator", "unsigned", "staying", "cosmetics", "easter", "theories", "repository", "praise", "jeremy", "venice", "jo", "concentrations", "vibrators", "estonia", "christianity", "veteran", "streams", "landing", "signing", "executed", "katie", "negotiations", "realistic", "dt", "cgi", "showcase", "integral", "asks", "relax", "namibia", "generating", "christina", "congressional", "synopsis", "hardly", "prairie", "reunion", "composer", "bean", "sword", "absent", "photographic", "sells", "ecuador", "hoping", "accessed", "spirits", "modifications", "coral", "pixel", "float", "colin", "bias", "imported", "paths", "bubble", "por", "acquire", "contrary", "millennium", "tribune", "vessel", "acids", "focusing", "viruses", "cheaper", "admitted", "dairy", "admit", "mem", "fancy", "equality", "samoa", "gc", "achieving", "tap", "stickers", "fisheries", "exceptions", "reactions", "leasing", "lauren", "beliefs", "ci", "macromedia", "companion", "squad", "analyze", "ashley", "scroll", "relate", "divisions", "swim", "wages", "additionally", "suffer", "forests", "fellowship", "nano", "invalid", "concerts", "martial", "males", "victorian", "retain", "colours", "execute", "tunnel", "genres", "cambodia", "patents", "copyrights", "yn", "chaos", "lithuania", "mastercard", "wheat", "chronicles", "obtaining", "beaver", "updating", "distribute", "readings", "decorative", "kijiji", "confused", "compiler", "enlargement", "eagles", "bases", "vii", "accused", "bee", "campaigns", "unity", "loud", "conjunction", "bride", "rats", "defines", "airports", "instances", "indigenous", "begun", "cfr", "brunette", "packets", "anchor", "socks", "validation", "parade", "corruption", "stat", "trigger", "incentives", "cholesterol", "gathered", "essex", "slovenia", "notified", "differential", "beaches", "folders", "dramatic", "surfaces", "terrible", "routers", "cruz", "pendant", "dresses", "baptist", "scientist", "starsmerchant", "hiring", "clocks", "arthritis", "bios", "females", "wallace", "nevertheless", "reflects", "taxation", "fever", "pmc", "cuisine", "surely", "practitioners", "transcript", "myspace", "theorem", "inflation", "thee", "nb", "ruth", "pray", "stylus", "compounds", "pope", "drums", "contracting", "topless", "arnold", "structured", "reasonably", "jeep", "chicks", "bare", "hung", "cattle", "mba", "radical", "graduates", "rover", "recommends", "controlling", "treasure", "reload", "distributors", "flame", "levitra", "tanks", "assuming", "monetary", "elderly", "pit", "arlington", "mono", "particles", "floating", "extraordinary", "tile", "indicating", "bolivia", "spell", "hottest", "stevens", "coordinate", "kuwait", "exclusively", "emily", "alleged", "limitation", "widescreen", "compile", "squirting", "webster", "struck", "rx", "illustration", "plymouth", "warnings", "construct", "apps", "inquiries", "bridal", "annex", "mag", "gsm", "inspiration", "tribal", "curious", "affecting", "freight", "rebate", "meetup", "eclipse", "sudan", "ddr", "downloading", "rec", "shuttle", "aggregate", "stunning", "cycles", "affects", "forecasts", "detect", "sluts", "actively", "ciao", "ampland", "knee", "prep", "pb", "complicated", "chem", "fastest", "butler", "shopzilla", "injured", "decorating", "payroll", "cookbook", "expressions", "ton", "courier", "uploaded", "shakespeare", "hints", "collapse", "americas", "connectors", "twinks", "unlikely", "oe", "gif", "pros", "conflicts", "techno", "beverage", "tribute", "wired", "elvis", "immune", "latvia", "travelers", "forestry", "barriers", "cant", "jd", "rarely", "gpl", "infected", "offerings", "martha", "genesis", "barrier", "argue", "incorrect", "trains", "metals", "bicycle", "furnishings", "letting", "arise", "guatemala", "celtic", "thereby", "irc", "jamie", "particle", "perception", "minerals", "advise", "humidity", "bottles", "boxing", "wy", "dm", "bangkok", "renaissance", "pathology", "sara", "bra", "ordinance", "hughes", "photographers", "bitch", "infections", "jeffrey", "chess", "operates", "brisbane", "configured", "survive", "oscar", "festivals", "menus", "joan", "possibilities", "duck", "reveal", "canal", "amino", "phi", "contributing", "herbs", "clinics", "mls", "cow", "manitoba", "analytical", "missions", "watson", "lying", "costumes", "strict", "dive", "saddam", "circulation", "drill", "offense", "threesome", "bryan", "cet", "protest", "handjob", "assumption", "jerusalem", "hobby", "tries", "transexuales", "invention", "nickname", "fiji", "technician", "inline", "executives", "enquiries", "washing", "audi", "staffing", "cognitive", "exploring", "trick", "enquiry", "closure", "raid", "ppc", "timber", "volt", "intense", "div", "playlist", "registrar", "showers", "supporters", "ruling", "steady", "dirt", "statutes", "withdrawal", "myers", "drops", "predicted", "wider", "saskatchewan", "jc", "cancellation", "plugins", "enrolled", "sensors", "screw", "ministers", "publicly", "hourly", "blame", "geneva", "freebsd", "veterinary", "acer", "prostores", "reseller", "dist", "handed", "suffered", "intake", "informal", "relevance", "incentive", "butterfly", "tucson", "mechanics", "heavily", "swingers", "fifty", "headers", "mistakes", "numerical", "ons", "geek", "uncle", "defining", "xnxx", "counting", "reflection", "sink", "accompanied", "assure", "invitation", "devoted", "princeton", "jacob", "sodium", "randy", "spirituality", "hormone", "meanwhile", "proprietary", "timothy", "childrens", "brick", "grip", "naval", "thumbzilla", "medieval", "porcelain", "avi", "bridges", "pichunter", "captured", "watt", "thehun", "decent", "casting", "dayton", "translated", "shortly", "cameron", "columnists", "pins", "carlos", "reno", "donna", "andreas", "warrior", "diploma", "cabin", "innocent", "bdsm", "scanning", "ide", "consensus", "polo", "valium", "copying", "rpg", "delivering", "cordless", "patricia", "horn", "eddie", "uganda", "fired", "journalism", "pd", "prot", "trivia", "adidas", "perth", "frog", "grammar", "intention", "syria", "disagree", "klein", "harvey", "tires", "logs", "undertaken", "tgp", "hazard", "retro", "leo", "livesex", "statewide", "semiconductor", "gregory", "episodes", "boolean", "circular", "anger", "diy", "mainland", "illustrations", "suits", "chances", "interact", "snap", "happiness", "arg", "substantially", "bizarre", "glenn", "ur", "auckland", "olympics", "fruits", "identifier", "geo", "worldsex", "ribbon", "calculations", "doe", "jpeg", "conducting", "startup", "suzuki", "trinidad", "ati", "kissing", "wal", "handy", "swap", "exempt", "crops", "reduces", "accomplished", "calculators", "geometry", "impression", "abs", "slovakia", "flip", "guild", "correlation", "gorgeous", "capitol", "sim", "dishes", "rna", "barbados", "chrysler", "nervous", "refuse", "extends", "fragrance", "mcdonald", "replica", "plumbing", "brussels", "tribe", "neighbors", "trades", "superb", "buzz", "transparent", "nuke", "rid", "trinity", "charleston", "handled", "legends", "boom", "calm", "champions", "floors", "selections", "projectors", "inappropriate", "exhaust", "comparing", "shanghai", "speaks", "burton", "vocational", "davidson", "copied", "scotia", "farming", "gibson", "pharmacies", "fork", "troy", "ln", "roller", "introducing", "batch", "organize", "appreciated", "alter", "nicole", "latino", "ghana", "edges", "uc", "mixing", "handles", "skilled", "fitted", "albuquerque", "harmony", "distinguished", "asthma", "projected", "assumptions", "shareholders", "twins", "developmental", "rip", "zope", "regulated", "triangle", "amend", "anticipated", "oriental", "reward", "windsor", "zambia", "completing", "gmbh", "buf", "ld", "hydrogen", "webshots", "sprint", "comparable", "chick", "advocate", "sims", "confusion", "copyrighted", "tray", "inputs", "warranties", "genome", "escorts", "documented", "thong", "medal", "paperbacks", "coaches", "vessels", "harbour", "walks", "sucks", "sol", "keyboards", "sage", "knives", "eco", "vulnerable", "arrange", "artistic", "bat", "honors", "booth", "indie", "reflected", "unified", "bones", "breed", "detector", "ignored", "polar", "fallen", "precise", "sussex", "respiratory", "notifications", "msgid", "transexual", "mainstream", "invoice", "evaluating", "lip", "subcommittee", "sap", "gather", "suse", "maternity", "backed", "alfred", "colonial", "mf", "carey", "motels", "forming", "embassy", "cave", "journalists", "danny", "rebecca", "slight", "proceeds", "indirect", "amongst", "wool", "foundations", "msgstr", "arrest", "volleyball", "mw", "adipex", "horizon", "nu", "deeply", "toolbox", "ict", "marina", "liabilities", "prizes", "bosnia", "browsers", "decreased", "patio", "dp", "tolerance", "surfing", "creativity", "lloyd", "describing", "optics", "pursue", "lightning", "overcome", "eyed", "ou", "quotations", "grab", "inspector", "attract", "brighton", "beans", "bookmarks", "ellis", "disable", "snake", "succeed", "leonard", "lending", "oops", "reminder", "nipple", "xi", "searched", "behavioral", "riverside", "bathrooms", "plains", "sku", "ht", "raymond", "insights", "abilities", "initiated", "sullivan", "za", "midwest", "karaoke", "trap", "lonely", "fool", "ve", "nonprofit", "lancaster", "suspended", "hereby", "observe", "julia", "containers", "attitudes", "karl", "berry", "collar", "simultaneously", "racial", "integrate", "bermuda", "amanda", "sociology", "mobiles", "screenshot", "exhibitions", "kelkoo", "confident", "retrieved", "exhibits", "officially", "consortium", "dies", "terrace", "bacteria", "pts", "replied", "seafood", "novels", "rh", "rrp", "recipients", "playboy", "ought", "delicious", "traditions", "fg", "jail", "safely", "finite", "kidney", "periodically", "fixes", "sends", "durable", "mazda", "allied", "throws", "moisture", "hungarian", "roster", "referring", "symantec", "spencer", "wichita", "nasdaq", "uruguay", "ooo", "hz", "transform", "timer", "tablets", "tuning", "gotten", "educators", "tyler", "futures", "vegetable", "verse", "highs", "humanities", "independently", "wanting", "custody", "scratch", "launches", "ipaq", "alignment", "masturbating", "henderson", "bk", "britannica", "comm", "ellen", "competitors", "nhs", "rocket", "aye", "bullet", "towers", "racks", "lace", "nasty", "visibility", "latitude", "consciousness", "ste", "tumor", "ugly", "deposits", "beverly", "mistress", "encounter", "trustees", "watts", "duncan", "reprints", "hart", "bernard", "resolutions", "ment", "accessing", "forty", "tubes", "attempted", "col", "midlands", "priest", "floyd", "ronald", "analysts", "queue", "dx", "sk", "trance", "locale", "nicholas", "biol", "yu", "bundle", "hammer", "invasion", "witnesses", "runner", "rows", "administered", "notion", "sq", "skins", "mailed", "oc", "fujitsu", "spelling", "arctic", "exams", "rewards", "beneath", "strengthen", "defend", "aj", "frederick", "medicaid", "treo", "infrared", "seventh", "gods", "une", "welsh", "belly", "aggressive", "tex", "advertisements", "quarters", "stolen", "cia", "sublimedirectory", "soonest", "haiti", "disturbed", "determines", "sculpture", "poly", "ears", "dod", "wp", "fist", "naturals", "neo", "motivation", "lenders", "pharmacology", "fitting", "fixtures", "bloggers", "mere", "agrees", "passengers", "quantities", "petersburg", "consistently", "powerpoint", "cons", "surplus", "elder", "sonic", "obituaries", "cheers", "dig", "taxi", "punishment", "appreciation", "subsequently", "om", "belarus", "nat", "zoning", "gravity", "providence", "thumb", "restriction", "incorporate", "backgrounds", "treasurer", "guitars", "essence", "flooring", "lightweight", "ethiopia", "tp", "mighty", "athletes", "humanity", "transcription", "jm", "holmes", "complications", "scholars", "dpi", "scripting", "gis", "remembered", "galaxy", "chester", "snapshot", "caring", "loc", "worn", "synthetic", "shaw", "vp", "segments", "testament", "expo", "dominant", "twist", "specifics", "itunes", "stomach", "partially", "buried", "cn", "newbie", "minimize", "darwin", "ranks", "wilderness", "debut", "generations", "tournaments", "bradley", "deny", "anatomy", "bali", "judy", "sponsorship", "headphones", "fraction", "trio", "proceeding", "cube", "defects", "volkswagen", "uncertainty", "breakdown", "milton", "marker", "reconstruction", "subsidiary", "strengths", "clarity", "rugs", "sandra", "adelaide", "encouraging", "furnished", "monaco", "settled", "folding", "emirates", "terrorists", "airfare", "comparisons", "beneficial", "distributions", "vaccine", "belize", "crap", "fate", "viewpicture", "promised", "volvo", "penny", "robust", "bookings", "threatened", "minolta", "republicans", "discusses", "gui", "porter", "gras", "jungle", "ver", "rn", "responded", "rim", "abstracts", "zen", "ivory", "alpine", "dis", "prediction", "pharmaceuticals", "andale", "fabulous", "remix", "alias", "thesaurus", "individually", "battlefield", "literally", "newer", "kay", "ecological", "spice", "oval", "implies", "cg", "soma", "ser", "cooler", "appraisal", "consisting", "maritime", "periodic", "submitting", "overhead", "ascii", "prospect", "shipment", "breeding", "citations", "geographical", "donor", "mozambique", "tension", "href", "benz", "trash", "shapes", "wifi", "tier", "fwd", "earl", "manor", "envelope", "diane", "homeland", "disclaimers", "championships", "excluded", "andrea", "breeds", "rapids", "disco", "sheffield", "bailey", "aus", "endif", "finishing", "emotions", "wellington", "incoming", "prospects", "lexmark", "cleaners", "bulgarian", "hwy", "eternal", "cashiers", "guam", "cite", "aboriginal", "remarkable", "rotation", "nam", "preventing", "productive", "boulevard", "eugene", "ix", "gdp", "pig", "metric", "compliant", "minus", "penalties", "bennett", "imagination", "hotmail", "refurbished", "joshua", "armenia", "varied", "grande", "closest", "activated", "actress", "mess", "conferencing", "assign", "armstrong", "politicians", "trackbacks", "lit", "accommodate", "tigers", "aurora", "una", "slides", "milan", "premiere", "lender", "villages", "shade", "chorus", "christine", "rhythm", "digit", "argued", "dietary", "symphony", "clarke", "sudden", "accepting", "precipitation", "marilyn", "lions", "findlaw", "ada", "pools", "tb", "lyric", "claire", "isolation", "speeds", "sustained", "matched", "approximate", "rope", "carroll", "rational", "programmer", "fighters", "chambers", "dump", "greetings", "inherited", "warming", "incomplete", "vocals", "chronicle", "fountain", "chubby", "grave", "legitimate", "biographies", "burner", "yrs", "foo", "investigator", "gba", "plaintiff", "finnish", "gentle", "bm", "prisoners", "deeper", "muslims", "hose", "mediterranean", "nightlife", "footage", "howto", "worthy", "reveals", "architects", "saints", "entrepreneur", "carries", "sig", "freelance", "duo", "excessive", "devon", "screensaver", "helena", "saves", "regarded", "valuation", "unexpected", "cigarette", "fog", "characteristic", "marion", "lobby", "egyptian", "tunisia", "metallica", "outlined", "consequently", "headline", "treating", "punch", "appointments", "str", "gotta", "cowboy", "narrative", "bahrain", "enormous", "karma", "consist", "betty", "queens", "academics", "pubs", "quantitative", "shemales", "lucas", "screensavers", "subdivision", "tribes", "vip", "defeat", "clicks", "distinction", "honduras", "naughty", "hazards", "insured", "harper", "livestock", "mardi", "exemption", "tenant", "sustainability", "cabinets", "tattoo", "shake", "algebra", "shadows", "holly", "formatting", "silly", "nutritional", "yea", "mercy", "hartford", "freely", "marcus", "sunrise", "wrapping", "mild", "fur", "nicaragua", "weblogs", "timeline", "tar", "belongs", "rj", "readily", "affiliation", "soc", "fence", "nudist", "infinite", "diana", "ensures", "relatives", "lindsay", "clan", "legally", "shame", "satisfactory", "revolutionary", "bracelets", "sync", "civilian", "telephony", "mesa", "fatal", "remedy", "realtors", "breathing", "briefly", "thickness", "adjustments", "graphical", "genius", "discussing", "aerospace", "fighter", "meaningful", "flesh", "retreat", "adapted", "barely", "wherever", "estates", "rug", "democrat", "borough", "maintains", "failing", "shortcuts", "ka", "retained", "voyeurweb", "pamela", "andrews", "marble", "extending", "jesse", "specifies", "hull", "logitech", "surrey", "briefing", "belkin", "dem", "accreditation", "wav", "blackberry", "highland", "meditation", "modular", "microphone", "macedonia", "combining", "brandon", "instrumental", "giants", "organizing", "shed", "balloon", "moderators", "winston", "memo", "ham", "solved", "tide", "kazakhstan", "hawaiian", "standings", "partition", "invisible", "gratuit", "consoles", "funk", "fbi", "qatar", "magnet", "translations", "porsche", "cayman", "jaguar", "reel", "sheer", "commodity", "posing", "wang", "kilometers", "rp", "bind", "thanksgiving", "rand", "hopkins", "urgent", "guarantees", "infants", "gothic", "cylinder", "witch", "buck", "indication", "eh", "congratulations", "tba", "cohen", "sie", "usgs", "puppy", "kathy", "acre", "graphs", "surround", "cigarettes", "revenge", "expires", "enemies", "lows", "controllers", "aqua", "chen", "emma", "consultancy", "finances", "accepts", "enjoying", "conventions", "eva", "patrol", "smell", "pest", "hc", "italiano", "coordinates", "rca", "fp", "carnival", "roughly", "sticker", "promises", "responding", "reef", "physically", "divide", "stakeholders", "hydrocodone", "gst", "consecutive", "cornell", "satin", "bon", "deserve", "attempting", "mailto", "promo", "jj", "representations", "chan", "worried", "tunes", "garbage", "competing", "combines", "mas", "beth", "bradford", "len", "phrases", "kai", "peninsula", "chelsea", "boring", "reynolds", "dom", "jill", "accurately", "speeches", "reaches", "schema", "considers", "sofa", "catalogs", "ministries", "vacancies", "quizzes", "parliamentary", "obj", "prefix", "lucia", "savannah", "barrel", "typing", "nerve", "dans", "planets", "deficit", "boulder", "pointing", "renew", "coupled", "viii", "myanmar", "metadata", "harold", "circuits", "floppy", "texture", "handbags", "jar", "ev", "somerset", "incurred", "acknowledge", "thoroughly", "antigua", "nottingham", "thunder", "tent", "caution", "identifies", "questionnaire", "qualification", "locks", "modelling", "namely", "miniature", "dept", "hack", "dare", "euros", "interstate", "pirates", "aerial", "hawk", "consequence", "rebel", "systematic", "perceived", "origins", "hired", "makeup", "textile", "lamb", "madagascar", "nathan", "tobago", "presenting", "cos", "troubleshooting", "uzbekistan", "indexes", "pac", "rl", "erp", "centuries", "gl", "magnitude", "ui", "richardson", "hindu", "dh", "fragrances", "vocabulary", "licking", "earthquake", "vpn", "fundraising", "fcc", "markers", "weights", "albania", "geological", "assessing", "lasting", "wicked", "eds", "introduces", "kills", "roommate", "webcams", "pushed", "webmasters", "ro", "df", "computational", "acdbentity", "participated", "junk", "handhelds", "wax", "lucy", "answering", "hans", "impressed", "slope", "reggae", "failures", "poet", "conspiracy", "surname", "theology", "nails", "evident", "whats", "rides", "rehab", "epic", "saturn", "organizer", "nut", "allergy", "sake", "twisted", "combinations", "preceding", "merit", "enzyme", "cumulative", "zshops", "planes", "edmonton", "tackle", "disks", "condo", "pokemon", "amplifier", "ambien", "arbitrary", "prominent", "retrieve", "lexington", "vernon", "sans", "worldcat", "titanium", "irs", "fairy", "builds", "contacted", "shaft", "lean", "bye", "cdt", "recorders", "occasional", "leslie", "casio", "deutsche", "ana", "postings", "innovations", "kitty", "postcards", "dude", "drain", "monte", "fires", "algeria", "blessed", "luis", "reviewing", "cardiff", "cornwall", "favors", "potato", "panic", "explicitly", "sticks", "leone", "transsexual", "ez", "citizenship", "excuse", "reforms", "basement", "onion", "strand", "pf", "sandwich", "uw", "lawsuit", "alto", "informative", "girlfriend", "bloomberg", "cheque", "hierarchy", "influenced", "banners", "reject", "eau", "abandoned", "bd", "circles", "italic", "beats", "merry", "mil", "scuba", "gore", "complement", "cult", "dash", "passive", "mauritius", "valued", "cage", "checklist", "bangbus", "requesting", "courage", "verde", "lauderdale", "scenarios", "gazette", "hitachi", "divx", "extraction", "batman", "elevation", "hearings", "coleman", "hugh", "lap", "utilization", "beverages", "calibration", "jake", "eval", "efficiently", "anaheim", "ping", "textbook", "dried", "entertaining", "prerequisite", "luther", "frontier", "settle", "stopping", "refugees", "knights", "hypothesis", "palmer", "medicines", "flux", "derby", "sao", "peaceful", "altered", "pontiac", "regression", "doctrine", "scenic", "trainers", "muze", "enhancements", "renewable", "intersection", "passwords", "sewing", "consistency", "collectors", "conclude", "recognised", "munich", "oman", "celebs", "gmc", "propose", "hh", "azerbaijan", "lighter", "rage", "adsl", "uh", "prix", "astrology", "advisors", "pavilion", "tactics", "trusts", "occurring", "supplemental", "travelling", "talented", "annie", "pillow", "induction", "derek", "precisely", "shorter", "harley", "spreading", "provinces", "relying", "finals", "paraguay", "steal", "parcel", "refined", "fd", "bo", "fifteen", "widespread", "incidence", "fears", "predict", "boutique", "acrylic", "rolled", "tuner", "avon", "incidents", "peterson", "rays", "asn", "shannon", "toddler", "enhancing", "flavor", "alike", "walt", "homeless", "horrible", "hungry", "metallic", "acne", "blocked", "interference", "warriors", "palestine", "listprice", "libs", "undo", "cadillac", "atmospheric", "malawi", "wm", "pk", "sagem", "knowledgestorm", "dana", "halo", "ppm", "curtis", "parental", "referenced", "strikes", "lesser", "publicity", "marathon", "ant", "proposition", "gays", "pressing", "gasoline", "apt", "dressed", "scout", "belfast", "exec", "dealt", "niagara", "inf", "eos", "warcraft", "charms", "catalyst", "trader", "bucks", "allowance", "vcr", "denial", "uri", "designation", "thrown", "prepaid", "raises", "gem", "duplicate", "electro", "criterion", "badge", "wrist", "civilization", "analyzed", "vietnamese", "heath", "tremendous", "ballot", "lexus", "varying", "remedies", "validity", "trustee", "maui", "handjobs", "weighted", "angola", "squirt", "performs", "plastics", "realm", "corrected", "jenny", "helmet", "salaries", "postcard", "elephant", "yemen", "encountered", "tsunami", "scholar", "nickel", "internationally", "surrounded", "psi", "buses", "expedia", "geology", "pct", "wb", "creatures", "coating", "commented", "wallet", "cleared", "smilies", "vids", "accomplish", "boating", "drainage", "shakira", "corners", "broader", "vegetarian", "rouge", "yeast", "yale", "newfoundland", "sn", "qld", "pas", "clearing", "investigated", "dk", "ambassador", "coated", "intend", "stephanie", "contacting", "vegetation", "doom", "findarticles", "louise", "kenny", "specially", "owen", "routines", "hitting", "yukon", "beings", "bite", "issn", "aquatic", "reliance", "habits", "striking", "myth", "infectious", "podcasts", "singh", "gig", "gilbert", "sas", "ferrari", "continuity", "brook", "fu", "outputs", "phenomenon", "ensemble", "insulin", "assured", "biblical", "weed", "conscious", "accent", "mysimon", "eleven", "wives", "ambient", "utilize", "mileage", "oecd", "prostate", "adaptor", "auburn", "unlock", "hyundai", "pledge", "vampire", "angela", "relates", "nitrogen", "xerox", "dice", "merger", "softball", "referrals", "quad", "dock", "differently", "firewire", "mods", "nextel", "framing", "organised", "musician", "blocking", "rwanda", "sorts", "integrating", "vsnet", "limiting", "dispatch", "revisions", "papua", "restored", "hint", "armor", "riders", "chargers", "remark", "dozens", "varies", "msie", "reasoning", "wn", "liz", "rendered", "picking", "charitable", "guards", "annotated", "ccd", "sv", "convinced", "openings", "buys", "burlington", "replacing", "researcher", "watershed", "councils", "occupations", "acknowledged", "nudity", "kruger", "pockets", "granny", "pork", "zu", "equilibrium", "viral", "inquire", "pipes", "characterized", "laden", "aruba", "cottages", "realtor", "merge", "privilege", "edgar", "develops", "qualifying", "chassis", "dubai", "estimation", "barn", "pushing", "llp", "fleece", "pediatric", "boc", "fare", "dg", "asus", "pierce", "allan", "dressing", "techrepublic", "sperm", "vg", "bald", "filme", "craps", "fuji", "frost", "leon", "institutes", "mold", "dame", "fo", "sally", "yacht", "tracy", "prefers", "drilling", "brochures", "herb", "tmp", "alot", "ate", "breach", "whale", "traveller", "appropriations", "suspected", "tomatoes", "benchmark", "beginners", "instructors", "highlighted", "bedford", "stationery", "idle", "mustang", "unauthorized", "clusters", "antibody", "competent", "momentum", "fin", "wiring", "io", "pastor", "mud", "calvin", "uni", "shark", "contributor", "demonstrates", "phases", "grateful", "emerald", "gradually", "laughing", "grows", "cliff", "desirable", "tract", "ul", "ballet", "ol", "journalist", "abraham", "js", "bumper", "afterwards", "webpage", "religions", "garlic", "hostels", "shine", "senegal", "explosion", "pn", "banned", "wendy", "briefs", "signatures", "diffs", "cove", "mumbai", "ozone", "disciplines", "casa", "mu", "daughters", "conversations", "radios", "tariff", "nvidia", "opponent", "pasta", "simplified", "muscles", "serum", "wrapped", "swift", "motherboard", "runtime", "inbox", "focal", "bibliographic", "vagina", "eden", "distant", "incl", "champagne", "ala", "decimal", "hq", "deviation", "superintendent", "propecia", "dip", "nbc", "samba", "hostel", "housewives", "employ", "mongolia", "penguin", "magical", "influences", "inspections", "irrigation", "miracle", "manually", "reprint", "reid", "wt", "hydraulic", "centered", "robertson", "flex", "yearly", "penetration", "wound", "belle", "rosa", "conviction", "hash", "omissions", "writings", "hamburg", "lazy", "mv", "mpg", "retrieval", "qualities", "cindy", "lolita", "fathers", "carb", "charging", "cas", "marvel", "lined", "cio", "dow", "prototype", "importantly", "rb", "petite", "apparatus", "upc", "terrain", "dui", "pens", "explaining", "yen", "strips", "gossip", "rangers", "nomination", "empirical", "mh", "rotary", "worm", "dependence", "discrete", "beginner", "boxed", "lid", "sexuality", "polyester", "cubic", "deaf", "commitments", "suggesting", "sapphire", "kinase", "skirts", "mats", "remainder", "crawford", "labeled", "privileges", "televisions", "specializing", "marking", "commodities", "pvc", "serbia", "sheriff", "griffin", "declined", "guyana", "spies", "blah", "mime", "neighbor", "motorcycles", "elect", "highways", "thinkpad", "concentrate", "intimate", "reproductive", "preston", "deadly", "cunt", "feof", "bunny", "chevy", "molecules", "rounds", "longest", "refrigerator", "tions", "intervals", "sentences", "dentists", "usda", "exclusion", "workstation", "holocaust", "keen", "flyer", "peas", "dosage", "receivers", "urls", "customise", "disposition", "variance", "navigator", "investigators", "cameroon", "baking", "marijuana", "adaptive", "computed", "needle", "baths", "enb", "gg", "cathedral", "brakes", "og", "nirvana", "ko", "fairfield", "owns", "til", "invision", "sticky", "destiny", "generous", "madness", "emacs", "climb", "blowing", "fascinating", "landscapes", "heated", "lafayette", "jackie", "wto", "computation", "hay", "cardiovascular", "ww", "sparc", "cardiac", "salvation", "dover", "adrian", "predictions", "accompanying", "vatican", "brutal", "learners", "gd", "selective", "arbitration", "configuring", "token", "editorials", "zinc", "sacrifice", "seekers", "guru", "isa", "removable", "convergence", "yields", "gibraltar", "levy", "suited", "numeric", "anthropology", "skating", "kinda", "aberdeen", "emperor", "grad", "malpractice", "dylan", "bras", "belts", "blacks", "educated", "rebates", "reporters", "burke", "proudly", "pix", "necessity", "rendering", "mic", "inserted", "pulling", "basename", "kyle", "obesity", "curves", "suburban", "touring", "clara", "vertex", "bw", "hepatitis", "nationally", "tomato", "andorra", "waterproof", "expired", "mj", "travels", "flush", "waiver", "pale", "specialties", "hayes", "humanitarian", "invitations", "functioning", "delight", "survivor", "garcia", "cingular", "economies", "alexandria", "bacterial", "moses", "counted", "undertake", "declare", "continuously", "johns", "valves", "gaps", "impaired", "achievements", "donors", "tear", "jewel", "teddy", "lf", "convertible", "ata", "teaches", "ventures", "nil", "bufing", "stranger", "tragedy", "julian", "nest", "pam", "dryer", "painful", "velvet", "tribunal", "ruled", "nato", "pensions", "prayers", "funky", "secretariat", "nowhere", "cop", "paragraphs", "gale", "joins", "adolescent", "nominations", "wesley", "dim", "lately", "cancelled", "scary", "mattress", "mpegs", "brunei", "likewise", "banana", "introductory", "slovak", "cakes", "stan", "reservoir", "occurrence", "idol", "bloody", "mixer", "remind", "wc", "worcester", "sbjct", "demographic", "charming", "mai", "tooth", "disciplinary", "annoying", "respected", "stays", "disclose", "affair", "drove", "washer", "upset", "restrict", "springer", "beside", "mines", "portraits", "rebound", "logan", "mentor", "interpreted", "evaluations", "fought", "baghdad", "elimination", "metres", "hypothetical", "immigrants", "complimentary", "helicopter", "pencil", "freeze", "hk", "performer", "abu", "titled", "commissions", "sphere", "powerseller", "moss", "ratios", "concord", "graduated", "endorsed", "ty", "surprising", "walnut", "lance", "ladder", "italia", "unnecessary", "dramatically", "liberia", "sherman", "cork", "maximize", "cj", "hansen", "senators", "workout", "mali", "yugoslavia", "bleeding", "characterization", "colon", "likelihood", "lanes", "purse", "fundamentals", "contamination", "mtv", "endangered", "compromise", "masturbation", "optimize", "stating", "dome", "caroline", "leu", "expiration", "namespace", "align", "peripheral", "bless", "engaging", "negotiation", "crest", "opponents", "triumph", "nominated", "confidentiality", "electoral", "changelog", "welding", "orgasm", "deferred", "alternatively", "heel", "alloy", "condos", "plots", "polished", "yang", "gently", "greensboro", "tulsa", "locking", "casey", "controversial", "draws", "fridge", "blanket", "bloom", "qc", "simpsons", "lou", "elliott", "recovered", "fraser", "justify", "upgrading", "blades", "pgp", "loops", "surge", "frontpage", "trauma", "aw", "tahoe", "advert", "possess", "demanding", "defensive", "sip", "flashers", "subaru", "forbidden", "tf", "vanilla", "programmers", "pj", "monitored", "installations", "deutschland", "picnic", "souls", "arrivals", "spank", "cw", "practitioner", "motivated", "wr", "dumb", "smithsonian", "hollow", "vault", "securely", "examining", "fioricet", "groove", "revelation", "rg", "pursuit", "delegation", "wires", "bl", "dictionaries", "mails", "backing", "greenhouse", "sleeps", "vc", "blake", "transparency", "dee", "travis", "wx", "endless", "figured", "orbit", "currencies", "niger", "bacon", "survivors", "positioning", "heater", "colony", "cannon", "circus", "promoted", "forbes", "mae", "moldova", "mel", "descending", "paxil", "spine", "trout", "enclosed", "feat", "temporarily", "ntsc", "cooked", "thriller", "transmit", "apnic", "fatty", "gerald", "pressed", "frequencies", "scanned", "reflections", "hunger", "mariah", "sic", "municipality", "usps", "joyce", "detective", "surgeon", "cement", "experiencing", "fireplace", "endorsement", "bg", "planners", "disputes", "textiles", "missile", "intranet", "closes", "seq", "psychiatry", "persistent", "deborah", "conf", "marco", "assists", "summaries", "glow", "gabriel", "auditor", "wma", "aquarium", "violin", "prophet", "cir", "bracket", "looksmart", "isaac", "oxide", "oaks", "magnificent", "erik", "colleague", "naples", "promptly", "modems", "adaptation", "hu", "harmful", "paintball", "prozac", "sexually", "enclosure", "acm", "dividend", "newark", "kw", "paso", "glucose", "phantom", "norm", "playback", "supervisors", "westminster", "turtle", "ips", "distances", "absorption", "treasures", "dsc", "warned", "neural", "ware", "fossil", "mia", "hometown", "badly", "transcripts", "apollo", "wan", "disappointed", "persian", "continually", "communist", "collectible", "handmade", "greene", "entrepreneurs", "robots", "grenada", "creations", "jade", "scoop", "acquisitions", "foul", "keno", "gtk", "earning", "mailman", "sanyo", "nested", "biodiversity", "excitement", "somalia", "movers", "verbal", "blink", "presently", "seas", "carlo", "workflow", "mysterious", "novelty", "bryant", "tiles", "voyuer", "librarian", "subsidiaries", "switched", "stockholm", "tamil", "garmin", "ru", "pose", "fuzzy", "indonesian", "grams", "therapist", "richards", "mrna", "budgets", "toolkit", "promising", "relaxation", "goat", "render", "carmen", "ira", "sen", "thereafter", "hardwood", "erotica", "temporal", "sail", "forge", "commissioners", "dense", "dts", "brave", "forwarding", "qt", "awful", "nightmare", "airplane", "reductions", "southampton", "istanbul", "impose", "organisms", "sega", "telescope", "viewers", "asbestos", "portsmouth", "cdna", "meyer", "enters", "pod", "savage", "advancement", "wu", "harassment", "willow", "resumes", "bolt", "gage", "throwing", "existed", "whore", "generators", "lu", "wagon", "barbie", "dat", "favour", "soa", "knock", "urge", "smtp", "generates", "potatoes", "thorough", "replication", "inexpensive", "kurt", "receptors", "peers", "roland", "optimum", "neon", "interventions", "quilt", "huntington", "creature", "ours", "mounts", "syracuse", "internship", "lone", "refresh", "aluminium", "snowboard", "beastality", "webcast", "michel", "evanescence", "subtle", "coordinated", "notre", "shipments", "maldives", "stripes", "firmware", "antarctica", "cope", "shepherd", "lm", "canberra", "cradle", "chancellor", "mambo", "lime", "kirk", "flour", "controversy", "legendary", "bool", "sympathy", "choir", "avoiding", "beautifully", "blond", "expects", "cho", "jumping", "fabrics", "antibodies", "polymer", "hygiene", "wit", "poultry", "virtue", "burst", "examinations", "surgeons", "bouquet", "immunology", "promotes", "mandate", "wiley", "departmental", "bbs", "spas", "ind", "corpus", "johnston", "terminology", "gentleman", "fibre", "reproduce", "convicted", "shades", "jets", "indices", "roommates", "adware", "qui", "intl", "threatening", "spokesman", "zoloft", "activists", "frankfurt", "prisoner", "daisy", "halifax", "encourages", "ultram", "cursor", "assembled", "earliest", "donated", "stuffed", "restructuring", "insects", "terminals", "crude", "morrison", "maiden", "simulations", "cz", "sufficiently", "examines", "viking", "myrtle", "bored", "cleanup", "yarn", "knit", "conditional", "mug", "crossword", "bother", "budapest", "conceptual", "knitting", "attacked", "hl", "bhutan", "liechtenstein", "mating", "compute", "redhead", "arrives", "translator", "automobiles", "tractor", "allah", "continent", "ob", "unwrap", "fares", "longitude", "resist", "challenged", "telecharger", "hoped", "pike", "safer", "insertion", "instrumentation", "ids", "hugo", "wagner", "constraint", "groundwater", "touched", "strengthening", "cologne", "gzip", "wishing", "ranger", "smallest", "insulation", "newman", "marsh", "ricky", "ctrl", "scared", "theta", "infringement", "bent", "laos", "subjective", "monsters", "asylum", "lightbox", "robbie", "stake", "cocktail", "outlets", "swaziland", "varieties", "arbor", "mediawiki", "configurations", "poison", "ethnicity", "dominated", "costly", "derivatives", "prevents", "stitch", "lesotho", "rifle", "severity", "rfid", "notable", "warfare", "retailing", "judiciary", "embroidery", "mama", "inland", "oscommerce", "nonfiction", "homeowners", "racism", "greenland", "interpret", "accord", "vaio", "modest", "gamers", "slr", "licensee", "countryside", "sorting", "liaison", "bisexual", "rel", "unused", "bulbs", "ign", "consuming", "installer", "tourists", "sandals", "powershot", "bestselling", "insure", "packaged", "behaviors", "clarify", "seconded", "activate", "waist", "attributed", "tg", "seychelles", "pv", "fatigue", "owl", "patriot", "sewer", "crystals", "kathleen", "bosch", "forthcoming", "sandisk", "num", "treats", "marino", "detention", "carson", "vitro", "exceeds", "complementary", "cosponsors", "gallon", "coil", "battles", "hyatt", "traders", "carlton", "bitter", "memorandum", "burned", "cardinal", "dragons", "converting", "romeo", "din", "burundi", "incredibly", "delegates", "turks", "roma", "demos", "balancing", "btw", "att", "vet", "sided", "claiming", "psychiatric", "tittens", "teenagers", "courtyard", "presidents", "offenders", "depart", "grading", "cuban", "tenants", "expressly", "distinctive", "lily", "brackets", "unofficial", "oversight", "valentines", "vonage", "privately", "wetlands", "minded", "resin", "allies", "twilight", "preserved", "crossed", "kensington", "monterey", "linen", "rita", "quicktime", "ascending", "seals", "nominal", "alicia", "decay", "weaknesses", "underwater", "quartz", "registers", "eighth", "pbs", "usher", "herbert", "authorised", "improves", "advocates", "phenomena", "buffet", "deciding", "skate", "vanuatu", "joey", "erotik", "hackers", "tilt", "supportive", "vw", "granite", "repeatedly", "lynch", "masses", "transformed", "athlete", "targeting", "franc", "bead", "enforce", "preschool", "similarity", "landlord", "leak", "timor", "dw", "assorted", "hm", "implements", "jl", "adviser", "hg", "flats", "compelling", "vouchers", "megapixel", "booklet", "expecting", "cancun", "heels", "voter", "reimbursement", "turnover", "urine", "cheryl", "radeon", "capri", "towel", "ginger", "italicized", "suburbs", "imagery", "chromosome", "optimized", "sears", "als", "ffl", "flies", "upgraded", "competence", "colorful", "inadequate", "crying", "matthews", "amateurs", "crane", "defendants", "deployed", "governed", "considerably", "investigating", "rotten", "popup", "mk", "garnet", "habit", "bulb", "scattered", "honour", "useless", "protects", "northwestern", "audiences", "iris", "coupe", "hal", "benin", "ppp", "bach", "manages", "erosion", "oceania", "abundance", "carpenter", "khan", "insufficient", "highlands", "peters", "fertility", "formulation", "clever", "primer", "che", "lords", "bu", "tends", "fresno", "enjoyable", "handbag", "crescent", "bypass", "freshman", "ies", "playground", "negotiate", "logout", "sixty", "exploit", "orgies", "boyfriend", "permanently", "concentrated", "distinguish", "ei", "hogtied", "projections", "wl", "spark", "illustrate", "lin", "clipart", "patience", "securing", "pathway", "detectors", "newsgroups", "shallow", "stir", "spike", "plated", "jacques", "drawer", "ingredient", "togo", "spectra", "lifting", "judith", "curtain", "disclosed", "davies", "tactical", "pilots", "mailbox", "copenhagen", "expedition", "pile", "operative", "humour", "athlon", "maturity", "caller", "iq", "distortion", "prosecution", "het", "landscaping", "tonga", "mol", "imprint", "korn", "natalie", "receipts", "assisting", "shirley", "sanctions", "directv", "goodbye", "viable", "emerged", "deviantart", "defect", "qa", "poorly", "goddess", "backs", "observers", "magnets", "formulas", "spacious", "shoulders", "nas", "argues", "wade", "soils", "chapman", "organs", "det", "loyalty", "beloved", "sometime", "ballard", "beating", "faithful", "hunks", "appellant", "libya", "offence", "xsl", "invested", "whatsoever", "numbered", "terminated", "expands", "lithium", "sedan", "pony", "ctr", "comprises", "leap", "bolton", "founding", "swan", "planting", "alphabetically", "facials", "covenant", "dropping", "calories", "airways", "archaeology", "refill", "reagan", "sailor", "fittings", "lining", "banquet", "cares", "sanctuary", "flora", "kazaa", "einstein", "pornstar", "statue", "hilary", "quotation", "equals", "hardy", "vcd", "jumper", "caravan", "diagrams", "harness", "majors", "headsets", "manipulation", "bells", "vascular", "alongside", "impressions", "yankees", "toxicity", "forwarded", "sz", "gal", "transmitter", "dorothy", "freeman", "denim", "greenville", "andre", "scat", "ems", "neighborhoods", "puppies", "relaxing", "delphi", "trophy", "emotion", "buick", "slipknot", "nets", "sights", "uniforms", "mst", "residual", "disasters", "asterisk", "versatile", "liquor", "kindergarten", "profitable", "wounded", "clayton", "bf", "bash", "derivative", "suffolk", "ngos", "necklaces", "storesshop", "tot", "occupancy", "postgraduate", "doses", "educate", "baked", "glove", "daytona", "wastewater", "prejudice", "herzegovina", "constructor", "technicians", "debbie", "probable", "issuance", "sj", "baldwin", "mbps", "incorporation", "rem", "evolutionary", "arriving", "decoration", "nationals", "trojan", "assistants", "counselor", "spinal", "ij", "eliminated", "alito", "sooner", "struggling", "enacted", "waterfront", "tenure", "plush", "weber", "diagnosed", "biotech", "unstable", "turkmenistan", "elk", "woodland", "iranian", "nelly", "fulfill", "urged", "reflecting", "unsecured", "brent", "gaining", "kyoto", "cis", "definitive", "eb", "appropriately", "shifts", "inactive", "lansing", "traveled", "barcode", "adapt", "extracted", "accession", "patterson", "xd", "regulator", "carriage", "therein", "terminate", "rex", "fuels", "txt", "postcode", "traditionally", "withdraw", "soy", "brett", "makefile", "anchorage", "ansi", "paula", "vicodin", "landmark", "greens", "neat", "naming", "stern", "shawn", "suv", "lacrosse", "bentley", "bud", "slaves", "dentist", "utilizing", "mis", "crafted", "burkina", "eritrea", "bbq", "tutor", "idiot", "comprised", "winnipeg", "charities", "mickey", "wh", "debit", "sebastian", "aliens", "domino", "dmx", "edits", "unwanted", "raven", "defeated", "strains", "dwelling", "slice", "xr", "tanning", "bn", "gambia", "aspen", "lacking", "symbolic", "noaa", "cest", "objectionable", "angles", "lemma", "kyrgyzstan", "pressures", "webb", "sensing", "mediation", "venus", "postgresql", "bump", "cowboys", "flames", "primitive", "kbps", "auf", "trac", "stocking", "esp", "dolby", "balloons", "ecosystem", "pkg", "dashboard", "malcolm", "nikki", "georgetown", "technorati", "esl", "norwich", "halls", "alzheimer", "decorations", "pause", "simplicity", "postscript", "dividends", "relaxed", "periodicals", "pearson", "demon", "welcomed", "jk", "infinity", "wk", "handler", "gabon", "notation", "chandler", "aunt", "interviewed", "crow", "semantic", "dia", "discontinued", "concurrent", "decides", "caption", "bargaining", "globalization", "atv", "vga", "atari", "complain", "pulmonary", "adhesive", "toledo", "asses", "altitude", "compass", "closet", "sch", "reebok", "couch", "evolved", "downs", "mfg", "exceeding", "jb", "rogue", "unfair", "blogthis", "electronically", "inspirational", "augusta", "wilmington", "infantry", "faso", "renowned", "corridor", "philosophical", "scripture", "celebrating", "sahara", "justification", "rebuild", "sdram", "vacant", "manuscript", "fixing", "motherboards", "gram", "blk", "hiding", "methodist", "inherent", "dye", "sits", "alphabet", "shelves", "toes", "cleaned", "honored", "optic", "hannah", "jw", "telephones", "tailored", "insect", "frances", "diaries", "chili", "grief", "leicester", "vodafone", "sweat", "dolphin", "pendants", "wonders", "romanian", "xt", "ventilation", "ucla", "masks", "celeb", "bust", "lateral", "assoc", "quake", "palo", "usability", "alley", "gardner", "backyard", "sanders", "pathways", "telegraph", "pertaining", "novell", "memorable", "refunds", "newsroom", "tina", "professors", "kia", "monument", "taxpayer", "fb", "formally", "cola", "twain", "ile", "boise", "bsd", "nevis", "saab", "dew", "lavender", "refinancing", "justified", "withdrawn", "breeze", "debates", "gems", "cert", "buffy", "doctoral", "backpack", "npr", "identities", "outgoing", "mann", "tajikistan", "yankee", "sheraton", "outs", "snacks", "deficiency", "booster", "taxable", "gum", "progression", "adv", "saddle", "malaria", "loyal", "torrent", "imc", "ufo", "linksys", "dentistry", "renal", "fedora", "odyssey", "spite", "nero", "capita", "nyse", "guideline", "imply", "inaccuracies", "tendency", "caledonia", "freezer", "wholly", "chill", "utilized", "embrace", "pcr", "bnet", "ein", "binoculars", "liner", "manila", "auxiliary", "initiate", "ua", "elevated", "purely", "demographics", "fry", "lifts", "vivid", "enroll", "allegations", "stationary", "corresponds", "daemon", "foil", "whitney", "celebrated", "buddies", "alarms", "hunters", "roi", "allison", "kc", "crashes", "stairs", "outlines", "steroids", "kt", "pogo", "acted", "konica", "hotline", "amps", "byron", "critique", "accountants", "coefficient", "honestly", "transvestite", "upstream", "skull", "continuation", "carnegie", "digg", "servant", "falcon", "jointly", "canadians", "avoided", "comprising", "tick", "ladyboy", "terrier", "listened", "explanations", "renewed", "hussein", "incorporating", "variant", "riley", "biochemistry", "duplication", "equatorial", "critic", "sediment", "translators", "squares", "scottsdale", "ninja", "tj", "avalon", "deg", "bot", "lea", "vans", "od", "voucher", "tw", "honeymoon", "percussion", "glue", "wheelchair", "gw", "cone", "margins", "sands", "survived", "spinning", "epidemiology", "adequately", "pentagon", "spectral", "diabetic", "stressed", "libdevel", "prevalence", "dominica", "contaminated", "fragment", "dvi", "finishes", "lecturer", "biomedical", "embroidered", "bucket", "steak", "gameboy", "commits", "cobra", "subset", "gucci", "threw", "sutton", "djibouti", "https", "websphere", "authorize", "cheney", "zombie", "decorated", "credited", "cherokee", "recycled", "apo", "ao", "followup", "recruit", "simmons", "nih", "gals", "hoc", "hdd", "bidders", "wherein", "simulator", "appearances", "performers", "dessert", "dissertation", "exporters", "walsh", "ninth", "mutant", "nos", "marry", "blankets", "enthusiasm", "confusing", "celebrations", "approaching", "bounce", "ivan", "spiral", "ssh", "governors", "weakness", "authoring", "specializes", "wills", "katherine", "atoms", "jacobs", "mauritania", "tissues", "reminded", "irvine", "drake", "olds", "ramp", "jakarta", "cynthia", "roosevelt", "practicing", "schmidt", "nicely", "surprisingly", "expressing", "della", "laurel", "carolyn", "rails", "tl", "pgsql", "fried", "cairo", "ambulance", "practically", "traded", "signaling", "vivo", "malls", "domination", "shrimp", "jensen", "chords", "impairment", "scooter", "molecule", "dedication", "wap", "desires", "woody", "dismissed", "mcgraw", "lr", "cheerleader", "cried", "psychic", "cracks", "edu", "lotion", "analyzing", "substrate", "sincerely", "mmc", "beaten", "piercing", "ashanti", "antilles", "homemade", "ukrainian", "establishments", "marginal", "visions", "efficacy", "freshwater", "topical", "prestige", "cocaine", "accelerated", "pinnacle", "tucker", "rms", "recognizes", "plugs", "isdn", "responsive", "coded", "supra", "omitted", "molly", "proximity", "ku", "alcatel", "belonging", "unbiased", "pear", "suriname", "chiefs", "franz", "collision", "supplementary", "parkway", "femdom", "palau", "clue", "scandal", "duff", "lodges", "dangers", "lys", "ck", "bonuses", "scam", "travellers", "gia", "scream", "biking", "discrepancies", "pirate", "microsystems", "timeout", "senses", "aerosmith", "repeats", "resellers", "willie", "portfolios", "rival", "ops", "slower", "simulated", "culinary", "fairfax", "beck", "semantics", "huh", "scarface", "accountant", "beige", "auditing", "rolex", "propaganda", "amplifiers", "offender", "waterloo", "warwick", "coli", "executable", "pentax", "restart", "rounded", "boarding", "vanity", "mitigation", "tome", "prof", "overstock", "homer", "eps", "daylight", "macdonald", "hmm", "gases", "dependency", "dioxide", "fireworks", "genus", "approached", "catching", "cutter", "connects", "ont", "explores", "liberals", "aperture", "roofing", "dixon", "elastic", "melody", "sins", "cousin", "hath", "torque", "recalls", "consultations", "memberships", "debts", "renting", "icann", "ticketmaster", "cdc", "meridia", "phillip", "burial", "balcony", "prescriptions", "hsn", "prop", "avril", "willis", "myths", "camden", "coupling", "knees", "oncology", "neglect", "emerge", "nf", "winchester", "clutch", "shy", "poets", "woven", "bloglines", "auditorium", "pedro", "maid", "sid", "carrie", "audioslave", "towels", "wikimedia", "canterbury", "lipitor", "remodeling", "trent", "redhat", "barber", "intuitive", "rigid", "enom", "sta", "degradation", "ret", "haha", "orthodox", "erin", "ferguson", "coordinating", "holistic", "salsa", "fragments", "encarta", "mariana", "qualitative", "claude", "minorities", "childcare", "dvr", "blown", "diffusion", "baton", "cdn", "polynesia", "barton", "umbrella", "soundtracks", "napster", "rods", "wong", "stimulation", "abbey", "pigs", "debugging", "olivia", "rechargeable", "engineered", "jerseys", "refugee", "pw", "straps", "maya", "discourse", "lancashire", "superstore", "headache", "stained", "marital", "socialist", "hex", "wg", "bruno", "attracted", "undertaking", "slavery", "notwithstanding", "blogroll", "evite", "feasible", "romans", "micronesia", "credibility", "shores", "fest", "thames", "flowing", "dreamweaver", "diets", "montenegro", "deed", "sauna", "whirlpool", "perfumes", "sustain", "mechanic", "bauer", "eliminating", "rejection", "multiplayer", "crt", "caicos", "bowls", "qaeda", "dissemination", "shareholder", "cardinals", "kitts", "cosmic", "dawson", "tivo", "defective", "deletion", "lengths", "beacon", "hoover", "ptr", "macau", "politically", "elective", "forensic", "botanical", "quartet", "mudvayne", "ceramics", "suspense", "drafting", "cruel", "observing", "freestyle", "advertised", "commencement", "southwestern", "conform", "helmets", "organizers", "firing", "smartphone", "eager", "cmd", "denise", "hypertension", "searchable", "touching", "aguilera", "vacancy", "servicing", "papa", "settlements", "strawberry", "chang", "gloria", "counselling", "elevator", "pupil", "feast", "ecards", "maggie", "redemption", "profound", "canton", "nina", "acura", "registering", "seth", "warn", "conservatives", "clit", "bonnie", "laying", "cops", "provisional", "compiling", "fedex", "strive", "snowboarding", "releasing", "laserjet", "martinique", "shells", "painter", "cooker", "ankle", "peso", "leagues", "monkeys", "historically", "lego", "transitions", "prevented", "digits", "err", "banker", "sup", "easiest", "microbiology", "borrow", "internships", "bamboo", "lv", "denotes", "communicating", "sgh", "ki", "vectors", "decks", "craigslist", "vibration", "stepped", "vent", "blunt", "protector", "hamas", "aux", "react", "understands", "rises", "shane", "issuing", "heaters", "accents", "insane", "buddha", "voyage", "een", "rdf", "colonel", "transitional", "mozart", "acceleration", "sketch", "hoffman", "bj", "balances", "firearms", "nightly", "visualization", "pitt", "deduction", "dancer", "coats", "pol", "capsules", "hyde", "firmly", "doo", "dots", "pursuing", "newswire", "aston", "hf", "spermshack", "mugs", "brokerage", "washed", "overtime", "staind", "resonance", "mosaic", "rhodes", "fiesta", "wd", "sourcing", "vase", "filings", "forcing", "fairs", "flute", "durability", "boeing", "sizing", "exceeded", "meadows", "hindi", "presley", "harsh", "outfit", "godsmack", "labeling", "substitution", "whois", "burma", "cease", "deserves", "aboard", "paradigm", "msc", "irving", "perfection", "joints", "overwhelming", "linguistics", "snmp", "standardized", "liu", "poles", "gta", "bounds", "lyon", "nutrients", "kosovo", "santiago", "vera", "advising", "altogether", "devils", "dignity", "europa", "barbuda", "wondered", "cheshire", "boyd", "sliding", "accumulation", "napa", "descriptive", "abt", "inst", "feasibility", "nickelback", "lj", "negotiating", "homo", "pier", "sioux", "nazi", "cote", "premiums", "jenna", "arrays", "lutheran", "syllabus", "rgb", "fellows", "valencia", "superman", "rodriguez", "perkins", "animations", "ideally", "activism", "splash", "fargo", "chairperson", "equip", "saga", "reged", "leverage", "probation", "sgt", "ast", "gran", "commissioned", "hedge", "ke", "anguilla", "fender", "violet", "dancers", "mutation", "radisson", "envelopes", "apc", "alle", "compulsory", "hitler", "favorable", "rue", "handset", "preparations", "maxwell", "illustrates", "inheritance", "curry", "vulnerabilities", "pga", "oblique", "pearls", "worms", "activist", "palestinians", "satisfying", "ldap", "succeeded", "prerequisites", "maintainer", "apples", "elf", "dewey", "surviving", "pouch", "advent", "proposes", "hooks", "ces", "exploitation", "singers", "mayo", "tasmania", "mansion", "benq", "cha", "surrender", "lx", "schneider", "accumulated", "arsenal", "dub", "screws", "pyramid", "enjoys", "bv", "hacking", "stripe", "knoxville", "averages", "peaks", "tai", "como", "lisp", "limousine", "churchill", "mentoring", "pak", "affirmative", "keynote", "mos", "didnt", "classrooms", "planted", "petitioner", "residency", "spoon", "bombs", "niche", "deadlines", "fortunately", "tk", "cigar", "vis", "calculating", "erie", "berkshire", "bookshop", "proportional", "credentials", "deprecated", "nonetheless", "municipalities", "chin", "locker", "jenkins", "squash", "expectation", "severely", "spotted", "curse", "hifi", "gf", "ajax", "coconut", "interrupt", "conductor", "wont", "liberation", "forex", "diagnostics", "grandfather", "removes", "ew", "luxurious", "titan", "dreamcast", "tumors", "booked", "anita", "indirectly", "nile", "vm", "blessing", "lumber", "kyocera", "pillows", "portals", "illustrator", "asleep", "potassium", "prompted", "shout", "nudes", "rationale", "hubs", "pasadena", "presidency", "abnormal", "bissau", "delicate", "convince", "whoever", "subway", "hpa", "straw", "lifted", "mankind", "uncertain", "fgets", "citrus", "paramount", "cameltoe", "upright", "breakfasts", "inspectors", "emergencies", "reuse", "ernest", "sightseeing", "shocked", "therapies", "alcoholic", "bakery", "lieutenant", "orchid", "histories", "loses", "widget", "renault", "atkins", "variability", "comoros", "suede", "observatory", "soda", "waited", "preventive", "peach", "calculus", "stefan", "selector", "gop", "breathe", "diaper", "dunn", "hotwire", "ngo", "smiling", "ounces", "pvt", "economically", "uncut", "intact", "noting", "shifting", "samurai", "atp", "moines", "subtotal", "coefficients", "duplex", "ivy", "mvp", "delegate", "lightly", "negotiated", "jh", "analyzer", "herman", "congestion", "runners", "stove", "charset", "clin", "accidental", "talents", "nixon", "refuge", "brady", "guadeloupe", "nutrient", "walton", "zhang", "underway", "carved", "ark", "freak", "obstacles", "govt", "cbc", "preferably", "bluff", "excerpts", "jasper", "formatted", "sed", "newborn", "sadly", "laughed", "gorillaz", "avail", "emerson", "regulate", "orchard", "inhibitors", "uu", "mythology", "prestigious", "deploy", "trousers", "gameplay", "hatch", "replaces", "tomb", "regina", "stein", "shortage", "privileged", "spill", "goodness", "drift", "extracts", "professions", "explored", "autism", "mysteries", "fuller", "taxpayers", "martinez", "bombing", "decreases", "wwe", "metrics", "winxp", "crisp", "inability", "cor", "goo", "coronary", "bldg", "mediated", "prom", "scans", "keeper", "reinforced", "johannesburg", "spells", "specifying", "vaginal", "buddhist", "isps", "inevitable", "etiquette", "rookie", "environ", "nic", "theatrical", "coloured", "births", "kr", "cubs", "interdisciplinary", "wheeler", "ritual", "miguel", "kerala", "pulp", "onset", "interpreter", "enzymes", "specimens", "initiation", "analytics", "assay", "jacuzzi", "reconciliation", "pots", "lesbianas", "recognizing", "parser", "leigh", "razr", "slam", "jt", "respects", "tents", "plaque", "accounted", "deposited", "lowe", "beavers", "crib", "styling", "snack", "defending", "pulls", "autonomous", "weezer", "granting", "motoring", "appropriation", "randomly", "condensed", "philippine", "theological", "quietly", "semiconductors", "scenery", "coca", "acs", "peugeot", "bollywood", "mentally", "horoscopes", "drying", "assemblies", "noun", "xmas", "silicone", "collateral", "cpa", "learner", "welcomes", "dn", "swallow", "tara", "transplant", "scoreboard", "proliferation", "usenet", "squid", "marines", "hw", "lighthouse", "proves", "customised", "trilogy", "crab", "jen", "brightness", "maurice", "brooke", "consumed", "maxim", "hike", "bore", "imdb", "depreciation", "clic", "technically", "ars", "pharmacist", "marley", "enjoyment", "typepad", "cows", "xs", "deliveries", "recruiters", "austrian", "correspond", "slate", "suzanne", "confined", "screaming", "inhabitants", "straightforward", "delighted", "cygwin", "morton", "peel", "gprs", "cue", "jupiter", "simultaneous", "monopoly", "png", "pornography", "debris", "han", "intentions", "robotics", "pagan", "chopped", "widow", "contexts", "sac", "peg", "randall", "benson", "sleeves", "troubled", "footnote", "vibrant", "evolving", "sweater", "approximation", "skies", "barrett", "init", "burners", "alison", "fitzgerald", "kicks", "disappeared", "canoe", "svn", "sovereign", "reminds", "organism", "corrupt", "violated", "correspondent", "drought", "bake", "hurricanes", "oslo", "symptom", "laughter", "foreclosures", "propagation", "audits", "ignorance", "pesticides", "explosive", "inventor", "scaling", "juicy", "fave", "residues", "ashlee", "moody", "viet", "fashioned", "grains", "vicinity", "thyroid", "purification", "heal", "orbitz", "southeastern", "wizards", "horoscope", "invasive", "prosperity", "rainfall", "helsinki", "hardback", "mum", "launching", "vuitton", "nextag", "pedal", "inconsistent", "plantation", "storing", "asa", "tote", "jumped", "seemingly", "tuned", "narnia", "passionate", "alfa", "staples", "twp", "mayer", "backward", "sour", "geoff", "rename", "atx", "markup", "combustion", "breakthrough", "scrap", "ietf", "administer", "bilateral", "bella", "blondes", "beneficiaries", "disposable", "williamson", "sock", "gentlemen", "copier", "uncategorized", "terra", "literal", "questioned", "guiding", "charcoal", "xm", "vapor", "beware", "aloud", "glorious", "geforce", "overlap", "handsome", "defaults", "foreclosure", "clarification", "grounded", "bail", "goose", "espresso", "fn", "judgement", "cruiser", "hendrix", "cumberland", "gifted", "esteem", "cascade", "endorse", "strokes", "shelby", "hen", "homeowner", "ancestry", "mib", "dolphins", "adopting", "landed", "nucleus", "tees", "detached", "scouts", "warsaw", "ib", "mist", "glu", "winnt", "verb", "tec", "chic", "hydro", "nonlinear", "spokane", "objection", "phosphate", "playa", "gh", "noisy", "csi", "abide", "radioactive", "sentinel", "birthdays", "desserts", "doi", "socio", "pcmcia", "preserving", "vest", "neal", "economist", "grooming", "meridian", "marriages", "regret", "validate", "stakes", "rotating", "nederlands", "brigade", "movable", "doubles", "bst", "bliss", "filmography", "humiliation", "tens", "litter", "reflective", "outerwear", "abbreviations", "executing", "greenwich", "flooding", "parse", "rugged", "jelly", "dsp", "implementations", "grandmother", "renovation", "puma", "appoint", "attendees", "panthers", "perceptions", "greenwood", "ignition", "humble", "toc", "downstream", "petrol", "midway", "mania", "edwin", "webcasts", "ax", "accelerator", "masterbating", "clare", "flyers", "recognise", "tacoma", "hostile", "aphrodite", "radiology", "establishes", "whites", "rant", "trapped", "bolts", "diplomatic", "locals", "fringe", "linguistic", "internally", "planetary", "mms", "tungsten", "typed", "desc", "datasheet", "laurent", "shutdown", "ego", "manuel", "xenical", "computerworld", "gaza", "influenza", "gill", "tattoos", "rude", "sang", "steele", "citing", "viewpoint", "peptide", "nay", "sweatshirt", "hassle", "regents", "servants", "meanings", "conception", "unemployed", "heavenly", "gn", "exeter", "docket", "amusement", "dll", "elsevier", "nordic", "middlesex", "curl", "privat", "albanian", "overflow", "geometric", "hastings", "subsidies", "taxonomy", "thirds", "deli", "willingness", "intern", "implicit", "nsf", "patriotic", "simplify", "darling", "schwartz", "satan", "ornaments", "oppose", "sata", "terrific", "xxxx", "megan", "allergies", "definite", "bangalore", "congregation", "regiment", "cheer", "everett", "reviewers", "clutter", "misleading", "marty", "predator", "vine", "vale", "whereby", "deceased", "sparks", "xlibs", "belgian", "adolescents", "djs", "simpler", "captures", "coventry", "capitalism", "hancock", "falkland", "clamp", "cur", "pricegrabber", "mammals", "grape", "cloning", "args", "madden", "russ", "peppers", "deeds", "lively", "inequality", "smugmug", "educator", "premature", "visually", "tripod", "immigrant", "alright", "laguna", "limo", "demonstrations", "obsolete", "aligned", "rust", "lon", "pesticide", "interfere", "traps", "shuffle", "wardrobe", "vin", "transformers", "successes", "racer", "fabrication", "guilt", "sweep", "nash", "exploited", "avid", "outpatient", "bladder", "lam", "inflammatory", "iss", "immunity", "encrypted", "bets", "wholesalers", "doyle", "ducks", "coldfusion", "dcr", "shooter", "switchboard", "paints", "vince", "neighbourhood", "cheating", "carr", "fade", "fluorescent", "tastes", "cookware", "storms", "lavigne", "param", "smiled", "jurisdictions", "scrutiny", "regeneration", "lunar", "differentiation", "shields", "environmentally", "nonsense", "invented", "gradient", "ncbi", "inserts", "kvm", "elaine", "programmable", "posed", "subjected", "tasting", "bibtex", "chemotherapy", "gwen", "mob", "expose", "borrowing", "arises", "imf", "vr", "precautions", "branded", "dysfunction", "manning", "lisbon", "forks", "monk", "boxer", "shining", "livejournal", "diazepam", "weigh", "rodeo", "clerical", "voyager", "hobart", "sampler", "moose", "jovi", "timetable", "dorset", "corrosion", "positioned", "checker", "buenos", "workstations", "conscience", "crush", "cathy", "mystic", "solicitation", "darren", "cmp", "rectangular", "fischer", "pooh", "enthusiast", "udp", "positively", "sts", "shaping", "ich", "afghan", "inspire", "paulo", "torn", "meantime", "pumping", "patented", "revival", "disappear", "lever", "redundant", "regency", "milfseeker", "tasty", "sbc", "midland", "gag", "synchronization", "mccarthy", "informatics", "oakley", "heck", "rants", "tarot", "didrex", "brenda", "civilians", "bark", "carts", "wasted", "purdue", "cocoa", "invites", "cushion", "reversed", "lynx", "goa", "figurines", "footer", "maternal", "specimen", "jedi", "seamless", "ancestors", "panther", "mixes", "graves", "branding", "ghetto", "thr", "examiner", "vineyard", "meadow", "panty", "feeder", "mercer", "roms", "goodman", "listener", "subunit", "chloride", "awaiting", "kane", "becker", "aires", "bulls", "orion", "commercials", "councillor", "regulators", "hurry", "influential", "clarkson", "carlson", "yy", "beneficiary", "benchmarks", "hanson", "ug", "offspring", "emi", "panorama", "retrieving", "roth", "odor", "demanded", "reactor", "kiribati", "wastes", "telnet", "clash", "biker", "fidelity", "parked", "sis", "financials", "castro", "flew", "peanut", "holden", "ale", "sem", "converters", "nauru", "rhapsody", "trumpet", "solitaire", "decreasing", "freezing", "kaiser", "dishwasher", "rcs", "wallis", "criminals", "neurons", "ios", "retire", "rumors", "accomplishments", "emergence", "feminist", "theatres", "apex", "crimson", "compassion", "yds", "needing", "twentieth", "ive", "ecosystems", "pronounced", "extensively", "stain", "conrad", "wished", "transient", "kicked", "coloring", "curb", "gadget", "cctv", "leukemia", "reign", "trivial", "deco", "ticker", "coke", "habitats", "clauses", "baron", "remover", "sensible", "unlawful", "bates", "incorporates", "brasil", "webs", "swinging", "accountable", "thrust", "proving", "unicode", "opposing", "prod", "novice", "spreadsheet", "hewitt", "lowering", "dei", "delightful", "cane", "cruising", "fury", "personalities", "discography", "stiff", "todo", "encoded", "researching", "noah", "wore", "christchurch", "pediatrics", "traces", "rabbi", "sushi", "puffy", "asap", "weston", "headings", "enthusiasts", "ridiculous", "scattering", "secretaries", "onsite", "mapquest", "contracted", "elbow", "fights", "deleting", "compilations", "therapists", "appealing", "scholarly", "detailing", "stark", "lifestyles", "roberto", "dst", "strongest", "hammond", "swimwear", "padded", "applet", "pricetool", "circa", "revise", "contributes", "threesomes", "surroundings", "proficiency", "quinn", "uranium", "honours", "consolidate", "daniels", "billions", "hut", "daewoo", "antigen", "ultrasound", "stafford", "mgmt", "procedural", "labrador", "refusal", "lima", "suppression", "weaver", "cern", "readiness", "secular", "macros", "majesty", "msa", "fishery", "teresa", "distributing", "estimating", "outdated", "aussie", "advisories", "dues", "pewter", "lendingtree", "belmont", "distress", "pumpkin", "notably", "intends", "trevor", "homosexual", "garment", "acad", "bilingual", "barbecue", "localization", "supplying", "secondly", "razor", "cough", "cerebral", "grandma", "customization", "gigs", "indexing", "lori", "oceans", "displacement", "spacecraft", "ivoire", "backwards", "arrows", "volunteering", "montserrat", "telecommunication", "presumably", "coatings", "eureka", "plea", "constructive", "bundles", "pcb", "sdk", "tibet", "preparedness", "pres", "isles", "stretching", "ovens", "systemic", "garrett", "esther", "playoffs", "abundant", "deductible", "adaptors", "priests", "accompany", "compares", "forecasting", "hesitate", "inspiring", "specialize", "prey", "deposition", "drm", "laurie", "tas", "zodiac", "pavement", "enya", "masterbation", "tubing", "keller", "pedestrian", "fencing", "bloomington", "artery", "conditioner", "plaintiffs", "inlet", "rub", "violate", "stimulate", "realise", "fluids", "conveniently", "lick", "vanessa", "gov", "stealth", "nucleotide", "ter", "ness", "bronx", "listmania", "repayment", "middot", "netgear", "canopy", "gloss", "panda", "crc", "whip", "symbian", "porch", "pertinent", "lifelong", "emailed", "promoter", "chf", "collegiate", "constants", "construed", "interchange", "remotely", "clr", "fletcher", "concise", "isuzu", "fibers", "handful", "brains", "curtains", "eaten", "indigo", "retaining", "kelley", "autobiography", "conditioned", "webring", "prohibition", "motions", "redirect", "interoperability", "msrp", "tuvalu", "shampoo", "emphasize", "excite", "rebels", "neoplasms", "artifacts", "believing", "vac", "hilarious", "salisbury", "pseudo", "gu", "quoting", "sinks", "steep", "dinar", "dynasty", "creed", "carat", "nan", "microphones", "nobel", "raiders", "galaxies", "spreads", "verlag", "elegance", "volatile", "pointers", "sensory", "scrapbook", "dummies", "throne", "magnesium", "pagina", "kenwood", "chartered", "slopes", "socially", "unfortunate", "seized", "roundup", "territorial", "leases", "imac", "consisted", "randolph", "faxes", "plump", "uss", "memoirs", "alkaline", "expire", "och", "wwii", "midst", "methyl", "campuses", "borne", "forgive", "ramada", "competitor", "mansfield", "neighbours", "tesco", "marvin", "dba", "architectures", "conversions", "acdbline", "usable", "tempo", "getty", "mutations", "cdr", "readable", "almanac", "conway", "ay", "gail", "msi", "responds", "denote", "slayer", "payne", "prog", "firewalls", "tester", "polling", "fifa", "purchaser", "bins", "relies", "inserting", "tibetan", "prepares", "concludes", "consumables", "waterford", "rodney", "cylinders", "mus", "selects", "fulton", "directing", "nationality", "highbeam", "msdn", "statistically", "torch", "zurich", "stretched", "depressed", "mps", "encounters", "haunted", "spares", "symmetry", "agp", "bout", "cont", "adverts", "programmed", "lohan", "salons", "olympia", "hank", "negligence", "unclear", "screened", "helper", "carlisle", "aromatherapy", "rancho", "transferring", "nederland", "stockton", "stepping", "hacks", "clearwater", "attic", "trustpass", "topology", "appetite", "sensation", "piper", "airborne", "morality", "honorable", "wealthy", "handicap", "skinny", "sewage", "endowment", "demonstrating", "antennas", "sundance", "lifecycle", "dhcp", "avec", "trucking", "sonoma", "esta", "defender", "amos", "iraqis", "shortcut", "wretch", "sunlight", "stems", "racist", "wo", "profitability", "unc", "fairmont", "ventura", "convey", "ang", "evergreen", "globally", "bearings", "govern", "feather", "fond", "sore", "aaliyah", "fiat", "reboot", "sixteen", "newsgroup", "blinds", "audiovox", "traits", "tightly", "graded", "phuket", "successor", "jf", "intrusion", "sickness", "guiana", "underneath", "prohibit", "metabolic", "noel", "cans", "abused", "sarasota", "billed", "lim", "avery", "toons", "danielle", "brushes", "tenth", "anthology", "prosecutor", "smiles", "merged", "auditors", "grandchildren", "exc", "desks", "capsule", "aided", "relied", "suspend", "eternity", "mesothelioma", "trafficking", "introductions", "weighing", "eff", "currents", "bizjournals", "michele", "kk", "aide", "kindly", "cutie", "nes", "protests", "sharks", "notch", "minors", "dances", "revealing", "reprinted", "fernando", "mapped", "resurrection", "lieu", "decree", "tor", "creampie", "seoul", "printf", "columnist", "discovering", "tuberculosis", "lacks", "horizons", "transplantation", "jerome", "daytime", "elaborate", "contour", "gamble", "fra", "descent", "nwt", "gravel", "analyse", "rammstein", "disturbing", "judged", "shutter", "illusion", "ambitious", "scrapbooking", "ole", "notorious", "ibid", "residue", "reds", "enlarged", "stephens", "transforming", "sequential", "stripping", "uniquely", "bart", "assert", "goodies", "fluctuations", "bowie", "auth", "archaeological", "inspect", "thrice", "babylon", "gina", "sugababes", "edison", "casualty", "rsa", "rcw", "musings", "whistler", "poses", "airfares", "huntsville", "ths", "noir", "eli", "layouts", "evan", "servicemagic", "mushroom", "designate", "scent", "sequel", "gymnastics", "titanic", "knob", "wolves", "exquisite", "herpes", "upward", "sentenced", "dundee", "newsgator", "principe", "contractual", "acquiring", "judging", "unchanged", "kicking", "meg", "akron", "fines", "grasp", "streak", "ounce", "thirteen", "bh", "tragic", "theodore", "buena", "irrelevant", "professionally", "liberties", "sounding", "rebounds", "milano", "compressor", "toast", "happily", "hooked", "samantha", "shrink", "knox", "khz", "webmail", "carcinoma", "taipei", "unesco", "mutually", "stance", "aps", "kumar", "beaded", "remembering", "boca", "exodus", "compartment", "gemini", "kinky", "brittany", "dove", "testified", "iis", "cunningham", "derive", "affinity", "presbyterian", "supervisory", "pretend", "ostg", "buddhism", "kl", "amnesty", "chiropractic", "borrower", "gloucester", "warrants", "owens", "fairness", "needles", "coll", "throughput", "quota", "netbsd", "discreet", "misplace", "versa", "imp", "oi", "serviced", "mack", "pu", "sung", "lowell", "whichever", "starr", "elliot", "opener", "uae", "vaccines", "chooses", "tuscany", "jigsaw", "jumbo", "crowded", "tickling", "unspecified", "wee", "jsp", "turbine", "unreal", "wounds", "percentages", "advisers", "manufactures", "physiological", "lett", "maths", "addison", "charters", "generalized", "unprecedented", "probes", "frustration", "flint", "dummy", "financially", "awake", "sanitation", "americana", "swivel", "ally", "dissolved", "cleanliness", "complexes", "kung", "varsity", "collectively", "insurer", "croatian", "inhibition", "multicast", "certifications", "burnt", "solidarity", "frustrated", "muhammad", "alma", "pradesh", "ger", "px", "hanover", "inverse", "clifton", "holt", "isis", "verdict", "nominee", "medals", "proton", "dickinson", "christi", "lister", "recurring", "studs", "allegedly", "rhetoric", "modifying", "incubus", "kaplan", "impulse", "surveyed", "creditors", "dull", "tis", "cabins", "commenced", "ballroom", "employing", "satellites", "ignoring", "linens", "stevenson", "coherent", "beetle", "converts", "majestic", "bicycles", "omni", "roast", "testers", "debuginfo", "complainant", "inhibitor", "clifford", "knowledgeable", "critically", "cy", "composers", "localities", "owe", "jimi", "hummer", "reciprocal", "accelerate", "hatred", "telefonsex", "questioning", "putative", "manifest", "indications", "petty", "permitting", "hyperlink", "presario", "motorsports", "som", "behave", "getaway", "bees", "robbins", "zeppelin", "felix", "shiny", "carmel", "encore", "smash", "angelina", "kimberly", "unsure", "braun", "destructive", "sockets", "claimant", "dinosaur", "psa", "tac", "ample", "countless", "ashland", "energies", "dlp", "repealed", "royce", "listeners", "abusive", "sophomore", "antibiotics", "landfill", "warehousing", "filesize", "merits", "scarf", "strangers", "garland", "voor", "celebrex", "verisign", "riviera", "apprentice", "obscure", "napoleon", "registrations", "wavelength", "glamour", "slashdot", "transvestites", "hated", "cheerleaders", "sigh", "trolley", "principals", "sidney", "friedman", "coolpix", "spicy", "blocker", "tawnee", "frankly", "hud", "chronological", "mov", "entrepreneurship", "itinerary", "fools", "beard", "discoveries", "percentile", "linkage", "economical", "miniatures", "wedge", "adjusting", "mock", "peggy", "bats", "patriots", "ruins", "lh", "sheila", "ripper", "dependencies", "afp", "kd", "accomodation", "benton", "mcafee", "chateau", "denis", "counselors", "homestead", "competitiveness", "burger", "microscopy", "changer", "sergeant", "melt", "syrian", "hyper", "madthumbs", "linkin", "gmail", "ned", "cypress", "courtney", "cites", "utf", "scooters", "reserveamerica", "organisational", "prospectus", "ezine", "protectors", "reactive", "interiors", "encouragement", "clipboard", "disadvantages", "gamer", "alexa", "abbott", "tailor", "pollutants", "directorate", "chocolates", "faux", "supervised", "interpreting", "savvy", "pascal", "tha", "serenity", "uploads", "ore", "pant", "sheridan", "gallons", "attainment", "sanitary", "terri", "cooperate", "dreaming", "norms", "implants", "fortunate", "alibaba", "mushrooms", "hormones", "hype", "interpretations", "geoffrey", "faults", "addr", "nfs", "silva", "grease", "diablo", "urinary", "cairns", "institut", "premise", "epidemic", "prima", "condoms", "rite", "directives", "cinnamon", "zelda", "lac", "discharged", "alba", "underworld", "variants", "fetal", "palms", "lawsuits", "seated", "lattice", "dong", "realization", "reportedly", "absorbed", "sirius", "chord", "edi", "kudoz", "vous", "turf", "asphalt", "replay", "improper", "flavors", "dilemma", "ig", "rebuilding", "livingston", "quickcheck", "commenting", "shifted", "tangible", "smoked", "hawks", "ziff", "placebo", "irons", "comet", "berg", "baltic", "corrective", "competency", "muse", "probing", "teachings", "tyne", "lotto", "fowler", "xv", "youngest", "contingent", "refreshing", "textures", "pid", "syrup", "xii", "warmth", "hawkins", "dep", "lust", "correlated", "augustine", "dominion", "verses", "seagate", "nanotechnology", "astronomical", "solvent", "toggle", "luna", "amplitude", "aesthetic", "commercially", "emc", "dion", "wolfgang", "spacing", "frameworks", "completeness", "irregular", "barker", "solids", "mergers", "capturing", "filtration", "certify", "gpa", "consulted", "realised", "cpus", "jude", "eighteen", "singular", "incremental", "jennings", "demons", "unacceptable", "redistribute", "coping", "corr", "baxter", "outbreak", "abdominal", "sbin", "deficiencies", "curved", "milestone", "erase", "lien", "nip", "bites", "prose", "marx", "incidental", "toni", "arguing", "vein", "scalable", "hale", "ji", "swear", "intra", "bel", "clown", "spontaneous", "summers", "taboo", "equestrian", "wetland", "olson", "methodologies", "malicious", "consume", "amazed", "fourteen", "legislators", "volcano", "capacities", "fremont", "skeleton", "someday", "tsp", "sha", "suspects", "displaced", "sounded", "exporter", "honesty", "dwarf", "mri", "hum", "bis", "northeastern", "ifdef", "shocks", "rewarding", "killers", "battalion", "multicultural", "lasers", "candid", "schooling", "dataset", "thornton", "schoolgirl", "caesar", "savers", "powerpc", "pines", "steelers", "stellar", "davenport", "locating", "monogram", "philippe", "enhances", "aix", "fucks", "relational", "ornament", "graffiti", "cassettes", "pussies", "urges", "sophie", "doesnt", "tiff", "cnc", "refrigeration", "attacking", "microscope", "houghton", "countdown", "threaten", "decker", "natl", "bait", "extern", "badges", "enron", "kitten", "codec", "broadcasts", "brides", "dent", "checksum", "stealing", "bullets", "emphasized", "glossy", "informations", "haired", "directional", "breeders", "alterations", "pablo", "lethal", "biographical", "confirms", "cavity", "molded", "vladimir", "ida", "probate", "terrestrial", "decals", "completes", "beams", "props", "incense", "formulated", "dough", "stool", "macs", "towing", "welch", "rosemary", "millionaire", "turquoise", "archival", "seismic", "exposures", "baccarat", "boone", "substituted", "horde", "paperwork", "mommy", "teenager", "nanny", "suburb", "hutchinson", "smokers", "cohort", "succession", "declining", "alliances", "sums", "lineup", "averaged", "hotspot", "bellevue", "glacier", "pueblo", "hj", "req", "rigorous", "gigabit", "worksheet", "allocate", "relieve", "aftermath", "roach", "clarion", "override", "angus", "enthusiastic", "lame", "continuum", "squeeze", "feng", "sar", "burgundy", "struggles", "pep", "farewell", "soho", "ashes", "vanguard", "nylons", "chipset", "natal", "locus", "msnbc", "hillary", "evenings", "misses", "troubles", "factual", "carisoprodol", "tutoring", "spectroscopy", "gemstone", "psc", "phonephone", "elton", "purity", "shaking", "unregistered", "witnessed", "cellar", "moto", "gonzalez", "friction", "prone", "valerie", "enclosures", "dior", "mer", "equitable", "fuse", "lobster", "pops", "osha", "judaism", "goldberg", "atlantis", "amid", "onions", "preteen", "bonding", "insurers", "prototypes", "corinthians", "crosses", "proactive", "issuer", "uncomfortable", "sylvia", "furnace", "sponsoring", "poisoning", "doubled", "malaysian", "clues", "inflammation", "rabbits", "icc", "transported", "crews", "easton", "goodwill", "sentencing", "bulldogs", "worthwhile", "ideology", "anxious", "tariffs", "norris", "ly", "cervical", "baptism", "cutlery", "overlooking", "tallahassee", "userpic", "knot", "attribution", "rad", "gut", "staffordshire", "factories", "acta", "swords", "advancing", "yep", "timed", "evolve", "yuan", "iec", "differs", "esa", "suspicious", "leased", "subscribed", "tate", "starters", "dartmouth", "brewing", "coop", "uml", "bur", "blossom", "scare", "confessions", "bergen", "lowered", "kris", "thief", "prisons", "pictured", "feminine", "sizeof", "grabbed", "rocking", "spi", "nichols", "regs", "blackwell", "fulfilled", "sweets", "nautical", "imprisonment", "employs", "gutenberg", "bubbles", "ashton", "pitcher", "shinedown", "standby", "judgments", "muscular", "motif", "illnesses", "plum", "saloon", "prophecy", "loft", "arin", "unisex", "historian", "wallets", "identifiable", "elm", "facsimile", "hurts", "ethanol", "cannabis", "folded", "rsvp", "sofia", "dynamically", "comprise", "grenadines", "lump", "constr", "disposed", "subtitle", "chestnut", "librarians", "engraved", "halt", "alta", "manson", "autocad", "pastoral", "unpaid", "ghosts", "powerbook", "doubts", "locality", "substantive", "bulletins", "worries", "hug", "rejects", "spear", "nigel", "referee", "transporter", "jolie", "swinger", "broadly", "ethereal", "crossroads", "aero", "constructing", "smoothly", "parsons", "bury", "infiniti", "blanc", "autonomy", "bounded", "ppl", "williamsburg", "insist", "birch", "supp", "slash", "snyder", "budgeting", "exercised", "backpacks", "detecting", "resale", "mikes", "howell", "digestive", "scalar", "entertain", "cinderella", "unresolved", "sesame", "hep", "duct", "touches", "seiko", "electromagnetic", "arial", "tos", "joanne", "housewife", "zoofilia", "hcl", "pursued", "validated", "lend", "sco", "corvette", "yachts", "stacy", "christie", "unrelated", "lois", "levi", "annotate", "stimulating", "mont", "joomla", "misuse", "helix", "cosmos", "speculation", "sx", "dixie", "pans", "enforced", "legion", "env", "fulfillment", "biomass", "assertion", "phs", "hierarchical", "lesions", "shook", "lincolnshire", "financed", "dismissal", "surnames", "mah", "reconditioned", "shocking", "allergic", "overland", "prolonged", "isaiah", "backbone", "rk", "abn", "unanimously", "eliminates", "sausage", "addict", "matte", "neighboring", "uncommon", "centralized", "stratford", "heidi", "melanie", "objections", "unpublished", "ames", "slaughter", "enlightenment", "pistol", "juniors", "rockets", "secunia", "metering", "seymour", "genetically", "zebra", "runway", "arithmetic", "supposedly", "admits", "bombay", "originals", "enrichment", "chennai", "milford", "buckle", "bartlett", "fetch", "kitchens", "ions", "asshole", "wat", "rey", "divers", "faroe", "townsend", "blackburn", "glendale", "speedway", "founders", "sweatshirts", "sundays", "upside", "admiral", "yay", "patron", "sandwiches", "sinclair", "boiler", "anticipate", "activex", "logon", "induce", "annapolis", "padding", "recruiter", "popcorn", "espanol", "disadvantaged", "trong", "diagonal", "unite", "cracked", "debtor", "polk", "mets", "niue", "ux", "shear", "mortal", "sovereignty", "supermarket", "franchises", "rams", "cleansing", "mfr", "boo", "hmmm", "genomic", "gown", "helpdesk", "ponds", "archery", "refuses", "excludes", "afb", "sabbath", "ruin", "trump", "nate", "escaped", "precursor", "mates", "adhd", "avian", "exe", "stella", "visas", "matrices", "anyways", "xtreme", "passages", "etiology", "vu", "cereal", "comprehension", "tcl", "sy", "tow", "resolving", "mellon", "drills", "webmd", "alexandra", "champ", "personalised", "hospice", "zerodegrees", "agreeing", "qos", "exhibitor", "rented", "deductions", "harrisburg", "brushed", "augmentation", "otto", "annuity", "assortment", "credible", "sportswear", "ik", "cultured", "importing", "deliberately", "recap", "openly", "toddlers", "astro", "crawl", "chanel", "theo", "sparkling", "jabber", "hgh", "bindings", "hx", "convincing", "rotate", "flaws", "este", "tracing", "deviations", "incomes", "fema", "subwoofer", "amortization", "neurology", "ack", "fragile", "jeremiah", "sapiens", "nyt", "olsen", "serbian", "radiator", "hai", "competencies", "restoring", "sanchez", "rushing", "behold", "amherst", "alteration", "hotspots", "trainee", "nielsen", "podcasting", "murdered", "centennial", "tuna", "bluegrass", "hazel", "wipe", "ledger", "scarlet", "crushed", "acronyms", "laughs", "connie", "autographed", "referendum", "modulation", "statues", "depths", "spices", "communion", "loader", "uncertainties", "colonies", "followers", "caldwell", "latency", "themed", "messy", "squadron", "bei", "dmc", "rupee", "ments", "subsidy", "demolition", "irene", "empowerment", "felony", "lungs", "monuments", "veronica", "filtered", "replacements", "growers", "vinci", "subtitles", "adj", "gcse", "haul", "acupuncture", "workload", "acknowledgement", "highlighting", "duly", "roasted", "tenders", "inviting", "rig", "ov", "grassroots", "mick", "gentoo", "redevelopment", "mustard", "strait", "masterpiece", "obey", "cellphone", "donkey", "sax", "jacks", "conceived", "triggered", "boasts", "praying", "oss", "multiply", "intercourse", "frontgate", "radial", "mare", "routinely", "instructed", "stole", "kirby", "armour", "summarized", "avalanche", "asc", "northampton", "uploading", "manuscripts", "managerial", "nsu", "cary", "celine", "exhibited", "disciples", "shaving", "finepix", "wks", "bishops", "kite", "destroying", "humorous", "tonnes", "hypermail", "thunderbird", "faa", "corona", "heap", "griffith", "investigative", "letras", "bylaws", "erection", "quasi", "wmv", "lao", "energetic", "disturbance", "saunders", "ribbons", "jew", "facesitting", "exile", "breastfeeding", "bilder", "reside", "mccartney", "anglo", "cashier", "kathryn", "jaw", "butterflies", "eats", "randomized", "knots", "flea", "motivational", "offences", "anton", "pals", "gratuite", "gerry", "celebrates", "hail", "armenian", "longitudinal", "historians", "realities", "kappa", "mentions", "samson", "neuroscience", "blender", "jumps", "fleming", "blaster", "optimistic", "remediation", "wasting", "decoder", "genocide", "acclaimed", "seldom", "heathrow", "indy", "morrow", "pantera", "glitter", "giovanni", "sidebar", "authored", "lasted", "snoop", "awhile", "winery", "rbi", "scaled", "contingency", "photon", "wiltshire", "vague", "overlay", "wraps", "constituents", "rusty", "pharma", "herd", "handicapped", "exported", "fayetteville", "lag", "champaign", "warns", "fyi", "xc", "pakistani", "harmless", "ics", "apa", "bitches", "sting", "urbana", "bravo", "believers", "diagnose", "secsg", "franco", "announcing", "dispersion", "curiosity", "trivium", "amature", "showroom", "cx", "swarovski", "resting", "missiles", "persistence", "coarse", "continents", "liter", "carpets", "recovering", "submarine", "akon", "blessings", "brendan", "prevailing", "originated", "axe", "condosaver", "sculptures", "amex", "intrinsic", "classicvacations", "blackpool", "thoughtful", "nicht", "archer", "hertfordshire", "fh", "inuyasha", "nominees", "warmer", "cuz", "viewsonic", "dryers", "calf", "fujifilm", "basil", "ams", "hallmark", "counterparts", "paced", "engl", "grouped", "dominate", "asians", "orient", "contra", "damaging", "populated", "seether", "renee", "boiling", "journeys", "milestones", "parkinson", "parsing", "splitting", "mclean", "derbyshire", "checkboxes", "abandon", "lobbying", "rave", "ej", "dy", "mgm", "cigars", "cinemas", "islander", "encoder", "nicolas", "inference", "ras", "recalled", "importers", "impressum", "transformer", "weiss", "declarations", "rib", "phe", "chattanooga", "giles", "maroon", "drafts", "excursions", "jerk", "kontakt", "shack", "ers", "marrow", "kawasaki", "licences", "bose", "tavern", "bathing", "lambert", "epilepsy", "allowances", "fountains", "goggles", "ses", "unhappy", "clones", "foregoing", "crossover", "situ", "specificity", "certainty", "sleek", "gerard", "runoff", "osteoporosis", "approvals", "antarctic", "ord", "successive", "neglected", "ariel", "bea", "monty", "cafes", "jukebox", "classmates", "hitch", "fracture", "ama", "nexus", "cancers", "foremost", "nineteenth", "chesapeake", "tango", "melting", "mahogany", "actresses", "clarence", "ernst", "garner", "buster", "moderated", "mal", "nassau", "flap", "ignorant", "aba", "allowable", "karate", "compositions", "sings", "marcos", "sorrow", "carte", "qb", "canned", "collects", "treaties", "endurance", "optimizing", "teaspoon", "switchfoot", "coldplay", "insulated", "dupont", "harriet", "philosopher", "rectangle", "woo", "queer", "pains", "vioxx", "decatur", "wrapper", "tty", "ahmed", "bsc", "buchanan", "drummer", "sobre", "celexa", "guitarist", "symmetric", "ceremonies", "satisfies", "kuala", "appellate", "comma", "bbb", "geeks", "conformity", "jg", "avant", "repec", "insightful", "supper", "fulfilling", "hooded", "unrated", "diva", "adsense", "instability", "seminary", "exemptions", "integrates", "presenter", "csa", "offenses", "emulation", "lengthy", "sonata", "fortress", "contiguous", "bookstores", "perez", "cimel", "inaccurate", "hvac", "explanatory", "leica", "settlers", "stools", "ministerial", "xavier", "agendas", "torah", "fao", "publishes", "stacks", "owning", "nws", "andersen", "busch", "armani", "bipolar", "sermon", "facilitating", "complained", "ferdinand", "taps", "thrill", "lagoon", "undoubtedly", "menopause", "inbound", "withheld", "insisted", "shortlist", "gainesville", "tiava", "eclectic", "reluctant", "headphone", "regimes", "headaches", "ramsey", "oath", "readme", "pigeon", "rivals", "freed", "binder", "xemacs", "constrained", "parrot", "magnum", "invoked", "invaluable", "helicopters", "keystone", "inclined", "ngc", "gala", "intercontinental", "cheek", "traction", "utterly", "workspace", "customizable", "softcover", "gavin", "illuminated", "realtime", "lasts", "gloucestershire", "electrons", "psychologist", "dane", "claudia", "perpetual", "subsystem", "appl", "kinetic", "caffeine", "solicitor", "clustering", "xf", "glimpse", "nib", "verbatim", "innocence", "httpd", "quicker", "grandparents", "cardboard", "attributable", "sketches", "angelo", "tertiary", "exhausted", "smarter", "slac", "shelters", "attain", "dora", "calorie", "inconvenience", "tang", "graphite", "vaccination", "stroller", "farther", "bowel", "sweaters", "chats", "mafia", "riot", "fats", "futuna", "mandarin", "dungeon", "predictable", "germans", "lilly", "shire", "susceptible", "mosquito", "kashmir", "insest", "lyons", "skyline", "sulfur", "scams", "lipid", "putnam", "corpse", "speedy", "ming", "tao", "quot", "ritz", "networked", "localhost", "lush", "barrels", "transformations", "cabling", "analogue", "werner", "clyde", "stills", "perimeter", "biased", "cardiology", "playoff", "honorary", "sti", "irwin", "brewer", "chiang", "exchanged", "payload", "adhere", "fran", "merrill", "oldsmobile", "grilled", "rafael", "ccc", "enquire", "toilets", "mains", "whales", "misty", "lindsey", "parity", "partitions", "grim", "conserved", "searchsearch", "hubbard", "rewrite", "vending", "prism", "chasing", "keygen", "janeiro", "flop", "aggregation", "shelley", "batting", "borrowed", "heh", "transexuals", "rests", "toss", "prentice", "depicted", "grapes", "proposing", "cumbria", "winding", "diaz", "ripped", "vegan", "congressman", "cobalt", "pity", "recombinant", "ubuntu", "downward", "superstar", "closeout", "corel", "kayaking", "synergy", "eta", "catalogues", "aspire", "harvesting", "garfield", "groom", "jewels", "saturated", "georges", "backpacking", "quincy", "accidentally", "doughty", "bonded", "sticking", "dudley", "osama", "weeds", "stripped", "oprah", "inflatable", "beers", "clive", "fixture", "glassware", "canary", "steadily", "amc", "imagined", "darby", "woke", "kos", "fills", "proportions", "grips", "clergy", "coursework", "solicitors", "kayak", "moderately", "mayotte", "altar", "salvage", "repetitive", "stanton", "creators", "gears", "orbital", "musicals", "kilometres", "cuff", "lithuanian", "amatuer", "repeating", "empires", "profiling", "reps", "hn", "oyster", "sturdy", "sequencing", "massacre", "undergo", "panoramic", "risen", "blended", "deskjet", "rhino", "polynomial", "tau", "nsa", "imperative", "stakeholder", "beg", "digging", "lantern", "catches", "evangelical", "eaton", "ruler", "signifies", "henri", "stochastic", "psu", "tokens", "santana", "kidding", "piping", "swept", "swansea", "airmail", "staring", "seventy", "problematic", "troop", "arose", "decomposition", "chatham", "roadmap", "ogg", "becky", "lesbo", "farrell", "elders", "interpreters", "supporter", "acknowledgements", "klaus", "tnt", "skincare", "conquest", "heroin", "repairing", "mandated", "workbook", "assemble", "xslt", "hogan", "omg", "whistle", "sulfate", "dresden", "timeshare", "diversified", "oldies", "fertilizer", "complaining", "analytic", "predominantly", "amethyst", "debra", "woodward", "rewritten", "cdrom", "concerto", "adorable", "ambition", "torres", "apologize", "cle", "restraint", "thrillers", "fortran", "eddy", "condemned", "berger", "timeless", "parole", "corey", "kendall", "spouses", "slips", "vv", "ninety", "tyr", "trays", "stewardship", "cues", "esq", "bioinformatics", "kisses", "kerr", "regulating", "flock", "exporting", "arabian", "chung", "subpart", "scheduler", "bending", "boris", "hypnosis", "kat", "ammunition", "vega", "pleasures", "shortest", "denying", "cornerstone", "recycle", "shave", "sos", "lsu", "sexe", "disruption", "galway", "colt", "artillery", "furnish", "precedence", "gao", "applicability", "volatility", "grinding", "rubbish", "missionary", "knocked", "swamp", "uid", "pitching", "hoteles", "fav", "bordeaux", "manifold", "wf", "tornado", "disneyland", "umd", "gdb", "possessed", "upstairs", "bro", "turtles", "offs", "listserv", "fab", "vauxhall", "cond", "welcoming", "learns", "manipulate", "dividing", "hickory", "renovated", "inmates", "tokelau", "conformance", "slices", "diecast", "bittorrent", "cody", "frankie", "oa", "lawson", "quo", "iu", "vf", "alprazolam", "damned", "beethoven", "faint", "rebuilt", "proceeded", "collaborate", "lei", "tentative", "peterborough", "fierce", "jars", "authenticity", "hips", "rene", "gland", "positives", "wigs", "resignation", "striped", "zion", "blends", "garments", "fraternity", "hunk", "allocations", "lymphoma", "tapestry", "originating", "stu", "chap", "blows", "inevitably", "rpc", "freebies", "converse", "frontline", "thb", "tele", "gardener", "imap", "winamp", "winnie", "ita", "higgins", "stoke", "idg", "warwickshire", "polymers", "penguins", "attracting", "grills", "jeeves", "harp", "phat", "zz", "escrow", "lumpur", "wes", "dds", "denton", "anthem", "tack", "whitman", "nowadays", "woodstock", "infospace", "sack", "inferior", "surfers", "abuses", "inspected", "deb", "jockey", "kauai", "licensors", "indicative", "cpc", "stresses", "incumbent", "ithaca", "webhosting", "edmund", "peoria", "upholstery", "aggression", "peek", "alr", "practiced", "ella", "casualties", "ipsec", "bournemouth", "sudoku", "monarch", "undef", "housed", "administering", "temptation", "havana", "roe", "campground", "nasal", "sars", "restrictive", "costing", "ranged", "cme", "predictive", "vlan", "aquaculture", "hier", "spruce", "paradox", "sendmail", "redesign", "billings", "jeanne", "nitro", "oxidation", "jackpot", "marin", "halfway", "cortex", "entitlement", "amending", "conflicting", "georgian", "compensate", "recherche", "loser", "secs", "mixers", "accountancy", "claus", "policing", "braves", "cracking", "sued", "shoots", "michaels", "interrupted", "hemisphere", "miranda", "clover", "ecc", "kj", "kindness", "similarities", "kv", "hipaa", "porto", "neutron", "duluth", "directs", "jolly", "snakes", "swelling", "spanning", "politician", "femme", "unanimous", "railways", "approves", "scriptures", "misconduct", "lester", "dogg", "folklore", "resides", "wording", "obliged", "perceive", "rockies", "siege", "dimm", "exercising", "acoustics", "voluntarily", "pensacola", "atkinson", "crs", "condominium", "wildcats", "nord", "exhibitors", "truths", "ssi", "grouping", "wolfe", "redwood", "thereto", "invoices", "tyres", "westwood", "authorizing", "enamel", "toby", "gly", "radiant", "estonian", "virgins", "firstly", "martini", "butte", "bomber", "reeves", "songwriter", "suspicion", "disadvantage", "bastard", "shania", "coaster", "spends", "hicks", "typedef", "pratt", "pedigree", "strippers", "macmillan", "fraudulent", "aac", "woodworking", "sherwood", "forgiveness", "cbd", "almond", "pricerunner", "afl", "catalytic", "har", "petitions", "francais", "trenton", "chalk", "omar", "alexis", "bethesda", "privatization", "sourceforge", "sanford", "axle", "membranes", "puppet", "testosterone", "cultivation", "nunavut", "surveying", "grazing", "biochemical", "pillar", "mirage", "lennon", "questionable", "seaside", "suitability", "precinct", "renamed", "cobb", "lara", "unbelievable", "soluble", "piracy", "rowing", "siding", "kx", "hardest", "forrest", "invitational", "reminders", "negro", "blanca", "equivalents", "johann", "handcrafted", "aftermarket", "pineapple", "fellowships", "freeway", "wrath", "opal", "simplest", "patrons", "peculiar", "toon", "europeans", "commence", "descendants", "redmond", "safeguard", "digitally", "lars", "hatchback", "rfp", "obsession", "grind", "albeit", "billiards", "coa", "clint", "bankers", "righteous", "eo", "redistribution", "freaks", "subclass", "rutgers", "tra", "sampled", "sincere", "deploying", "interacting", "roanoke", "intentionally", "blitz", "tended", "censorship", "cactus", "viva", "treadmill", "fiberglass", "attained", "blew", "howe", "nap", "osaka", "splendid", "janice", "personalize", "lava", "leonardo", "sucked", "scissors", "broncos", "jorge", "cooks", "sharply", "granada", "laurence", "rebellion", "rainy", "tho", "regent", "evelyn", "vinegar", "vie", "classifications", "diggs", "rafting", "pluto", "gil", "sle", "vail", "jv", "fisherman", "misery", "undergoing", "limerick", "safaris", "contaminants", "envy", "scr", "mitch", "sweeping", "healthier", "ussr", "mailer", "preface", "jameson", "grievance", "liners", "asheville", "unread", "sentiment", "pencils", "galloway", "quinta", "kristin", "forged", "bistro", "viola", "lw", "voodoo", "disclosures", "provence", "caching", "computerized", "rustic", "rumor", "dillon", "shah", "eleanor", "deception", "volts", "conducts", "divorced", "rushed", "excalibur", "bots", "weighs", "sinatra", "magnolia", "diver", "disappointment", "castles", "notions", "plateau", "interpersonal", "dexter", "traumatic", "ringer", "zipper", "meds", "palette", "blaze", "wreck", "threatens", "strengthened", "sammy", "briefings", "siblings", "wakefield", "adversely", "devastating", "pitcairn", "centro", "pdb", "arabs", "bild", "onboard", "robbery", "eine", "nucleic", "telecoms", "jasmine", "crochet", "brock", "crowds", "hoops", "hehe", "macon", "celeron", "lynne", "invariant", "stamped", "challenger", "increment", "redistributed", "ju", "uptake", "newsweek", "geared", "ideals", "chloe", "ape", "svc", "gee", "apologies", "prada", "tycoon", "malignant", "maxtor", "plone", "dcp", "dismiss", "preceded", "lawful", "stag", "crosby", "biochem", "pte", "rash", "ors", "gateways", "compactflash", "collapsed", "antibiotic", "horns", "vanderbilt", "cps", "diversion", "overweight", "fantasies", "metasearch", "taliban", "maureen", "trekking", "coordinators", "beginnings", "reversal", "digi", "lex", "shoreline", "presses", "ordination", "westin", "oxfordshire", "yves", "tandem", "middleware", "mips", "boil", "deliberate", "gagged", "roundtable", "surprises", "abe", "roc", "dementia", "barley", "potent", "vo", "amusing", "mastering", "levine", "nerves", "ripencc", "shoppy", "filesystem", "retains", "pow", "docking", "guidebook", "atreyu", "kylie", "pilates", "chimney", "backstreet", "packers", "localized", "naomi", "proverbs", "lic", "risky", "mistaken", "carving", "miracles", "docume", "xy", "clair", "fte", "slipped", "realism", "stl", "crete", "fractions", "yd", "archiving", "disconnect", "bloodhound", "multilingual", "sherry", "desperately", "gsa", "indies", "tulip", "madame", "remedial", "vain", "bert", "immunization", "dalton", "bologna", "departing", "ciara", "maze", "cumming", "barefoot", "remuneration", "bohemian", "interviewing", "categorized", "imposing", "damon", "tivoli", "cmos", "transmissions", "receivable", "rode", "amen", "marching", "ronnie", "evacuation", "owing", "warp", "implant", "playlists", "thematic", "brentwood", "catholics", "imo", "correctional", "faculties", "katz", "denies", "jojo", "buffers", "talkback", "servings", "reinforce", "kobe", "inception", "draper", "baylor", "otc", "bowman", "frustrating", "subversion", "ssa", "zeta", "benny", "spires", "barney", "dinnerware", "sclerosis", "homosexuality", "declares", "emotionally", "masonry", "carbohydrate", "medicinal", "estrogen", "odbc", "ipods", "accrued", "temples", "realizing", "annum", "openbsd", "cemeteries", "indoors", "telescopes", "magellan", "champs", "federated", "averaging", "salads", "addicted", "shui", "flashlight", "disappointing", "rockford", "eighty", "staging", "unlocked", "scarce", "statistic", "roche", "ropes", "torino", "spiders", "obedience", "plague", "diluted", "canine", "gladly", "schizophrenia", "brewery", "lineage", "mehr", "brew", "vaughan", "kern", "julius", "coup", "cannes", "morse", "dominance", "predators", "piston", "itu", "cords", "mpi", "revisited", "cass", "sealing", "topped", "adhesives", "rag", "despair", "inventories", "fore", "uf", "brokeback", "absorb", "injected", "alps", "commodore", "dumping", "enlisted", "prophets", "ow", "econ", "footjob", "warez", "supernatural", "overlooked", "magenta", "tagging", "ditch", "feared", "prelude", "rowe", "slick", "overly", "limestone", "triggers", "commentaries", "constructs", "impedance", "dragonfly", "manpower", "underoath", "lec", "chunk", "reels", "lob", "slept", "gregg", "refundable", "hbo", "billboard", "drafted", "chalet", "huang", "sportsbook", "layered", "hopper", "sus", "neurological", "subs", "specialization", "abstraction", "ludwig", "watchdog", "scandinavian", "starbucks", "ibook", "viability", "kh", "detained", "luncheon", "filler", "smiley", "zenith", "genomics", "yi", "yum", "browns", "researched", "waits", "tenor", "copiers", "ovarian", "softly", "plenary", "scrub", "airplanes", "wilkinson", "limb", "intestinal", "cello", "poe", "wlan", "refusing", "suffers", "sweepstakes", "occupy", "antigens", "gan", "midtown", "bethlehem", "stabilization", "caves", "authoritative", "celestial", "immense", "audrey", "merlin", "kinetics", "cocos", "aiming", "seizure", "stuttgart", "diplomacy", "differing", "impacted", "foreigners", "limp", "capitalist", "rumsfeld", "mute", "beanie", "prescott", "protestant", "metre", "tricky", "ordinances", "thurs", "spaced", "koch", "freq", "topaz", "ans", "segmentation", "imaginary", "albion", "soaps", "courthouse", "sutherland", "entrepreneurial", "dar", "dart", "lebanese", "psycho", "maharashtra", "ricoh", "wrought", "robe", "nrc", "theresa", "heidelberg", "multitude", "tutors", "ezra", "housekeeping", "captive", "kettle", "visitation", "chr", "gibbs", "baggage", "chavez", "dusty", "patty", "serena", "asst", "satire", "overload", "tortured", "pioneers", "vikings", "crate", "kanye", "bootstrap", "wtf", "episcopal", "humane", "scm", "moonlight", "mast", "travelocity", "unfinished", "fno", "goth", "cared", "affection", "sworn", "twink", "bowen", "vicious", "educating", "nortel", "kin", "koh", "affiliations", "cozy", "pussycat", "appropriated", "escherichia", "mallorca", "mackenzie", "reversible", "spd", "oj", "slippers", "unclassified", "earthquakes", "bookshelf", "hayward", "wandering", "comb", "liquids", "htdocs", "beech", "vineyards", "amer", "zur", "frogs", "fps", "consequential", "initialization", "unreasonable", "expat", "osborne", "raider", "farmington", "timers", "stimulus", "economists", "miners", "agnes", "constituency", "rocker", "acknowledges", "alas", "enrolment", "glibc", "sawyer", "maori", "lawmakers", "tense", "predicting", "filipino", "cooled", "prudential", "basel", "migrant", "devotion", "larson", "photosmart", "invoke", "arte", "leaning", "centrally", "acl", "luv", "paddle", "watkins", "oxley", "anterior", "dealership", "chop", "eyewear", "rooted", "onyx", "benches", "illumination", "freedoms", "bakersfield", "foolish", "finale", "weaker", "foley", "fir", "stirling", "moran", "decal", "compose", "nausea", "comfortably", "hoop", "addictive", "clarinet", "temps", "fiona", "clearer", "vn", "floods", "gigabyte", "fritz", "mover", "dbz", "modeled", "erica", "malaga", "rainforest", "federally", "sustaining", "macos", "repaired", "diocese", "francois", "obituary", "multinational", "painters", "thistle", "pornstars", "tem", "sleepy", "nope", "footnotes", "evo", "rupert", "shrine", "aspirin", "purified", "striving", "dire", "attendant", "gull", "jour", "mir", "spoilers", "northumberland", "machining", "malibu", "memoir", "betsy", "gatwick", "shaun", "redundancy", "meredith", "fauna", "cliffs", "hayden", "emo", "roadside", "smells", "dispose", "detox", "waking", "feathers", "skateboard", "reflex", "falcons", "automate", "drosophila", "branson", "spurs", "sion", "ortho", "crashed", "appraisals", "travelled", "urgency", "flashes", "lakewood", "gould", "brit", "drupal", "prac", "eliza", "carers", "kramer", "graduating", "rims", "harmonic", "usaid", "darts", "idc", "shin", "intriguing", "keypad", "flaw", "richland", "tails", "emulator", "microbial", "discarded", "bibles", "hangs", "adc", "caregivers", "joanna", "quark", "zyban", "synonyms", "electronica", "stranded", "mitochondrial", "horton", "dolce", "hercules", "pane", "browning", "angular", "veins", "folds", "grinder", "angie", "sneak", "octet", "wj", "incorrectly", "avoidance", "cre", "dinosaurs", "sauces", "conquer", "mccoy", "probabilities", "vibe", "immortal", "mariners", "snapshots", "ubc", "endeavor", "creole", "mateo", "meth", "trendy", "teas", "settling", "inpatient", "filming", "badger", "mohammed", "saturdays", "partisan", "fread", "backend", "pri", "gratitude", "impress", "willy", "anon", "eminent", "ribs", "communicated", "exceptionally", "quilts", "cartier", "ageing", "splits", "subscribing", "companions", "cheques", "containment", "keynes", "protections", "edith", "aliases", "maximizing", "screwed", "handsfree", "tomcat", "magna", "walmart", "sectional", "interestingly", "fashionable", "polly", "tidal", "jules", "ballots", "hog", "ernie", "testify", "poole", "boycott", "elem", "vitality", "clerks", "crust", "bothered", "traverse", "vengeance", "organisers", "dolly", "pissed", "garrison", "nite", "sal", "barb", "mckenzie", "lenox", "huns", "miner", "fashions", "darussalam", "genital", "mcse", "barr", "analogy", "insomnia", "constituent", "aura", "cecil", "sponge", "cajun", "csu", "algebraic", "sect", "astm", "diner", "anticipation", "enduring", "scarborough", "kristen", "regis", "fsa", "winters", "nous", "explosives", "mound", "xiv", "backgammon", "sgd", "ox", "chromatography", "overdose", "nad", "gallagher", "snatch", "mueller", "mole", "obs", "owed", "ethan", "cao", "ladyboys", "orgasms", "plantronics", "ftd", "kissed", "buff", "freezers", "butcher", "psalms", "rum", "ibiza", "reese", "chefs", "engraving", "digimon", "constituted", "gastrointestinal", "hamlet", "inspiron", "pagerank", "asm", "smb", "contrib", "clad", "excursion", "blu", "matlab", "inverness", "orb", "grange", "netware", "bse", "megapixels", "resigned", "retriever", "fled", "svalbard", "enriched", "harrington", "brandy", "swings", "pixar", "scion", "elle", "reptiles", "dhtml", "vortex", "swallowing", "winme", "purses", "bodily", "func", "xiii", "awe", "gamespy", "beaumont", "standalone", "australasia", "mandy", "hoods", "antitrust", "equine", "bros", "fireplaces", "proto", "jared", "requisite", "retrospective", "emphasizes", "lizard", "hawthorne", "tehran", "bouquets", "dal", "wears", "anesthesia", "shropshire", "baja", "filemaker", "regal", "safeguards", "cabbage", "cub", "libtool", "wrongful", "spectator", "arrests", "circumstance", "signage", "numbering", "psy", "encode", "admins", "moc", "dau", "alvin", "accolades", "raton", "sliced", "reproductions", "stefani", "infertility", "byrd", "sidewalk", "prob", "breaker", "curly", "servlet", "alberto", "collage", "asserted", "aces", "depeche", "benchmarking", "jealous", "refinement", "durban", "learnt", "xxl", "hound", "squirrel", "teleflora", "concealed", "bankruptcies", "gauges", "blueprint", "mccain", "spiderman", "bridging", "wharf", "rhythms", "departures", "flick", "datum", "shotgun", "stimulated", "chickens", "canceled", "langley", "briggs", "cheyenne", "empowering", "lug", "ymca", "surveyor", "facilitator", "bos", "macworld", "wwf", "maize", "galveston", "extinction", "unaware", "rockville", "banff", "discretionary", "smc", "ry", "lq", "psalm", "serv", "ipo", "tek", "scented", "ipc", "timestamp", "musica", "bib", "gowns", "stevie", "spying", "nicholson", "rivera", "dermatology", "lied", "ek", "sandbox", "bloc", "mdt", "pinkworld", "cambridgeshire", "premiership", "luton", "recurrent", "talbot", "conftest", "leaks", "tam", "recursive", "swell", "obstacle", "ville", "registerregister", "fluorescence", "kosher", "mantle", "additives", "chico", "driveway", "irony", "gesture", "fairbanks", "parfum", "marketed", "armies", "hy", "hugs", "greenfield", "santos", "owls", "mandrake", "cutters", "camper", "acquires", "cpr", "ceased", "merging", "plaques", "breadth", "mammoth", "liquidity", "convictions", "lasik", "intentional", "galactic", "sophia", "merchandising", "prohibits", "ombudsman", "innings", "registrant", "reorganization", "pronunciation", "firefighters", "placements", "ih", "concession", "measurable", "elec", "ami", "parcels", "pastry", "manners", "levin", "academia", "amiga", "phosphorus", "viper", "descriptor", "hid", "volcanic", "gypsy", "thieves", "preaching", "pimp", "repeal", "gimp", "uncovered", "hemp", "eileen", "proficient", "pelican", "cyclic", "swimsuit", "apocalypse", "morphology", "versace", "printprinter", "cousins", "discharges", "giorgio", "condom", "admire", "westerns", "nk", "dodgers", "litre", "poured", "usefulness", "unsolicited", "binds", "unveiled", "correlations", "burt", "titus", "textual", "suffix", "handsets", "installment", "gandhi", "spindle", "heavens", "inks", "wink", "diarrhea", "seahawks", "mister", "rounding", "inorganic", "flare", "scholastic", "wight", "mondays", "withholding", "insertions", "itk", "kms", "couture", "foliage", "nod", "ocr", "ativan", "fife", "generals", "crank", "goats", "autographs", "summarize", "stub", "fundamentally", "creamy", "exposition", "savesave", "rains", "buckley", "middleton", "laminated", "organise", "citrix", "tort", "brace", "backups", "novelties", "turismo", "gigantic", "abdul", "sheldon", "ryder", "animalsex", "mayhem", "washers", "grep", "xeon", "polymerase", "optimisation", "octave", "struts", "easyshare", "cvsroot", "ud", "suppress", "harding", "dams", "deserved", "violates", "joplin", "dialup", "nx", "thn", "rutherford", "afro", "separates", "proofs", "precedent", "biosynthesis", "prosecutors", "confirming", "garth", "nolan", "alloys", "mach", "getaways", "facilitated", "miquelon", "paolo", "metaphor", "bridget", "wonderland", "infusion", "jessie", "organising", "zine", "conn", "truman", "argus", "jin", "mango", "spur", "jubilee", "landmarks", "polite", "sith", "thigh", "asynchronous", "paving", "cyclone", "perennial", "carla", "jacqueline", "seventeen", "messageslog", "meats", "clearinghouse", "wie", "dwi", "bulldog", "cleavage", "analysed", "uma", "gradual", "brethren", "facilitates", "embodiment", "specialised", "ramones", "everquest", "violating", "recruited", "bernstein", "skis", "calc", "marketers", "toilette", "trailing", "pact", "itc", "lipstick", "honourable", "lulu", "windy", "brennan", "kpx", "punished", "saturation", "stamford", "alamo", "chronology", "mastery", "thermometer", "cranberry", "kan", "downhill", "vita", "comcast", "hyderabad", "steer", "nesting", "vogue", "aired", "attn", "spaghetti", "outward", "whisper", "ipswich", "tues", "boogie", "abramoff", "ean", "fla", "compromised", "utilizes", "confession", "deprived", "benedict", "lesbos", "vodka", "molding", "zaire", "fasteners", "bricks", "communism", "leopard", "sakai", "lk", "flowering", "wig", "jingle", "bounty", "arcadia", "fishes", "ringing", "knobs", "taurus", "rajasthan", "whiskey", "absurd", "committing", "tolerant", "stoves", "inlog", "enactment", "laminate", "earring", "aggregator", "datatype", "embryo", "postnuke", "ska", "nora", "salts", "marietta", "ergonomic", "furious", "dma", "iteration", "vida", "ceilings", "dispenser", "respecting", "sme", "approving", "kp", "unsafe", "refills", "ibis", "yyyy", "separating", "soups", "residing", "unidentified", "atl", "richie", "markings", "ims", "moist", "tractors", "trina", "drained", "vx", "spp", "coed", "audiobooks", "mule", "cummings", "sheikh", "gk", "hernandez", "kiwi", "ohm", "cessation", "truste", "append", "motive", "pests", "acreage", "seasoned", "sunflower", "duel", "mfc", "fingerprint", "bernardino", "stocked", "sorority", "bethel", "entre", "audition", "mca", "plano", "nmr", "sunderland", "doris", "motives", "reinforcement", "dwight", "lortab", "leveraging", "psychotherapy", "provost", "mso", "guessing", "htm", "stokes", "lakers", "ats", "saxophone", "cocktails", "tal", "mead", "harlem", "throttle", "steroid", "gong", "ber", "communicator", "horticulture", "dhs", "resets", "util", "sympathetic", "fridays", "ordinator", "bono", "isolate", "unconscious", "bays", "acronym", "veritas", "faulty", "affidavit", "breathtaking", "streamline", "crowne", "messiah", "brunch", "infamous", "pundit", "pleasing", "seizures", "appealed", "figurine", "surveyors", "mutants", "cyberspace", "tenacious", "expiry", "exif", "waterfall", "sensual", "persecution", "goldman", "petit", "burgess", "msu", "inning", "gaze", "fries", "chlorine", "freshly", "initialize", "tlc", "saxon", "cabo", "rye", "sybase", "isabella", "foundry", "toxicology", "mpls", "monies", "bodybuilding", "fta", "assassination", "nostalgia", "remarkably", "acetate", "pointe", "stall", "pls", "deere", "bmx", "saratoga", "entirety", "destined", "marcel", "terminator", "lad", "hulk", "badminton", "cyan", "ora", "cory", "bal", "flores", "olivier", "portage", "stacey", "serif", "dwellings", "informing", "yellowstone", "portability", "characterize", "ricardo", "yourselves", "fsb", "yearbook", "rotterdam", "lubricants", "cns", "hv", "alameda", "aerosol", "mlm", "clemson", "hostage", "cracker", "anglican", "monks", "compliment", "camino", "storey", "scotch", "sermons", "goin", "philly", "remembers", "coolers", "multilateral", "freddie", "contention", "costello", "audited", "juliet", "adjunct", "guernsey", "galore", "aloha", "dehydrogenase", "bangor", "persia", "aq", "gx", "axes", "postfix", "stirring", "fj", "altavista", "wil", "haze", "pits", "exponential", "utter", "shi", "bottled", "ants", "gev", "gastric", "secretarial", "influencing", "rents", "christy", "theirs", "mattresses", "todays", "donovan", "lax", "toaster", "cater", "colts", "omb", "rehearsal", "strauss", "reputable", "wei", "bac", "tuck", "rei", "slab", "lure", "kart", "ren", "cpl", "sbs", "archbishop", "putin", "questionnaires", "ling", "incompatible", "emblem", "profileprofile", "roadway", "overlapping", "serials", "walters", "dunes", "equivalence", "murders", "vaughn", "aviv", "miserable", "unsuccessful", "condominiums", "decorate", "appleton", "bottoms", "revocation", "vomiting", "chesterfield", "exposing", "pea", "tubs", "simulate", "schematic", "liposuction", "medina", "swf", "apoptosis", "thankful", "pneumatic", "alaskan", "friedrich", "sniper", "vertices", "elephants", "pinch", "additive", "professionalism", "libertarian", "rus", "flynn", "washable", "normalized", "uninstall", "scopes", "fundraiser", "braces", "troll", "calhoun", "teamwork", "deficient", "auditions", "refrigerators", "redirected", "annotations", "middletown", "filth", "moderation", "widgets", "worrying", "ontology", "timberland", "mags", "outrageous", "kraft", "videogames", "concluding", "vallarta", "blackboard", "chopper", "nitrate", "pinball", "pharmacists", "skates", "surcharge", "tbd", "comstock", "hers", "grin", "ipb", "latvian", "asu", "footprint", "installs", "malware", "tunnels", "crises", "trillion", "tsn", "comforter", "cashmere", "heavier", "nguyen", "meteorological", "spit", "labelled", "darker", "salomon", "horsepower", "globes", "algae", "sarbanes", "alcoholism", "dissent", "bdd", "csc", "maximal", "daly", "prenatal", "documenting", "scooby", "choral", "unrestricted", "happenings", "moby", "leicestershire", "neu", "contempt", "socialism", "hem", "leds", "mcbride", "edible", "anarchy", "arden", "clicked", "ineffective", "scorecard", "gln", "beirut", "drawers", "byrne", "conditioners", "acme", "leakage", "culturally", "ilug", "shady", "chemist", "evenly", "janitorial", "reclamation", "rove", "propane", "appendices", "collagen", "lionel", "praised", "rhymes", "blizzard", "erect", "gj", "nigerian", "refining", "concessions", "ect", "commandments", "malone", "confront", "sto", "vests", "lydia", "coyote", "makeover", "breeder", "electrode", "esc", "dragonball", "chow", "stp", "cookbooks", "pollen", "drunken", "mot", "avis", "valet", "spoiler", "cheng", "ari", "avr", "lamborghini", "polarized", "shrubs", "watering", "baroque", "ppt", "barrow", "eliot", "jung", "jihad", "transporting", "sharepoint", "rifles", "cts", "abit", "posterior", "aria", "elgin", "excise", "poetic", "abnormalities", "mortar", "qtr", "blamed", "rae", "recommending", "inmate", "dirk", "posture", "thereon", "valleys", "declaring", "blogshares", "motorsport", "septic", "commencing", "armada", "wrench", "thanked", "citroen", "arranging", "thrilled", "gz", "bas", "predicts", "amelia", "palmone", "jonah", "expedited", "discomfort", "curricula", "scar", "indictment", "apology", "wmd", "pms", "raped", "collars", "configurable", "andover", "denon", "sloan", "pudding", "flawed", "cfs", "checkpoint", "rosenberg", "ffi", "plato", "examiners", "salzburg", "iriver", "rot", "callaway", "tcm", "possesses", "dorm", "squared", "needless", "pies", "lakeside", "marquette", "palma", "barnett", "interconnection", "gilmore", "prc", "ther", "heterogeneous", "taxis", "hates", "aspirations", "gamefaqs", "fences", "excavation", "cookers", "luckily", "ultraviolet", "rutland", "lighted", "pneumonia", "monastery", "afc", "erected", "expresses", "haitian", "dialing", "migrate", "unicef", "carton", "lorraine", "councillors", "identifiers", "hague", "mentors", "transforms", "ammonia", "steiner", "licensure", "roxy", "outlaw", "tammy", "saws", "bovine", "tz", "dislike", "systematically", "ogden", "interruption", "demi", "imminent", "madam", "tights", "compelled", "criticized", "hypertext", "dcs", "soybean", "electra", "affirmed", "posix", "communal", "landlords", "brewers", "emu", "libby", "seite", "dynamite", "tease", "motley", "mci", "aroma", "pierced", "translates", "mais", "retractable", "cognition", "quickbooks", "cain", "townhouse", "verona", "stormwater", "syn", "sgi", "delegated", "coco", "chatting", "punish", "fishermen", "pipelines", "conforming", "causal", "rudy", "stringent", "rowan", "tia", "assigning", "dwell", "hacked", "inaugural", "awkward", "congrats", "msds", "weaving", "metropolis", "arafat", "srl", "psychologists", "diligence", "stair", "splitter", "dine", "wai", "standardization", "enforcing", "lakeland", "thiscategory", "classy", "struggled", "lookout", "arterial", "injustice", "mystical", "acxiom", "triathlon", "ironing", "kbytes", "thx", "commanded", "woodlands", "guardians", "manifesto", "slap", "jaws", "textured", "finn", "doppler", "pedestal", "entropy", "widening", "snooker", "unleashed", "underwood", "saline", "sonny", "longevity", "paw", "lux", "isabel", "nairobi", "sterile", "importer", "isl", "orioles", "botany", "dissolution", "rotor", "pauline", "quart", "theres", "bison", "suppressed", "allegro", "materially", "cit", "amor", "xvi", "fungi", "phyllis", "ttl", "dreamy", "bengal", "backstage", "scrolls", "awakening", "qq", "fairies", "prescribe", "lubbock", "greed", "nominate", "sparkle", "autograph", "suvs", "bmp", "migrating", "gasket", "refrain", "lastly", "overcoming", "wander", "kona", "relieved", "firearm", "dss", "luc", "elena", "bam", "closures", "participatory", "intermittent", "ante", "micron", "budgetary", "pcos", "vols", "revolving", "ssk", "bundled", "pantie", "bombers", "covert", "crater", "leah", "favored", "bred", "spongebob", "fractional", "markus", "ideological", "fostering", "wellbutrin", "rheumatoid", "thence", "birthplace", "bleed", "reverend", "transmitting", "swindon", "cabernet", "serie", "sek", "neptune", "dsm", "caucasian", "understandable", "shea", "goblet", "doctorate", "binaries", "inventions", "dea", "slovenian", "practicable", "showdown", "simone", "fronts", "ancestor", "russians", "spc", "potentials", "incur", "tempe", "hklm", "cores", "borrowers", "osx", "canonical", "nodded", "confronted", "believer", "bouvet", "multifunction", "australians", "nifty", "declines", "unveils", "peacock", "utmost", "skeletal", "dems", "oahu", "yates", "leroy", "rollover", "infos", "helpers", "lds", "elapsed", "thanx", "anthrax", "academies", "tout", "shockwave", "gre", "imitation", "harvested", "dab", "hopeful", "furnishing", "negatively", "westlife", "residences", "spinach", "bpm", "liquidation", "predecessor", "tamiflu", "cheeks", "hare", "beasts", "touchdown", "planar", "philanthropy", "adequacy", "iomega", "xa", "fetisch", "peanuts", "discovers", "eastman", "franchising", "coppermine", "discard", "cavalry", "ged", "breakers", "quorum", "forwards", "ecard", "prevalent", "plat", "exploits", "ue", "kn", "dukes", "offended", "trimmed", "py", "ferries", "worcestershire", "faqfaq", "bonn", "muller", "prostitution", "mosque", "fudge", "extractor", "horseback", "vested", "terribly", "earnest", "usergroupsusergroups", "svenska", "pcg", "myocardial", "homme", "clancy", "everytime", "callback", "tory", "encompasses", "rossi", "sander", "oldham", "gonzales", "conductivity", "vor", "confederate", "presumed", "annette", "climax", "blending", "atc", "weave", "vicki", "postponed", "danville", "philosophers", "speeding", "creditor", "exits", "pardon", "sedona", "oder", "skateboarding", "lexisnexis", "abby", "deepthroat", "outback", "teller", "mandates", "siena", "reiki", "biopsy", "peptides", "veil", "peck", "custodian", "dante", "lange", "quarry", "seneca", "oceanic", "tres", "helm", "burbank", "festive", "rosen", "awakenings", "pim", "alla", "preserves", "sediments", "appraiser", "smp", "ingram", "gaussian", "hustler", "jess", "tensions", "secretion", "linkages", "separator", "insult", "scraps", "waived", "cured", "schultz", "buggy", "adr", "concordia", "recon", "kennel", "drilled", "fileplanet", "souvenirs", "royals", "prescribing", "slack", "globalisation", "borland", "pastel", "gin", "nottinghamshire", "differentiate", "strollers", "jays", "uninsured", "picasso", "pilgrim", "vines", "susceptibility", "ambiguous", "mcgill", "disputed", "scouting", "royale", "instinct", "gorge", "righteousness", "carrot", "discriminatory", "opaque", "headquartered", "bullying", "saul", "flaming", "travelodge", "empower", "apis", "marian", "liens", "caterpillar", "hurley", "remington", "pedals", "chew", "teak", "benefited", "prevail", "bitmap", "migraine", "musik", "sli", "undermine", "enum", "omission", "boyle", "lamar", "mio", "diminished", "jonas", "aes", "locke", "cages", "methane", "pager", "snp", "jolla", "aclu", "capitals", "correctness", "westchester", "implication", "pap", "banjo", "shaker", "natives", "tive", "nimh", "quilting", "campgrounds", "adm", "stout", "rewarded", "densities", "isd", "athena", "deepest", "matthias", "tional", "duane", "sane", "turnaround", "climbed", "corrupted", "relays", "navigational", "stargate", "hanna", "husbands", "saskatoon", "cen", "fading", "colchester", "minh", "fingertips", "sba", "rockwell", "persuade", "vl", "pepsi", "rea", "roaming", "oversized", "snr", "sibling", "ecs", "determinations", "burberry", "weighed", "ashamed", "concierge", "nrs", "gorilla", "gatherings", "endure", "cfa", "inhibit", "nom", "pps", "cheltenham", "screenplay", "unabridged", "dickens", "ntp", "endpoint", "juniper", "repetition", "labelling", "siberian", "synchronous", "heartland", "preparatory", "cafeteria", "outfitters", "fielding", "dune", "hee", "adler", "opp", "homelessness", "yosemite", "cursed", "opengl", "efficiencies", "blowout", "youths", "tickboxes", "migrants", "massey", "tumble", "oversee", "thresholds", "stare", "unlocking", "missy", "isnt", "waveform", "deficits", "meade", "contradiction", "flair", "helium", "applegate", "wonderfully", "whitewater", "tableware", "bernie", "dug", "workgroup", "congenital", "trojans", "insanity", "clement", "embraced", "cli", "finely", "authenticated", "reformed", "tolerate", "robotic", "mana", "lest", "adhesion", "tic", "mississauga", "dialysis", "filmed", "staten", "carole", "noticeable", "cette", "aesthetics", "schwarzenegger", "smoker", "benign", "hypotheses", "afforded", "aisle", "dunno", "blur", "evidently", "summarizes", "limbs", "unforgettable", "punt", "sludge", "crypto", "christensen", "tanned", "altering", "bunker", "multiplication", "paved", "heavyweight", "lps", "fabricated", "zach", "pdp", "pasture", "phantomnode", "richest", "cruelty", "comptroller", "scalability", "creatine", "mormon", "embl", "minimizing", "scots", "genuinely", "gpo", "neighbouring", "plugged", "tyson", "souvenir", "dq", "mifflin", "relativity", "mojo", "econo", "cucumber", "occurrences", "shapiro", "marshal", "rituals", "anders", "seize", "decisive", "spawn", "pq", "blanks", "ub", "dungeons", "epoxy", "watercolor", "uncensored", "sailors", "stony", "fayette", "trainees", "tori", "shelving", "effluent", "infousa", "annals", "storytelling", "sadness", "periodical", "polarization", "moe", "dime", "losers", "bombings", "punta", "flavour", "smes", "ionamin", "fuckin", "crypt", "charlottesville", "accomplishment", "xu", "onwards", "bogus", "carp", "aniston", "prompts", "witches", "barred", "skinner", "equities", "dusk", "nouveau", "customary", "vertically", "crashing", "cautious", "possessions", "feeders", "urging", "jboss", "passions", "faded", "mobil", "scrolling", "counterpart", "utensils", "secretly", "tying", "lent", "diode", "kaufman", "magician", "indulgence", "aloe", "johan", "buckinghamshire", "melted", "lund", "medford", "fam", "nel", "extremes", "puff", "underlined", "whores", "galileo", "bloomfield", "obsessed", "flavored", "gemstones", "bmi", "viewpoints", "groceries", "motto", "exim", "singled", "alton", "appalachian", "staple", "dealings", "phillies", "pathetic", "ramblings", "janis", "craftsman", "irritation", "rulers", "centric", "collisions", "militia", "optionally", "eis", "conservatory", "nightclub", "bananas", "geophysical", "fictional", "adherence", "golfing", "defended", "rubin", "handlers", "grille", "elisabeth", "claw", "pushes", "alain", "flagship", "kittens", "topeka", "openoffice", "illegally", "bugzilla", "deter", "tyre", "furry", "cubes", "transcribed", "bouncing", "wand", "linus", "taco", "mcsg", "humboldt", "scarves", "cavalier", "ish", "rinse", "outfits", "mla", "charlton", "repertoire", "respectfully", "emeritus", "ulster", "macroeconomic", "tides", "chu", "weld", "venom", "gundam", "adaptec", "writ", "patagonia", "dispensing", "tailed", "puppets", "voyer", "tapping", "hostname", "excl", "bx", "arr", "typo", "immersion", "explode", "toulouse", "escapes", "berries", "merchantability", "happier", "autodesk", "mummy", "jn", "punjab", "stacked", "winged", "brighter", "cries", "speciality", "warranted", "attacker", "ruined", "catcher", "damp", "sanity", "ether", "suction", "haynes", "crusade", "siyabona", "rumble", "inverter", "correcting", "shattered", "abi", "heroic", "motivate", "retreats", "mackay", "formulate", "bridgeport", "assessor", "fullerton", "cpp", "sheds", "blockbuster", "dz", "amarillo", "pixmania", "pathfinder", "anomalies", "homogeneous", "bonsai", "windshield", "humphrey", "spheres", "belonged", "tomtom", "spf", "assigns", "croydon", "sofas", "croix", "cushions", "fern", "convection", "jdbc", "defenders", "debugger", "boing", "odessa", "lore", "ancillary", "pointless", "whipped", "vox", "alibris", "dinners", "rosie", "factoring", "genealogical", "gyms", "inhalation", "terre", "selfish", "eventual", "faucet", "nach", "mitigate", "bitpipe", "jamestown", "arguably", "techs", "electives", "walkman", "midget", "elisa", "shelton", "quan", "boiled", "commissioning", "neville", "experimentation", "saltwater", "natasha", "cpi", "endeavour", "roswell", "haute", "herring", "nis", "unfamiliar", "wacky", "expectancy", "deterioration", "sgml", "proclaimed", "arid", "anemia", "biting", "coincidence", "idiots", "mona", "reits", "muddy", "nuevo", "savanna", "crn", "hitchcock", "cid", "travestis", "neighbour", "mmf", "raspberry", "cancellations", "paging", "coe", "nudists", "illusions", "fac", "spikes", "asean", "airsoft", "bontril", "enumeration", "proliant", "keeling", "zh", "accesses", "suche", "permissible", "yielded", "nuisance", "jive", "siam", "latent", "marcia", "drowning", "bullshit", "casper", "spun", "shalt", "libstdc", "ric", "loch", "commanding", "sparrow", "poorest", "hector", "xpress", "datasets", "webdesign", "nicotine", "comeback", "brotherhood", "gannett", "milling", "sinking", "sulphur", "curricular", "downtime", "takeover", "wicker", "lolitas", "balm", "thessalonians", "figs", "upto", "browne", "nephew", "confess", "joaquin", "chit", "chaotic", "alexandre", "lays", "principally", "visor", "mundo", "transistor", "jarvis", "drip", "traced", "outright", "melodies", "spotting", "myriad", "stains", "sandal", "rubbing", "naive", "wien", "skeptical", "wagering", "remembrance", "detects", "everest", "disregard", "hanger", "outkast", "dragged", "pitbull", "foreman", "rtf", "allegiance", "fairview", "hires", "conduit", "alienware", "dependable", "mainframe", "echoes", "indo", "compilers", "ladders", "prudent", "glowing", "guinness", "heartbeat", "blazer", "alchemy", "linden", "timezone", "merck", "sven", "tanya", "geographically", "bmc", "alternating", "tristan", "audible", "folio", "eia", "presiding", "mans", "colleen", "bbbonline", "participates", "waterways", "syndicated", "lexicon", "aff", "fractures", "apprenticeship", "childbirth", "dumped", "integers", "zirconia", "barre", "shortages", "plumbers", "rama", "johannes", "fiery", "convex", "jfk", "raf", "richer", "igor", "hama", "mop", "urn", "soleil", "patton", "pei", "surfer", "diapers", "eas", "waco", "physiol", "connor", "adp", "northamptonshire", "biscuits", "disclaims", "sich", "outbound", "breakout", "restless", "unanswered", "paired", "fakes", "stderr", "kev", "fomit", "vaults", "injections", "ahmad", "remortgage", "yogurt", "complies", "tossed", "caucus", "workaround", "cooke", "polytechnic", "pillars", "katy", "zoe", "uber", "overwhelmed", "salute", "shoppe", "parody", "berlios", "csr", "penthouse", "compensated", "synthase", "lacked", "circulated", "soo", "pistons", "emule", "maltese", "sauvignon", "acorn", "bosses", "pint", "ascension", "bayer", "carrera", "ply", "mornings", "dvb", "cation", "mentioning", "scientology", "cdma", "flagstaff", "maxi", "pretoria", "thrive", "msm", "rac", "feminism", "rightly", "paragon", "basal", "topps", "webinar", "dewalt", "turnout", "bruins", "persist", "wilde", "indispensable", "clamps", "illicit", "firefly", "liar", "tabletop", "pledged", "monoclonal", "pictorial", "curling", "ares", "wholesaler", "smoky", "opus", "typekey", "aromatic", "flirt", "slang", "emporium", "princes", "restricting", "partnering", "promoters", "soothing", "freshmen", "mage", "departed", "sqrt", "aristotle", "israelis", "finch", "inherently", "cdp", "krishna", "forefront", "headlights", "monophonic", "largo", "proquest", "amazingly", "plural", "dominic", "sergio", "swapping", "skipped", "hereinafter", "nur", "extracting", "analogous", "mev", "hebrews", "particulate", "tally", "unpleasant", "uno", "tempted", "bedfordshire", "blindness", "creep", "staining", "rockport", "nist", "shaded", "cot", "plaster", "novo", "negotiable", "subcategories", "hearted", "quarterback", "obstruction", "agility", "complying", "sudbury", "otis", "overture", "newcomers", "hectares", "upscale", "scrabble", "noteworthy", "agile", "sdn", "mta", "sacks", "docbook", "kiosk", "ionic", "stray", "runaway", "slowing", "firstgov", "hoodie", "hoodia", "payout", "clinically", "watchers", "supplemented", "poppy", "monmouth", "metacritic", "obligated", "frenzy", "decoding", "jargon", "kangaroo", "sleeper", "elemental", "presenters", "teal", "unnamed", "epstein", "doncaster", "particulars", "jerking", "weblogic", "ity", "bungalow", "covington", "bazaar", "esd", "interconnect", "predicate", "recurrence", "chinatown", "mindless", "purifier", "recruits", "sharper", "kz", "tablespoons", "greedy", "rodgers", "gloryhole", "supervise", "termed", "frauen", "suppl", "stamping", "coolest", "reilly", "hotjobs", "downing", "gnd", "libc", "basque", "societal", "astros", "ire", "halogen", "pegasus", "silhouette", "wyndham", "osu", "tuesdays", "dorado", "daring", "realms", "maestro", "turin", "gus", "utp", "superpages", "forte", "coaxial", "tipping", "jpy", "holster", "fiddle", "crunch", "leipzig", "liam", "sesso", "bard", "kellogg", "arabidopsis", "reap", "argv", "hanoi", "ccm", "faucets", "ballistic", "exemplary", "payouts", "rockin", "caliber", "apostle", "playful", "supermarkets", "bmg", "icelandic", "multiplied", "enchanted", "belgrade", "styled", "nacional", "commanders", "csv", "telstra", "thor", "waive", "contraception", "bethany", "polaroid", "vance", "soprano", "polishing", "marquis", "underage", "cardio", "wen", "translating", "frontiers", "timeshares", "atk", "qi", "logger", "adjoining", "greet", "acclaim", "kool", "oki", "birding", "hardship", "detainees", "hast", "indi", "lymph", "barrie", "pollutant", "closeouts", "miriam", "cavaliers", "rollers", "carleton", "pumped", "tolkien", "differentiated", "sonia", "undp", "verifying", "jbl", "almighty", "weekday", "homecoming", "increments", "kurdish", "vel", "intuition", "revoked", "openness", "chromium", "circulating", "bryce", "ilo", "latch", "mccormick", "verbs", "drank", "pcm", "confrontation", "shreveport", "grower", "frederic", "darlington", "slippery", "unpredictable", "galerie", "dtd", "capacitor", "outpost", "burnett", "hilfiger", "mda", "litres", "moroccan", "seville", "mira", "nightwish", "chatter", "hess", "wheaton", "santo", "lettuce", "raging", "tidy", "motorized", "jong", "subgroup", "oppression", "chevelle", "vets", "bows", "yielding", "assays", "torso", "occult", "expeditions", "nok", "hooker", "ramon", "longhorn", "lorenzo", "beau", "backdrop", "subordinate", "lilies", "aerobic", "articulate", "vgroup", "ecstasy", "sweetheart", "fulfil", "calcutta", "thursdays", "dansk", "tenerife", "hobbs", "mayen", "mediator", "oldmedline", "dunlop", "caa", "tad", "modernization", "xe", "cultivated", "rang", "disconnected", "consulate", "fourier", "businessman", "watersports", "lucent", "wilkes", "commuter", "orthopedic", "disagreement", "hhs", "strands", "tyrosine", "sicily", "compost", "shenzhen", "adjourned", "familiarity", "initiating", "erroneous", "grabs", "erickson", "marlin", "pulses", "theses", "stuffing", "casserole", "canoeing", "cca", "jeux", "wilton", "ophthalmology", "flooded", "geile", "clubhouse", "reverted", "crackers", "greyhound", "corsair", "ironic", "licensees", "wards", "unsupported", "evaluates", "hinge", "svg", "ultima", "cockpit", "protesters", "fernandez", "venetian", "mvc", "sleazydream", "patti", "mz", "sew", "carrots", "faire", "laps", "memorials", "sennheiser", "resumed", "sheehan", "conversely", "emory", "stunt", "maven", "excuses", "commute", "staged", "vitae", "transgender", "hustle", "stimuli", "customizing", "subroutine", "upwards", "witty", "pong", "transcend", "loosely", "anchors", "hun", "hertz", "atheist", "capped", "oro", "myr", "bridgewater", "firefighter", "liking", "preacher", "propulsion", "complied", "intangible", "westfield", "compassionate", "catastrophic", "fuckers", "blower", "substitutes", "tata", "flown", "frau", "dubbed", "silky", "giclee", "groovy", "vows", "reusable", "macy", "actuarial", "distorted", "nathaniel", "attracts", "bern", "qualifies", "grizzly", "helpline", "micah", "erectile", "timeliness", "obstetrics", "chaired", "agri", "repay", "hurting", "homicide", "prognosis", "colombian", "pandemic", "await", "mpc", "fob", "sparse", "corridors", "sont", "mcdowell", "fossils", "victories", "dimage", "chemically", "fetus", "determinants", "compliments", "durango", "cider", "noncommercial", "opteron", "crooked", "gangs", "segregation", "superannuation", "nemo", "ifs", "overcast", "inverted", "lenny", "achieves", "haas", "wimbledon", "documentaries", "mpa", "rao", "remake", "arp", "braille", "forehead", "physiopathology", "skye", "seperate", "econpapers", "arxiv", "pax", "kalamazoo", "taj", "percy", "scratches", "conan", "lilac", "sinus", "maverick", "intellect", "charmed", "denny", "harman", "hears", "wilhelm", "nationalism", "pervasive", "auch", "enfield", "anabolic", "nie", "allegra", "lexar", "clears", "videotape", "educ", "knowingly", "pivot", "amplification", "larsen", "huron", "snippets", "undergraduates", "conserv", "digestion", "dustin", "wsop", "mixtures", "composites", "wolverhampton", "soaring", "dragging", "virtues", "banning", "flushing", "deprivation", "cpt", "delights", "gauteng", "foreword", "glide", "transverse", "ftc", "watertown", "pathogens", "engagements", "mft", "withstand", "uefa", "newbury", "authorizes", "blooms", "soar", "jacking", "radiohead", "uniformly", "ooh", "subsections", "todos", "definately", "bod", "piedmont", "yin", "tiki", "empowered", "homepages", "asi", "lena", "outlying", "slogan", "subdivisions", "handouts", "deducted", "ezekiel", "totaling", "elijah", "cpm", "marvelous", "bop", "asnblock", "compton", "stretches", "vigorous", "biloxi", "flee", "biscuit", "creme", "submits", "woes", "waltz", "menace", "emerges", "classify", "paige", "downstairs", "statesman", "indymedia", "clapton", "cheerful", "blush", "beyonce", "smf", "leaflet", "monde", "weymouth", "nabble", "spherical", "intracellular", "infoworld", "favourable", "informs", "boyz", "dramas", "cher", "waltham", "geisha", "billiard", "aut", "dblp", "briefcase", "malay", "unseen", "mcmahon", "optimism", "cq", "silica", "kara", "mcgregor", "modal", "marlboro", "grafton", "unusually", "phishing", "addendum", "widest", "foia", "impotence", "medley", "cadet", "redskins", "kirsten", "temper", "yorker", "memberlistmemberlist", "gam", "intravenous", "ashcroft", "asserts", "loren", "stew", "newsfeed", "hereafter", "carbs", "retiring", "smashing", "yakima", "accumulate", "realtones", "xtc", "vdata", "interpro", "tahiti", "engadget", "tracey", "wac", "mariner", "collier", "hush", "darfur", "fragmentation", "behavioural", "kiev", "paranormal", "whispered", "generosity", "vibrating", "glossaries", "sonyericsson", "lama", "artisan", "akin", "raphael", "dex", "lola", "embarrassing", "emoticons", "carbohydrates", "aqueous", "pembroke", "hms", "norwood", "appetizers", "stockholders", "webmin", "lillian", "stylesheet", "goldstein", "splinter", "ibn", "wnba", "preferable", "englewood", "juices", "ironically", "morale", "morales", "solder", "trench", "asf", "persuasion", "hottie", "stripper", "practise", "pfc", "adrenaline", "mammalian", "opted", "lodged", "revolt", "meteorology", "analyzes", "renders", "pioneering", "pristine", "francaise", "ctx", "shines", "catalan", "spreadsheets", "regain", "resize", "auditory", "applause", "medically", "tweak", "mmm", "trait", "popped", "busted", "alicante", "basins", "farmhouse", "pounding", "picturesque", "ottoman", "graders", "shrek", "eater", "universidad", "tuners", "utopia", "slider", "insists", "cymru", "fprintf", "willard", "irq", "lettering", "dads", "marlborough", "sdl", "ebusiness", "pouring", "hays", "cyrus", "concentrating", "soak", "buckingham", "courtroom", "hides", "goodwin", "manure", "savior", "dade", "secrecy", "wesleyan", "baht", "duplicated", "dreamed", "relocating", "fertile", "hinges", "plausible", "creepy", "synth", "filthy", "subchapter", "ttf", "narrator", "optimizations", "infocus", "bellsouth", "sweeney", "augustus", "aca", "fpo", "fahrenheit", "hillside", "standpoint", "layup", "laundering", "nationalist", "piazza", "fre", "denoted", "nazis", "cumfiesta", "oneself", "royalties", "newbies", "mds", "piles", "abbreviation", "vaginas", "blanco", "critiques", "stroll", "anomaly", "thighs", "boa", "expressive", "infect", "bezel", "avatars", "pers", "twiztid", "dotted", "frontal", "havoc", "ubiquitous", "arsenic", "synonym", "facilitation", "ncr", "xb", "voc", "yer", "rts", "doomed", "applets", "francs", "ballad", "pdfs", "sling", "contraction", "cac", "devised", "teh", "explorers", "billie", "undercover", "substrates", "evansville", "joystick", "knowledgebase", "forrester", "ravens", "xoops", "rican", "underline", "obscene", "uptime", "dooyoo", "spammers", "mes", "hymn", "continual", "nuclei", "gupta", "tummy", "axial", "slowed", "aladdin", "tolerated", "quay", "aest", "outing", "instruct", "wilcox", "topographic", "westport", "overhaul", "majordomo", "peruvian", "indemnity", "lev", "imaginative", "weir", "wednesdays", "burgers", "rai", "remarked", "portrayed", "watchlist", "clarendon", "campers", "phenotype", "countrywide", "ferris", "julio", "affirm", "directx", "spelled", "epoch", "mourning", "resistor", "phelps", "aft", "bhd", "plaid", "audubon", "fable", "rescued", "commentsblog", "snowmobile", "exploded", "publ", "cpg", "padres", "scars", "whisky", "tes", "uptown", "susie", "subparagraph", "batter", "weighting", "reyes", "rectal", "vivian", "nuggets", "silently", "pesos", "shakes", "dram", "mckinney", "impartial", "hershey", "embryos", "punctuation", "initials", "spans", "pallet", "pistols", "mara", "garages", "sds", "tanner", "avenues", "urology", "dun", "aforementioned", "rihanna", "tackling", "obese", "compress", "apostles", "melvin", "sober", "collaborations", "tread", "legitimacy", "zoology", "steals", "unwilling", "lis", "isolates", "velcro", "worksheets", "avaya", "srs", "wigan", "hua", "abba", "qd", "orig", "paddy", "huskies", "frey", "iz", "loyola", "plunge", "pearce", "gartner", "vos", "sinister", "xda", "burr", "arteries", "strapon", "chaser", "formations", "vantage", "texans", "diffuse", "boredom", "norma", "astra", "expasy", "crosse", "overdrive", "mondo", "ripley", "phosphorylation", "helpless", "cfo", "depletion", "neonatal", "qr", "mclaren", "wyatt", "rowling", "vhf", "flatbed", "spades", "slug", "visionary", "coffin", "otter", "golfers", "lira", "navajo", "earns", "amplified", "recess", "dispersed", "technics", "shouted", "damien", "clippers", "shilling", "resemble", "spirited", "gv", "carbonate", "mimi", "staa", "discriminate", "stared", "recharge", "crocodile", "openid", "sassy", "demux", "ratification", "ribosomal", "tdk", "vases", "filmmakers", "transnational", "advises", "sind", "coward", "paralegal", "spokesperson", "fha", "teamed", "preset", "inequalities", "iptables", "pocketpc", "garde", "nox", "jams", "pancreatic", "tran", "manicures", "dyes", "sca", "tls", "prweb", "holloway", "viz", "turbulence", "cdrw", "yell", "fins", "plz", "nadu", "ritchie", "underwriting", "dresser", "rulemaking", "rake", "valentino", "ornamental", "riches", "resign", "prolyte", "millenium", "collectable", "stephan", "aries", "ramps", "tackles", "injunction", "intervene", "poised", "dsa", "barking", "walden", "josephine", "dread", "dag", "catchment", "targus", "tactic", "ess", "partitioning", "voicemail", "acct", "handwriting", "shimano", "serpent", "lingere", "tapped", "articulated", "pitched", "parentheses", "contextual", "qwest", "jira", "cerevisiae", "wisely", "accustomed", "bremen", "steaks", "dyson", "playhouse", "superficial", "toxins", "camaro", "suns", "josef", "casts", "bunk", "cryptography", "stab", "sanction", "dyer", "effected", "signalling", "daycare", "murakami", "tubular", "merriam", "moi", "ode", "scorpio", "attr", "avoids", "richter", "emp", "ultrasonic", "evidenced", "heinz", "argos", "dit", "larvae", "dyke", "ashford", "intergovernmental", "cassidy", "paranoid", "kernels", "mobilization", "dino", "xvid", "dmoz", "amt", "ivtools", "barron", "wilkins", "snorkeling", "chilean", "avs", "suny", "gifs", "qualifier", "manipulated", "hannover", "alleviate", "fungal", "ligand", "seam", "aust", "peoplesoft", "freelists", "riddle", "coastline", "comedies", "fainter", "omit", "respectful", "flamingo", "cabaret", "deformation", "orf", "recession", "pfizer", "assembler", "awaited", "renovations", "nozzle", "externally", "needy", "genbank", "broadcasters", "employability", "wheeled", "booksellers", "noodles", "darn", "diners", "greeks", "retardation", "supervising", "freeport", "lyme", "corning", "prov", "reich", "dishnetwork", "armored", "amg", "weary", "solitary", "claremont", "moo", "photographed", "tweed", "snowy", "pianist", "emmanuel", "acapulco", "surrounds", "knocking", "cosmopolitan", "magistrate", "everlasting", "cpe", "childs", "pigment", "faction", "tous", "bizkit", "argentine", "blogosphere", "endocrine", "scandinavia", "minnie", "resp", "genie", "carlsbad", "ammo", "bling", "chars", "linn", "mcguire", "utilisation", "rulings", "sst", "handel", "geophysics", "microscopic", "clarified", "coherence", "slater", "broccoli", "foreach", "oakwood", "sensations", "orphan", "conferred", "mcgee", "kissimmee", "acp", "disturbances", "chandelier", "linker", "embryonic", "tetris", "carver", "paterson", "tds", "delle", "graceful", "synchronized", "intercept", "hsbc", "shellfish", "shouts", "ascertain", "astoria", "veto", "trajectory", "epsilon", "exhaustive", "annoyed", "bureaucracy", "knowles", "astrophysics", "paz", "stalls", "fined", "bien", "hansard", "inward", "reflector", "greeted", "lai", "hartley", "defenses", "meaningless", "authorisation", "clam", "vampires", "relocate", "nerd", "francesco", "hes", "georg", "dac", "negligible", "starch", "melinda", "godfather", "apron", "glazing", "guts", "ros", "pragmatic", "tyranny", "provisioning", "warehouses", "mnt", "regimen", "axel", "expandable", "antony", "hahn", "maserati", "fluffy", "marianne", "slender", "hereford", "bender", "reliably", "aides", "forma", "fas", "sendo", "absorbing", "cherries", "hasbro", "gaelic", "gomez", "alec", "corba", "polski", "distinguishing", "multidisciplinary", "ventricular", "glazed", "judd", "dashed", "petersen", "libyan", "dickson", "distressed", "bans", "macquarie", "shouting", "pta", "poy", "mao", "bullock", "villagers", "transferable", "yummy", "acknowledgments", "ethiopian", "momma", "lehigh", "mermaid", "buds", "concordance", "greenberg", "trish", "sexes", "wilder", "sire", "centred", "confinement", "islanders", "ding", "uncover", "contested", "coma", "husky", "conserve", "bland", "electrodes", "svcd", "cron", "darth", "abatement", "cramer", "yup", "originator", "ching", "whipping", "skipping", "melanoma", "thug", "routed", "rudolph", "abigail", "missionaries", "yugoslav", "householder", "occ", "cpan", "plotting", "yan", "succeeding", "bizjournalshire"];

    /* srcReviving\EnterForm\EnterForm.svelte generated by Svelte v3.59.2 */

    const { console: console_1$5 } = globals;
    const file$e = "srcReviving\\EnterForm\\EnterForm.svelte";

    function create_fragment$g(ctx) {
    	let div1;
    	let div0;
    	let t0_value = /*sort*/ ctx[0] + 1 + "";
    	let t0;
    	let t1;
    	let input0;
    	let input0_id_value;
    	let t2;
    	let input1;
    	let div1_transition;
    	let current;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			input0 = element("input");
    			t2 = space();
    			input1 = element("input");
    			attr_dev(div0, "class", "tagname svelte-7617bi");
    			add_location(div0, file$e, 67, 0, 1914);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "class", "words svelte-7617bi");
    			attr_dev(input0, "id", input0_id_value = `inputForm${/*sort*/ ctx[0]}`);
    			attr_dev(input0, "spellcheck", "false");
    			attr_dev(input0, "lang", "en");
    			attr_dev(input0, "autocomplete", "off");
    			add_location(input0, file$e, 68, 0, 1953);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "class", "means svelte-7617bi");
    			add_location(input1, file$e, 69, 0, 2139);
    			attr_dev(div1, "class", "containTitleName svelte-7617bi");
    			add_location(div1, file$e, 66, 0, 1846);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, t0);
    			append_dev(div1, t1);
    			append_dev(div1, input0);
    			append_dev(div1, t2);
    			append_dev(div1, input1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input_handler*/ ctx[4], false, false, false, false),
    					listen_dev(input0, "click", /*ClickChose*/ ctx[2], false, false, false, false),
    					listen_dev(input0, "blur", /*Blur*/ ctx[3], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*sort*/ 1) && t0_value !== (t0_value = /*sort*/ ctx[0] + 1 + "")) set_data_dev(t0, t0_value);

    			if (!current || dirty & /*sort*/ 1 && input0_id_value !== (input0_id_value = `inputForm${/*sort*/ ctx[0]}`)) {
    				attr_dev(input0, "id", input0_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!current) return;
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 500 }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, slide, { duration: 500 }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $suggestTF;
    	let $listwordSug;
    	let $formchosedNum;
    	let $suggestUpdate;
    	let $endInput;
    	let $startInput;
    	let $resMean;
    	let $resWord;
    	validate_store(suggestTF, 'suggestTF');
    	component_subscribe($$self, suggestTF, $$value => $$invalidate(5, $suggestTF = $$value));
    	validate_store(listwordSug, 'listwordSug');
    	component_subscribe($$self, listwordSug, $$value => $$invalidate(6, $listwordSug = $$value));
    	validate_store(formchosedNum, 'formchosedNum');
    	component_subscribe($$self, formchosedNum, $$value => $$invalidate(7, $formchosedNum = $$value));
    	validate_store(suggestUpdate, 'suggestUpdate');
    	component_subscribe($$self, suggestUpdate, $$value => $$invalidate(8, $suggestUpdate = $$value));
    	validate_store(endInput, 'endInput');
    	component_subscribe($$self, endInput, $$value => $$invalidate(9, $endInput = $$value));
    	validate_store(startInput, 'startInput');
    	component_subscribe($$self, startInput, $$value => $$invalidate(10, $startInput = $$value));
    	validate_store(resMean, 'resMean');
    	component_subscribe($$self, resMean, $$value => $$invalidate(11, $resMean = $$value));
    	validate_store(resWord, 'resWord');
    	component_subscribe($$self, resWord, $$value => $$invalidate(12, $resWord = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EnterForm', slots, []);
    	let { sort } = $$props;

    	onMount(() => {
    		document.getElementsByClassName("words")[sort].value = $resWord[sort];
    		document.getElementsByClassName("means")[sort].value = $resMean[sort];
    	});

    	function TestInput(event) {
    		let input = event.target;
    		let cursorPosition = input.selectionStart;
    		let text = input.value;
    		let startIndex = cursorPosition;
    		let endIndex = cursorPosition;

    		// Find the start of the word
    		while (startIndex > 0 && text[startIndex - 1] !== ' ') {
    			startIndex--;
    		}

    		// Find the end of the word
    		while (endIndex < text.length && text[endIndex] !== ' ') {
    			endIndex++;
    		}

    		set_store_value(startInput, $startInput = startIndex, $startInput);
    		set_store_value(endInput, $endInput = endIndex, $endInput);
    		let fiword = text.substring(startIndex, endIndex);

    		if (fiword[0] != " ") {
    			let finalList = wordlist.filter(word => word.startsWith(fiword)).slice(0, 5);
    			set_store_value(listwordSug, $listwordSug = finalList, $listwordSug);
    			set_store_value(suggestTF, $suggestTF = true, $suggestTF);
    			set_store_value(suggestUpdate, $suggestUpdate = !$suggestUpdate, $suggestUpdate);
    			console.log(finalList);
    		}
    	} /*


    let matches = findBestMatch(word, wordlist);
    console.log(matches)
    let topMatches = matches.ratings
      .sort((a, b) => b.rating - a.rating) // Sort the matches by rating in descending order
      .slice(0, 10) // Take the top 10 matches

    let similarWords = topMatches.map(match => match.target);

    console.log(similarWords);
      */

    	function ClickChose() {
    		set_store_value(suggestTF, $suggestTF = true, $suggestTF);
    		set_store_value(formchosedNum, $formchosedNum = sort, $formchosedNum);
    		set_store_value(listwordSug, $listwordSug = [], $listwordSug);
    	}

    	function Blur() {
    		setTimeout(
    			() => {
    				set_store_value(suggestTF, $suggestTF = false, $suggestTF);
    			},
    			100
    		);
    	}

    	$$self.$$.on_mount.push(function () {
    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console_1$5.warn("<EnterForm> was created without expected prop 'sort'");
    		}
    	});

    	const writable_props = ['sort'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$5.warn(`<EnterForm> was created with unknown prop '${key}'`);
    	});

    	const input_handler = () => {
    		TestInput(event);
    	};

    	$$self.$$set = $$props => {
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		endInput,
    		formchosedNum,
    		listwordSug,
    		resMean,
    		resWord,
    		startInput,
    		suggestTF,
    		suggestUpdate,
    		wordlist,
    		slide,
    		sort,
    		TestInput,
    		ClickChose,
    		Blur,
    		$suggestTF,
    		$listwordSug,
    		$formchosedNum,
    		$suggestUpdate,
    		$endInput,
    		$startInput,
    		$resMean,
    		$resWord
    	});

    	$$self.$inject_state = $$props => {
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sort, TestInput, ClickChose, Blur, input_handler];
    }

    class EnterForm extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { sort: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EnterForm",
    			options,
    			id: create_fragment$g.name
    		});
    	}

    	get sort() {
    		throw new Error("<EnterForm>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<EnterForm>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcReviving\MainArea\EnterBoard.svelte generated by Svelte v3.59.2 */
    const file$d = "srcReviving\\MainArea\\EnterBoard.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	child_ctx[3] = i;
    	return child_ctx;
    }

    // (13:4) {#each $LisEnter as ele,i}
    function create_each_block$4(ctx) {
    	let enterform;
    	let current;

    	enterform = new EnterForm({
    			props: { sort: /*i*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(enterform.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(enterform, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(enterform.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(enterform.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(enterform, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(13:4) {#each $LisEnter as ele,i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$f(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let current;
    	let each_value = /*$LisEnter*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "words/clauses";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "meanings";
    			t3 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "title svelte-1cctzi7");
    			add_location(div0, file$d, 7, 8, 194);
    			attr_dev(div1, "class", "title svelte-1cctzi7");
    			add_location(div1, file$d, 9, 8, 252);
    			attr_dev(div2, "class", "containTitleName svelte-1cctzi7");
    			add_location(div2, file$d, 6, 4, 152);
    			attr_dev(div3, "id", "enterBoard");
    			attr_dev(div3, "class", "svelte-1cctzi7");
    			add_location(div3, file$d, 5, 0, 124);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div3, t3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div3, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$LisEnter*/ 1) {
    				each_value = /*$LisEnter*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div3, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let $LisEnter;
    	validate_store(LisEnter, 'LisEnter');
    	component_subscribe($$self, LisEnter, $$value => $$invalidate(0, $LisEnter = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('EnterBoard', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<EnterBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ EnterForm, LisEnter, $LisEnter });
    	return [$LisEnter];
    }

    class EnterBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EnterBoard",
    			options,
    			id: create_fragment$f.name
    		});
    	}
    }

    /* srcReviving\MainArea\MainArea.svelte generated by Svelte v3.59.2 */
    const file$c = "srcReviving\\MainArea\\MainArea.svelte";

    // (43:34) 
    function create_if_block_6(ctx) {
    	let resultcontain;
    	let current;
    	resultcontain = new ResultContain({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(resultcontain.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(resultcontain, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(resultcontain.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(resultcontain.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(resultcontain, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(43:34) ",
    		ctx
    	});

    	return block;
    }

    // (41:31) 
    function create_if_block_5(ctx) {
    	let mixcontain;
    	let current;
    	mixcontain = new MixContain({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(mixcontain.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(mixcontain, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mixcontain.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mixcontain.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(mixcontain, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(41:31) ",
    		ctx
    	});

    	return block;
    }

    // (39:33) 
    function create_if_block_4(ctx) {
    	let meanscontain;
    	let current;
    	meanscontain = new MeansContain({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(meanscontain.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(meanscontain, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(meanscontain.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(meanscontain.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(meanscontain, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(39:33) ",
    		ctx
    	});

    	return block;
    }

    // (36:32) 
    function create_if_block_3(ctx) {
    	let wordscontain;
    	let current;
    	wordscontain = new WordsContain({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(wordscontain.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wordscontain, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wordscontain.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wordscontain.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wordscontain, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(36:32) ",
    		ctx
    	});

    	return block;
    }

    // (34:33) 
    function create_if_block_2$1(ctx) {
    	let charscontain;
    	let current;
    	charscontain = new CharsContain({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(charscontain.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(charscontain, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(charscontain.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(charscontain.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(charscontain, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(34:33) ",
    		ctx
    	});

    	return block;
    }

    // (32:34) 
    function create_if_block_1$1(ctx) {
    	let choicespanel;
    	let current;
    	choicespanel = new ChoicesPanel({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(choicespanel.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(choicespanel, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(choicespanel.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(choicespanel.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(choicespanel, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(32:34) ",
    		ctx
    	});

    	return block;
    }

    // (27:4) {#if $choice =='enter'}
    function create_if_block$3(ctx) {
    	let enterboard;
    	let current;
    	enterboard = new EnterBoard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(enterboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(enterboard, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(enterboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(enterboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(enterboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(27:4) {#if $choice =='enter'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div;
    	let current_block_type_index;
    	let if_block;
    	let current;

    	const if_block_creators = [
    		create_if_block$3,
    		create_if_block_1$1,
    		create_if_block_2$1,
    		create_if_block_3,
    		create_if_block_4,
    		create_if_block_5,
    		create_if_block_6
    	];

    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$choice*/ ctx[0] == 'enter') return 0;
    		if (/*$choice*/ ctx[0] == 'choices') return 1;
    		if (/*$choice*/ ctx[0] == 'chars') return 2;
    		if (/*$choice*/ ctx[0] == 'words') return 3;
    		if (/*$choice*/ ctx[0] == 'means') return 4;
    		if (/*$choice*/ ctx[0] == 'mix') return 5;
    		if (/*$choice*/ ctx[0] == 'result') return 6;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "id", "mainArea");
    			attr_dev(div, "class", "svelte-h9ahnt");
    			add_location(div, file$c, 24, 0, 541);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block = if_blocks[current_block_type_index];

    					if (!if_block) {
    						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block.c();
    					}

    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				} else {
    					if_block = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let $choice;
    	validate_store(choice, 'choice');
    	component_subscribe($$self, choice, $$value => $$invalidate(0, $choice = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('MainArea', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<MainArea> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		CharsContain,
    		ChoicesPanel,
    		MeansContain,
    		MixContain,
    		ResultContain,
    		WordsContain,
    		EnterBoard,
    		choice,
    		$choice
    	});

    	return [$choice];
    }

    class MainArea extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MainArea",
    			options,
    			id: create_fragment$e.name
    		});
    	}
    }

    /* srcReviving\Reviving.svelte generated by Svelte v3.59.2 */
    const file$b = "srcReviving\\Reviving.svelte";

    // (16:0) {#if $dictionaryDS}
    function create_if_block$2(ctx) {
    	let dictionary;
    	let current;
    	dictionary = new Dictionary({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dictionary.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dictionary, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dictionary.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dictionary.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dictionary, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(16:0) {#if $dictionaryDS}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let div;
    	let img;
    	let img_src_value;
    	let t0;
    	let taskbar;
    	let t1;
    	let mainarea;
    	let t2;
    	let if_block_anchor;
    	let current;
    	taskbar = new Taskbar({ $$inline: true });
    	mainarea = new MainArea({ $$inline: true });
    	let if_block = /*$dictionaryDS*/ ctx[0] && create_if_block$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			img = element("img");
    			t0 = space();
    			create_component(taskbar.$$.fragment);
    			t1 = space();
    			create_component(mainarea.$$.fragment);
    			t2 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			if (!src_url_equal(img.src, img_src_value = "../images/withoutunderwhite.svg")) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "logo");
    			attr_dev(img, "id", "logo");
    			attr_dev(img, "class", "svelte-1qdmmwa");
    			add_location(img, file$b, 9, 4, 248);
    			attr_dev(div, "id", "taskbar");
    			attr_dev(div, "class", "svelte-1qdmmwa");
    			add_location(div, file$b, 8, 0, 222);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, img);
    			append_dev(div, t0);
    			mount_component(taskbar, div, null);
    			insert_dev(target, t1, anchor);
    			mount_component(mainarea, target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$dictionaryDS*/ ctx[0]) {
    				if (if_block) {
    					if (dirty & /*$dictionaryDS*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(taskbar.$$.fragment, local);
    			transition_in(mainarea.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(taskbar.$$.fragment, local);
    			transition_out(mainarea.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(taskbar);
    			if (detaching) detach_dev(t1);
    			destroy_component(mainarea, detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $dictionaryDS;
    	validate_store(dictionaryDS, 'dictionaryDS');
    	component_subscribe($$self, dictionaryDS, $$value => $$invalidate(0, $dictionaryDS = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Reviving', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Reviving> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Taskbar,
    		dictionaryDS,
    		Dictionary,
    		MainArea,
    		$dictionaryDS
    	});

    	return [$dictionaryDS];
    }

    class Reviving extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Reviving",
    			options,
    			id: create_fragment$d.name
    		});
    	}
    }

    let gameInputWord = writable("hiiii");

    let searchDicTF = writable(false);
    let resultCheckWord = writable();

    let stepGame = writable('choice');

    let listresEnter = writable([]); // lưu các từ user nhập
    let TFlist = writable([]);
    let changingUserAi =writable(false);

    let nofi = writable(''); //notifi

    let onWhom = writable('ai');

    /* srcGame\ContainDic\DefiBoard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$4 } = globals;
    const file$a = "srcGame\\ContainDic\\DefiBoard.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[9] = list[i];
    	return child_ctx;
    }

    // (103:4) {#each types.deex as defiexam}
    function create_each_block_1(ctx) {
    	let div2;
    	let button;
    	let t1;
    	let div0;
    	let t2_value = /*defiexam*/ ctx[9].defi + "";
    	let t2;
    	let t3;
    	let div1;
    	let t4_value = /*defiexam*/ ctx[9].exam + "";
    	let t4;
    	let t5;
    	let mounted;
    	let dispose;

    	function click_handler() {
    		return /*click_handler*/ ctx[2](/*defiexam*/ ctx[9]);
    	}

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			button = element("button");
    			button.textContent = "save";
    			t1 = space();
    			div0 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			attr_dev(button, "class", "savevo svelte-g3c5qs");
    			add_location(button, file$a, 104, 8, 2441);
    			attr_dev(div0, "class", "DefiEng svelte-g3c5qs");
    			add_location(div0, file$a, 105, 8, 2536);
    			attr_dev(div1, "class", "ExEng svelte-g3c5qs");
    			add_location(div1, file$a, 106, 8, 2590);
    			attr_dev(div2, "class", "MeaningClass svelte-g3c5qs");
    			add_location(div2, file$a, 103, 4, 2404);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, button);
    			append_dev(div2, t1);
    			append_dev(div2, div0);
    			append_dev(div0, t2);
    			append_dev(div2, t3);
    			append_dev(div2, div1);
    			append_dev(div1, t4);
    			append_dev(div2, t5);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", click_handler, false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty & /*fetchValue*/ 2 && t2_value !== (t2_value = /*defiexam*/ ctx[9].defi + "")) set_data_dev(t2, t2_value);
    			if (dirty & /*fetchValue*/ 2 && t4_value !== (t4_value = /*defiexam*/ ctx[9].exam + "")) set_data_dev(t4, t4_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(103:4) {#each types.deex as defiexam}",
    		ctx
    	});

    	return block;
    }

    // (101:2) {#each fetchValue.board as types}
    function create_each_block$3(ctx) {
    	let div;
    	let t0_value = /*types*/ ctx[6].type + "";
    	let t0;
    	let t1;
    	let each_1_anchor;
    	let each_value_1 = /*types*/ ctx[6].deex;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text(t0_value);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    			attr_dev(div, "class", "partOfSpeech svelte-g3c5qs");
    			add_location(div, file$a, 101, 4, 2316);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			insert_dev(target, t1, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(target, anchor);
    				}
    			}

    			insert_dev(target, each_1_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*fetchValue*/ 2 && t0_value !== (t0_value = /*types*/ ctx[6].type + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*fetchValue, Saving, words*/ 3) {
    				each_value_1 = /*types*/ ctx[6].deex;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t1);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(101:2) {#each fetchValue.board as types}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let div;
    	let each_value = /*fetchValue*/ ctx[1].board;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "containerPath svelte-g3c5qs");
    			add_location(div, file$a, 99, 0, 2244);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*fetchValue, Saving, words*/ 3) {
    				each_value = /*fetchValue*/ ctx[1].board;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function Saving(definition, words) {
    	let vocData = JSON.parse(localStorage.getItem('vocabulary'));
    	let date = `${new Date().getUTCDate()} - ${new Date().getUTCMonth() + 1} - ${new Date().getUTCFullYear()}`;

    	if (vocData.length === 0 || vocData[0].day !== date) {
    		let newDay = {};
    		newDay["day"] = date;
    		newDay["content"] = [];
    		vocData.unshift(newDay);
    	}

    	let con = {};
    	con["word"] = words;
    	con["definition"] = definition;
    	vocData[0].content.push(con);
    	localStorage.setItem('vocabulary', JSON.stringify(vocData));
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DefiBoard', slots, []);
    	let { words } = $$props;
    	let fetchValue = { "word": "", "pronon": "", "board": [] };

    	//API DÈINITION
    	let huptext = words;

    	var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + `${huptext}`;
    	let contaiFile;

    	fetch(link).then(res => res.json()).then(result => {
    		result.map(run1);

    		function run1(resultNew) {
    			$$invalidate(1, fetchValue.word = resultNew.word, fetchValue);
    			$$invalidate(1, fetchValue.pronon = resultNew.phonetic, fetchValue);
    			resultNew.meanings.map(run2);
    		} //phonetic vs word here

    		function run2(meaningsNew) {
    			contaiFile = { "type": "", "deex": [] };
    			contaiFile.type = meaningsNew.partOfSpeech;
    			meaningsNew.definitions.map(run3);
    			fetchValue.board.push(contaiFile);
    		}

    		function run3(definitionsNew) {
    			let deSam = { "defi": "", "exam": "" };
    			deSam.defi = definitionsNew.definition;

    			if (definitionsNew.example != undefined) {
    				deSam.exam = "Ex: " + definitionsNew.example;
    			} else {
    				deSam.exam = '';
    			}

    			contaiFile.deex.push(deSam);
    		}
    	}).catch(error => {
    		console.log(error);
    	}).finally(() => {
    		
    	});

    	$$self.$$.on_mount.push(function () {
    		if (words === undefined && !('words' in $$props || $$self.$$.bound[$$self.$$.props['words']])) {
    			console_1$4.warn("<DefiBoard> was created without expected prop 'words'");
    		}
    	});

    	const writable_props = ['words'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$4.warn(`<DefiBoard> was created with unknown prop '${key}'`);
    	});

    	const click_handler = defiexam => {
    		Saving(defiexam.defi, words);
    	};

    	$$self.$$set = $$props => {
    		if ('words' in $$props) $$invalidate(0, words = $$props.words);
    	};

    	$$self.$capture_state = () => ({
    		words,
    		fetchValue,
    		huptext,
    		link,
    		contaiFile,
    		Saving
    	});

    	$$self.$inject_state = $$props => {
    		if ('words' in $$props) $$invalidate(0, words = $$props.words);
    		if ('fetchValue' in $$props) $$invalidate(1, fetchValue = $$props.fetchValue);
    		if ('huptext' in $$props) huptext = $$props.huptext;
    		if ('link' in $$props) link = $$props.link;
    		if ('contaiFile' in $$props) contaiFile = $$props.contaiFile;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [words, fetchValue, click_handler];
    }

    class DefiBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { words: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DefiBoard",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get words() {
    		throw new Error("<DefiBoard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set words(value) {
    		throw new Error("<DefiBoard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcGame\ContainDic\FallBoard.svelte generated by Svelte v3.59.2 */

    const file$9 = "srcGame\\ContainDic\\FallBoard.svelte";

    function create_fragment$b(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Bad words bro, try another!";
    			attr_dev(div, "id", "failalert");
    			attr_dev(div, "class", "svelte-y0nv4u");
    			add_location(div, file$9, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('FallBoard', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<FallBoard> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class FallBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FallBoard",
    			options,
    			id: create_fragment$b.name
    		});
    	}
    }

    /* srcGame\ContainDic\ContainDic.svelte generated by Svelte v3.59.2 */
    const file$8 = "srcGame\\ContainDic\\ContainDic.svelte";

    // (15:8) {:else}
    function create_else_block(ctx) {
    	let fallboard;
    	let current;
    	fallboard = new FallBoard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(fallboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(fallboard, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(fallboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(fallboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(fallboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(15:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (13:8) {#if $resultCheckWord}
    function create_if_block$1(ctx) {
    	let defiboard;
    	let current;

    	defiboard = new DefiBoard({
    			props: { words: /*$gameInputWord*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(defiboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(defiboard, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const defiboard_changes = {};
    			if (dirty & /*$gameInputWord*/ 1) defiboard_changes.words = /*$gameInputWord*/ ctx[0];
    			defiboard.$set(defiboard_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(defiboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(defiboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(defiboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(13:8) {#if $resultCheckWord}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let div3;
    	let div2;
    	let div0;
    	let t0;
    	let t1;
    	let div1;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$1, create_else_block];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$resultCheckWord*/ ctx[1]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(/*$gameInputWord*/ ctx[0]);
    			t1 = space();
    			div1 = element("div");
    			if_block.c();
    			attr_dev(div0, "id", "conTilte");
    			attr_dev(div0, "class", "svelte-173zwms");
    			add_location(div0, file$8, 10, 4, 274);
    			attr_dev(div1, "id", "conTainDefi");
    			attr_dev(div1, "class", "svelte-173zwms");
    			add_location(div1, file$8, 11, 4, 322);
    			attr_dev(div2, "id", "ContainDic");
    			attr_dev(div2, "class", "svelte-173zwms");
    			add_location(div2, file$8, 9, 0, 245);
    			attr_dev(div3, "id", "diction");
    			attr_dev(div3, "class", "svelte-173zwms");
    			add_location(div3, file$8, 8, 0, 223);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div2);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			if_blocks[current_block_type_index].m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!current || dirty & /*$gameInputWord*/ 1) set_data_dev(t0, /*$gameInputWord*/ ctx[0]);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				} else {
    					if_block.p(ctx, dirty);
    				}

    				transition_in(if_block, 1);
    				if_block.m(div1, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let $gameInputWord;
    	let $resultCheckWord;
    	validate_store(gameInputWord, 'gameInputWord');
    	component_subscribe($$self, gameInputWord, $$value => $$invalidate(0, $gameInputWord = $$value));
    	validate_store(resultCheckWord, 'resultCheckWord');
    	component_subscribe($$self, resultCheckWord, $$value => $$invalidate(1, $resultCheckWord = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ContainDic', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<ContainDic> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		gameInputWord,
    		nofi,
    		resultCheckWord,
    		DefiBoard,
    		FallBoard,
    		$gameInputWord,
    		$resultCheckWord
    	});

    	return [$gameInputWord, $resultCheckWord];
    }

    class ContainDic extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContainDic",
    			options,
    			id: create_fragment$a.name
    		});
    	}
    }

    /* srcGame\SolvingGame.svelte\DisWords.svelte generated by Svelte v3.59.2 */

    const { console: console_1$3 } = globals;

    const file$7 = "srcGame\\SolvingGame.svelte\\DisWords.svelte";

    function create_fragment$9(ctx) {
    	let div;
    	let t_value = /*$listresEnter*/ ctx[2][/*sort*/ ctx[0]] + "";
    	let t;
    	let div_style_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(t_value);
    			attr_dev(div, "class", "disword svelte-1ixcmat");
    			attr_dev(div, "style", div_style_value = `background-color: ${/*backColor*/ ctx[1]}`);
    			add_location(div, file$7, 68, 0, 2592);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$listresEnter, sort*/ 5 && t_value !== (t_value = /*$listresEnter*/ ctx[2][/*sort*/ ctx[0]] + "")) set_data_dev(t, t_value);

    			if (dirty & /*backColor*/ 2 && div_style_value !== (div_style_value = `background-color: ${/*backColor*/ ctx[1]}`)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
    	let $gameInputWord;
    	let $onWhom;
    	let $TFlist;
    	let $searchDicTF;
    	let $nofi;
    	let $listresEnter;
    	validate_store(gameInputWord, 'gameInputWord');
    	component_subscribe($$self, gameInputWord, $$value => $$invalidate(4, $gameInputWord = $$value));
    	validate_store(onWhom, 'onWhom');
    	component_subscribe($$self, onWhom, $$value => $$invalidate(5, $onWhom = $$value));
    	validate_store(TFlist, 'TFlist');
    	component_subscribe($$self, TFlist, $$value => $$invalidate(6, $TFlist = $$value));
    	validate_store(searchDicTF, 'searchDicTF');
    	component_subscribe($$self, searchDicTF, $$value => $$invalidate(7, $searchDicTF = $$value));
    	validate_store(nofi, 'nofi');
    	component_subscribe($$self, nofi, $$value => $$invalidate(8, $nofi = $$value));
    	validate_store(listresEnter, 'listresEnter');
    	component_subscribe($$self, listresEnter, $$value => $$invalidate(2, $listresEnter = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('DisWords', slots, []);
    	let { sort, content } = $$props;
    	let backColor;

    	onMount(() => {
    		console.log("ssdfsdsdsdsds", content);

    		if (content == 'user') {
    			let text = $listresEnter[sort];
    			console.log(text, ";;;;;k");
    			text = text.split('');
    			text = text[text.length - 1];
    			console.log(text);
    			let link = `https://api.datamuse.com/words?sp=${text}*`;

    			fetch(link).then(res => res.json()).then(res => {
    				let ListWord = [];

    				res.map(value => {
    					ListWord.push(value.word);
    				});

    				text = ListWord[Math.floor(Math.random() * (ListWord.length - 1))];
    			});

    			setTimeout(
    				() => {
    					let noi = [
    						"Bring it on! My turn for some action.",
    						"Ready when you are, hit me with the next challenge.",
    						"Hand it over, I'm all in! Can't wait to take my shot.",
    						"My watch has come, let's see what's in store.",
    						"Eyes peeled, ears open, I'm primed and ready to go!",
    						"Up next! Can't wait to show my stuff.",
    						"Pass the baton, I'm ready to run with it.",
    						"Show time! Step aside, it's my moment to shine.",
    						"Gimme it, gimme it! I'm itching to get started.",
    						"On your mark, get set, let's do this! My turn to play."
    					];

    					set_store_value(nofi, $nofi = noi[Math.floor(Math.random() * (noi.length - 1))], $nofi);
    					set_store_value(searchDicTF, $searchDicTF = false, $searchDicTF);
    				},
    				5000
    			);

    			setTimeout(
    				() => {
    					let noi = [
    						"Finished.",
    						"Completed.",
    						"Concluded.",
    						"Achieved.",
    						"Accomplished.",
    						"Finalized.",
    						"Executed.",
    						"Fulfilled.",
    						"Resolved.",
    						"Ended."
    					];

    					set_store_value(nofi, $nofi = noi[Math.floor(Math.random() * (noi.length - 1))], $nofi);
    					set_store_value(gameInputWord, $gameInputWord = text, $gameInputWord);
    					set_store_value(searchDicTF, $searchDicTF = true, $searchDicTF);
    					console.log($TFlist);

    					//ai thinking
    					listresEnter.update(value => {
    						value.push(text);
    						return value;
    					});

    					TFlist.update(value => {
    						value.push('ai');
    						return value;
    					});

    					set_store_value(onWhom, $onWhom = 'ai', $onWhom);
    				},
    				8000
    			);
    		} else if (content == 'ai') {
    			console.log("adadad");
    			set_store_value(onWhom, $onWhom = 'user', $onWhom);
    			document.getElementById('textIn').value = $gameInputWord.split('').pop();
    		}
    	});

    	if (content == 'user') {
    		backColor = '#ff6464';
    	} else {
    		backColor = '#139487';
    	}

    	$$self.$$.on_mount.push(function () {
    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console_1$3.warn("<DisWords> was created without expected prop 'sort'");
    		}

    		if (content === undefined && !('content' in $$props || $$self.$$.bound[$$self.$$.props['content']])) {
    			console_1$3.warn("<DisWords> was created without expected prop 'content'");
    		}
    	});

    	const writable_props = ['sort', 'content'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$3.warn(`<DisWords> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    		if ('content' in $$props) $$invalidate(3, content = $$props.content);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		TFlist,
    		gameInputWord,
    		listresEnter,
    		nofi,
    		onWhom,
    		searchDicTF,
    		sort,
    		content,
    		backColor,
    		$gameInputWord,
    		$onWhom,
    		$TFlist,
    		$searchDicTF,
    		$nofi,
    		$listresEnter
    	});

    	$$self.$inject_state = $$props => {
    		if ('sort' in $$props) $$invalidate(0, sort = $$props.sort);
    		if ('content' in $$props) $$invalidate(3, content = $$props.content);
    		if ('backColor' in $$props) $$invalidate(1, backColor = $$props.backColor);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [sort, backColor, $listresEnter, content];
    }

    class DisWords extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { sort: 0, content: 3 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DisWords",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get sort() {
    		throw new Error("<DisWords>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<DisWords>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get content() {
    		throw new Error("<DisWords>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set content(value) {
    		throw new Error("<DisWords>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* srcGame\SolvingGame.svelte\YouMe.svelte generated by Svelte v3.59.2 */

    const file$6 = "srcGame\\SolvingGame.svelte\\YouMe.svelte";

    function create_fragment$8(ctx) {
    	let div2;
    	let div0;
    	let t1;
    	let div1;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "you";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "me";
    			attr_dev(div0, "class", "YMcontent svelte-p0565f");
    			attr_dev(div0, "id", "YMyou");
    			add_location(div0, file$6, 2, 4, 31);
    			attr_dev(div1, "class", "YMcontent svelte-p0565f");
    			attr_dev(div1, "id", "YMme");
    			add_location(div1, file$6, 4, 4, 86);
    			attr_dev(div2, "id", "containYM");
    			attr_dev(div2, "class", "svelte-p0565f");
    			add_location(div2, file$6, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('YouMe', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<YouMe> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class YouMe extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$8, create_fragment$8, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "YouMe",
    			options,
    			id: create_fragment$8.name
    		});
    	}
    }

    /* srcGame\SolvingGame.svelte\SolvingGame.svelte generated by Svelte v3.59.2 */
    const file$5 = "srcGame\\SolvingGame.svelte\\SolvingGame.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	child_ctx[3] = i;
    	return child_ctx;
    }

    // (12:4) {#each $TFlist as items, i}
    function create_each_block$2(ctx) {
    	let diswords;
    	let current;

    	diswords = new DisWords({
    			props: {
    				sort: /*i*/ ctx[3],
    				content: /*items*/ ctx[1]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(diswords.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(diswords, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const diswords_changes = {};
    			if (dirty & /*$TFlist*/ 1) diswords_changes.content = /*items*/ ctx[1];
    			diswords.$set(diswords_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(diswords.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(diswords.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(diswords, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(12:4) {#each $TFlist as items, i}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let div;
    	let youme;
    	let t;
    	let current;
    	youme = new YouMe({ $$inline: true });
    	let each_value = /*$TFlist*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(youme.$$.fragment);
    			t = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "id", "containSov");
    			attr_dev(div, "class", "svelte-1mdqsur");
    			add_location(div, file$5, 9, 0, 307);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(youme, div, null);
    			append_dev(div, t);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div, null);
    				}
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*$TFlist*/ 1) {
    				each_value = /*$TFlist*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(youme.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(youme.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(youme);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$7($$self, $$props, $$invalidate) {
    	let $TFlist;
    	validate_store(TFlist, 'TFlist');
    	component_subscribe($$self, TFlist, $$value => $$invalidate(0, $TFlist = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SolvingGame', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SolvingGame> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		TFlist,
    		changingUserAi,
    		listresEnter,
    		nofi,
    		searchDicTF,
    		DisWords,
    		YouMe,
    		$TFlist
    	});

    	return [$TFlist];
    }

    class SolvingGame extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SolvingGame",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    /* srcGame\WhoFirst\WFboard.svelte generated by Svelte v3.59.2 */

    const { console: console_1$2 } = globals;

    const file$4 = "srcGame\\WhoFirst\\WFboard.svelte";

    function create_fragment$6(ctx) {
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let button0;
    	let t3;
    	let button1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "who's first?";
    			t1 = space();
    			div1 = element("div");
    			button0 = element("button");
    			button0.textContent = "you";
    			t3 = space();
    			button1 = element("button");
    			button1.textContent = "me";
    			attr_dev(div0, "id", "WFtitile");
    			attr_dev(div0, "class", "svelte-13t68me");
    			add_location(div0, file$4, 82, 4, 3988);
    			attr_dev(button0, "id", "you");
    			attr_dev(button0, "class", "svelte-13t68me");
    			add_location(button0, file$4, 84, 8, 4071);
    			attr_dev(button1, "id", "me");
    			attr_dev(button1, "class", "svelte-13t68me");
    			add_location(button1, file$4, 85, 8, 4128);
    			attr_dev(div1, "id", "containWFchoice");
    			attr_dev(div1, "class", "svelte-13t68me");
    			add_location(div1, file$4, 83, 4, 4033);
    			attr_dev(div2, "id", "containWF");
    			attr_dev(div2, "class", "svelte-13t68me");
    			add_location(div2, file$4, 81, 0, 3960);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, button0);
    			append_dev(div1, t3);
    			append_dev(div1, button1);

    			if (!mounted) {
    				dispose = [
    					listen_dev(button0, "click", /*You*/ ctx[0], false, false, false, false),
    					listen_dev(button1, "click", /*Me*/ ctx[1], false, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let $nofi;
    	let $stepGame;
    	let $onWhom;
    	let $TFlist;
    	let $resultCheckWord;
    	let $searchDicTF;
    	let $gameInputWord;
    	validate_store(nofi, 'nofi');
    	component_subscribe($$self, nofi, $$value => $$invalidate(2, $nofi = $$value));
    	validate_store(stepGame, 'stepGame');
    	component_subscribe($$self, stepGame, $$value => $$invalidate(3, $stepGame = $$value));
    	validate_store(onWhom, 'onWhom');
    	component_subscribe($$self, onWhom, $$value => $$invalidate(4, $onWhom = $$value));
    	validate_store(TFlist, 'TFlist');
    	component_subscribe($$self, TFlist, $$value => $$invalidate(5, $TFlist = $$value));
    	validate_store(resultCheckWord, 'resultCheckWord');
    	component_subscribe($$self, resultCheckWord, $$value => $$invalidate(6, $resultCheckWord = $$value));
    	validate_store(searchDicTF, 'searchDicTF');
    	component_subscribe($$self, searchDicTF, $$value => $$invalidate(7, $searchDicTF = $$value));
    	validate_store(gameInputWord, 'gameInputWord');
    	component_subscribe($$self, gameInputWord, $$value => $$invalidate(8, $gameInputWord = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('WFboard', slots, []);

    	function You() {
    		let Turn = [
    			"Understood, I'll take a look.",
    			"Affirmative, I'm prepared.",
    			"Acknowledged, I'll review it.",
    			"Certainly, I'm all set.",
    			"Agreed, I'm ready.",
    			"Absolutely, I'm prepared.",
    			"Roger that, I'll examine it.",
    			"Indeed, I'm all set.",
    			"Absolutely, I'm good to go.",
    			"Affirmative, I'm ready."
    		];

    		let r = Math.floor(Math.random() * (Turn.length - 1));

    		let See = [
    			"Mulling it over.",
    			"Weighing my options.",
    			"Digesting this.",
    			"Running some calculations.",
    			"Letting the gears turn.",
    			"Trying to unscrew this mental pickle.",
    			"Holding space for an answer.",
    			"My brain is currently in high gear.",
    			"Just a sec, letting the light bulb dim to a nice soft glow."
    		];

    		setTimeout(
    			() => {
    				set_store_value(nofi, $nofi = Turn[r], $nofi);
    			},
    			0
    		);

    		setTimeout(
    			() => {
    				set_store_value(nofi, $nofi = See[Math.floor(Math.random() * (Turn.length - 1))], $nofi);
    			},
    			1000
    		);

    		listresEnter.update(value => {
    			var letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
    			var randomIndex = Math.floor(Math.random() * letters.length);
    			letters = letters.charAt(randomIndex);
    			let link = `https://api.datamuse.com/words?sp=${letters}*`;

    			fetch(link).then(res => res.json()).then(res => {
    				let ListWord = [];

    				res.map(value => {
    					ListWord.push(value.word);
    				});

    				let text = ListWord[Math.floor(Math.random() * (ListWord.length - 1))];
    				value.push(text);
    				set_store_value(gameInputWord, $gameInputWord = text, $gameInputWord);
    				set_store_value(searchDicTF, $searchDicTF = true, $searchDicTF);
    				set_store_value(resultCheckWord, $resultCheckWord = true, $resultCheckWord);
    			});

    			return value;
    		});

    		console.log($TFlist);

    		setTimeout(
    			() => {
    				TFlist.update(value => {
    					value.push('ai');

    					//$onWhom = 'user'
    					//nofi
    					let noi = [
    						"Nailed it!",
    						"Absolutely stellar! ✨",
    						"First-rate work!",
    						"Exceeded expectations!",
    						"Bravo!",
    						"Top-notch execution!",
    						"Masterful achievement!",
    						"You knocked it out of the park! ⚾",
    						"Pure brilliance!",
    						"Couldn't ask for more!"
    					];

    					set_store_value(nofi, $nofi = noi[Math.floor(Math.random() * (noi.length - 1))], $nofi);
    					return value;
    				});
    			},
    			2000
    		);

    		set_store_value(stepGame, $stepGame = 'solving', $stepGame);
    	}

    	function Me() {
    		set_store_value(onWhom, $onWhom = 'user', $onWhom);

    		let noi = [
    			"After you, pal!",
    			"Go for it, my friend!",
    			"Your call, champ!",
    			"Lead the way, sunshine!",
    			"You first, mate!",
    			"Knock yourself out, buddy!",
    			"Take the stage, amigo!",
    			"The floor is yours, partner!",
    			"On your cue, teammate!",
    			"You're the captain, steer us home!"
    		];

    		set_store_value(nofi, $nofi = noi[Math.floor(Math.random() * (noi.length - 1))], $nofi);
    		set_store_value(stepGame, $stepGame = 'solving', $stepGame);
    	}

    	//notification
    	let HiList = [
    		"Hello, how are you today?",
    		"Good morning, it's great to see you!",
    		"Hi there, I hope you're doing well.",
    		"Hey, how's your day going?",
    		"Good to see you, how have you been?",
    		"Greetings, I trust you're having a good day.",
    		"Howdy, hope everything's going smoothly for you.",
    		"Salutations, I'm glad we could meet today.",
    		"Aloha, I hope you're enjoying your day.",
    		"Bonjour, comment ça va?"
    	];

    	let ChoiceList = [
    		"Who should go first, you or me?",
    		"Shall we decide who goes first?",
    		"How about we take turns, starting with you?",
    		"Let's pick who goes first, shall we?",
    		"Do you want to go first, or should I?",
    		"How about we make a choice together?",
    		"Let's decide who goes first, okay?",
    		"Should we flip a coin to decide?",
    		"How about we alternate turns, starting with you?",
    		"Let's figure out who goes first, sound good?"
    	];

    	setTimeout(
    		() => {
    			let r = Math.floor(Math.random() * (HiList.length - 1));
    			set_store_value(nofi, $nofi = HiList[r], $nofi);
    		},
    		1000
    	);

    	setTimeout(
    		() => {
    			let h = Math.floor(Math.random() * (ChoiceList.length - 1));
    			set_store_value(nofi, $nofi = ChoiceList[[h]], $nofi);
    		},
    		4000
    	);

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<WFboard> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		TFlist,
    		gameInputWord,
    		listresEnter,
    		nofi,
    		onWhom,
    		resultCheckWord,
    		searchDicTF,
    		stepGame,
    		You,
    		Me,
    		HiList,
    		ChoiceList,
    		$nofi,
    		$stepGame,
    		$onWhom,
    		$TFlist,
    		$resultCheckWord,
    		$searchDicTF,
    		$gameInputWord
    	});

    	$$self.$inject_state = $$props => {
    		if ('HiList' in $$props) HiList = $$props.HiList;
    		if ('ChoiceList' in $$props) ChoiceList = $$props.ChoiceList;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [You, Me];
    }

    class WFboard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "WFboard",
    			options,
    			id: create_fragment$6.name
    		});
    	}
    }

    /* srcGame\ContainGame\ContainGame.svelte generated by Svelte v3.59.2 */

    const { console: console_1$1 } = globals;

    const file$3 = "srcGame\\ContainGame\\ContainGame.svelte";

    // (80:45) 
    function create_if_block_2(ctx) {
    	let solvinggame;
    	let current;
    	solvinggame = new SolvingGame({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(solvinggame.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(solvinggame, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(solvinggame.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(solvinggame.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(solvinggame, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(80:45) ",
    		ctx
    	});

    	return block;
    }

    // (78:12) {#if $stepGame == 'choice'}
    function create_if_block_1(ctx) {
    	let wfboard;
    	let current;
    	wfboard = new WFboard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(wfboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(wfboard, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(wfboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(wfboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(wfboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(78:12) {#if $stepGame == 'choice'}",
    		ctx
    	});

    	return block;
    }

    // (89:12) {#if $searchDicTF}
    function create_if_block(ctx) {
    	let containdic;
    	let current;
    	containdic = new ContainDic({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(containdic.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(containdic, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(containdic.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(containdic.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(containdic, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(89:12) {#if $searchDicTF}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let div4;
    	let div1;
    	let div0;
    	let current_block_type_index;
    	let if_block0;
    	let t0;
    	let div3;
    	let div2;
    	let t1;
    	let t2;
    	let t3;
    	let input;
    	let t4;
    	let button;
    	let current;
    	let mounted;
    	let dispose;
    	const if_block_creators = [create_if_block_1, create_if_block_2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$stepGame*/ ctx[2] == 'choice') return 0;
    		if (/*$stepGame*/ ctx[2] == 'solving') return 1;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	let if_block1 = /*$searchDicTF*/ ctx[0] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			div4 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div3 = element("div");
    			div2 = element("div");
    			t1 = text(/*$nofi*/ ctx[1]);
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			input = element("input");
    			t4 = space();
    			button = element("button");
    			button.textContent = "done";
    			attr_dev(div0, "id", "containDisplay");
    			attr_dev(div0, "class", "svelte-1s4y3ye");
    			add_location(div0, file$3, 76, 8, 3274);
    			attr_dev(div1, "id", "containContent");
    			attr_dev(div1, "class", "svelte-1s4y3ye");
    			add_location(div1, file$3, 74, 4, 3228);
    			attr_dev(div2, "id", "status");
    			attr_dev(div2, "class", "svelte-1s4y3ye");
    			add_location(div2, file$3, 86, 8, 3547);
    			attr_dev(input, "type", "text");
    			attr_dev(input, "id", "textIn");
    			attr_dev(input, "autocomplete", "off");
    			attr_dev(input, "class", "svelte-1s4y3ye");
    			add_location(input, file$3, 92, 8, 3679);
    			attr_dev(button, "id", "done");
    			attr_dev(button, "class", "svelte-1s4y3ye");
    			add_location(button, file$3, 93, 8, 3742);
    			attr_dev(div3, "id", "containStatus");
    			attr_dev(div3, "class", "svelte-1s4y3ye");
    			add_location(div3, file$3, 85, 4, 3511);
    			attr_dev(div4, "id", "GameContain");
    			attr_dev(div4, "class", "svelte-1s4y3ye");
    			add_location(div4, file$3, 73, 0, 3198);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div4, anchor);
    			append_dev(div4, div1);
    			append_dev(div1, div0);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div0, null);
    			}

    			append_dev(div4, t0);
    			append_dev(div4, div3);
    			append_dev(div3, div2);
    			append_dev(div2, t1);
    			append_dev(div3, t2);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t3);
    			append_dev(div3, input);
    			append_dev(div3, t4);
    			append_dev(div3, button);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Done*/ ctx[3], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index !== previous_block_index) {
    				if (if_block0) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block0 = if_blocks[current_block_type_index];

    					if (!if_block0) {
    						if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block0.c();
    					}

    					transition_in(if_block0, 1);
    					if_block0.m(div0, null);
    				} else {
    					if_block0 = null;
    				}
    			}

    			if (!current || dirty & /*$nofi*/ 2) set_data_dev(t1, /*$nofi*/ ctx[1]);

    			if (/*$searchDicTF*/ ctx[0]) {
    				if (if_block1) {
    					if (dirty & /*$searchDicTF*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div4);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}

    			if (if_block1) if_block1.d();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let $searchDicTF;
    	let $TFlist;
    	let $onWhom;
    	let $resultCheckWord;
    	let $changingUserAi;
    	let $gameInputWord;
    	let $nofi;
    	let $stepGame;
    	validate_store(searchDicTF, 'searchDicTF');
    	component_subscribe($$self, searchDicTF, $$value => $$invalidate(0, $searchDicTF = $$value));
    	validate_store(TFlist, 'TFlist');
    	component_subscribe($$self, TFlist, $$value => $$invalidate(4, $TFlist = $$value));
    	validate_store(onWhom, 'onWhom');
    	component_subscribe($$self, onWhom, $$value => $$invalidate(5, $onWhom = $$value));
    	validate_store(resultCheckWord, 'resultCheckWord');
    	component_subscribe($$self, resultCheckWord, $$value => $$invalidate(6, $resultCheckWord = $$value));
    	validate_store(changingUserAi, 'changingUserAi');
    	component_subscribe($$self, changingUserAi, $$value => $$invalidate(7, $changingUserAi = $$value));
    	validate_store(gameInputWord, 'gameInputWord');
    	component_subscribe($$self, gameInputWord, $$value => $$invalidate(8, $gameInputWord = $$value));
    	validate_store(nofi, 'nofi');
    	component_subscribe($$self, nofi, $$value => $$invalidate(1, $nofi = $$value));
    	validate_store(stepGame, 'stepGame');
    	component_subscribe($$self, stepGame, $$value => $$invalidate(2, $stepGame = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('ContainGame', slots, []);

    	onMount(() => {
    		onWhom.subscribe(value => {
    			if (value == 'ai') {
    				console.log("close");
    				document.getElementById('done').disabled = true;
    				document.getElementById('textIn').disabled = true;
    				document.getElementById('done').style.opacity = '0.5';
    				document.getElementById('textIn').style.opacity = '0.5';
    			} else {
    				console.log("open");
    				document.getElementById('done').disabled = false;
    				document.getElementById('textIn').disabled = false;
    				document.getElementById('done').style.opacity = '1';
    				document.getElementById('textIn').style.opacity = '1';
    			}
    		});
    	});

    	function Done() {
    		set_store_value(onWhom, $onWhom = 'ai', $onWhom);
    		set_store_value(searchDicTF, $searchDicTF = false, $searchDicTF);
    		set_store_value(gameInputWord, $gameInputWord = document.getElementById('textIn').value, $gameInputWord);
    		document.getElementById('textIn').value = '';

    		let noi = [
    			"Verifying what you've said.",
    			"Confirming your statement.",
    			"Validating your words.",
    			"Double-checking what you've mentioned.",
    			"Ensuring the accuracy of your words.",
    			"Investigating your claim.",
    			"Fact-checking your statement.",
    			"Cross-referencing your words.",
    			"Examining what you've said.",
    			"Making sure of your word."
    		];

    		set_store_value(nofi, $nofi = noi[Math.floor(Math.random() * (noi.length - 1))], $nofi);
    		var link = 'https://api.dictionaryapi.dev/api/v2/entries/en/' + `${$gameInputWord}`;

    		fetch(link).then(res => {
    			if (res.ok) {
    				//nofi
    				let noi = [
    					"Impressive choice of words, my friend.",
    					"You've got a way with words, my friend.",
    					"Well said, my friend.",
    					"Great expression, buddy.",
    					"You've articulated that well, mate.",
    					"Nice phrasing, my friend.",
    					"You've chosen your words well, buddy.",
    					"That's a commendable choice of words, my friend.",
    					"You've conveyed that nicely, mate.",
    					"Well put, my friend."
    				];

    				set_store_value(nofi, $nofi = noi[Math.floor(Math.random() * (noi.length - 1))], $nofi);

    				//nofi
    				set_store_value(resultCheckWord, $resultCheckWord = true, $resultCheckWord);

    				listresEnter.update(value => {
    					value.push($gameInputWord);
    					return value;
    				});

    				TFlist.update(value => {
    					if (value[value.length - 1] == 'user') {
    						value.push('ai');
    					} else {
    						value.push('user');
    					}

    					return value;
    				});

    				set_store_value(changingUserAi, $changingUserAi = !$changingUserAi, $changingUserAi);
    				console.log("change hewre");
    			} else {
    				set_store_value(resultCheckWord, $resultCheckWord = false, $resultCheckWord);
    				set_store_value(onWhom, $onWhom = 'user', $onWhom);
    			}

    			console.log($TFlist);
    			set_store_value(searchDicTF, $searchDicTF = true, $searchDicTF);
    		});
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<ContainGame> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		onMount,
    		ContainDic,
    		SolvingGame,
    		WFboard,
    		nofi,
    		TFlist,
    		changingUserAi,
    		gameInputWord,
    		listresEnter,
    		resultCheckWord,
    		searchDicTF,
    		stepGame,
    		onWhom,
    		Done,
    		$searchDicTF,
    		$TFlist,
    		$onWhom,
    		$resultCheckWord,
    		$changingUserAi,
    		$gameInputWord,
    		$nofi,
    		$stepGame
    	});

    	return [$searchDicTF, $nofi, $stepGame, Done];
    }

    class ContainGame extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ContainGame",
    			options,
    			id: create_fragment$5.name
    		});
    	}
    }

    /* srcGame\Game.svelte generated by Svelte v3.59.2 */

    function create_fragment$4(ctx) {
    	let containgame;
    	let current;
    	containgame = new ContainGame({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(containgame.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(containgame, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(containgame.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(containgame.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(containgame, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('Game', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Game> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ ContainGame });
    	return [];
    }

    class Game extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Game",
    			options,
    			id: create_fragment$4.name
    		});
    	}
    }

    /* src\StoreWord\SaveVocaBut.svelte generated by Svelte v3.59.2 */
    const file$2 = "src\\StoreWord\\SaveVocaBut.svelte";

    function create_fragment$3(ctx) {
    	let button;
    	let t;
    	let button_style_value;
    	let button_intro;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			button = element("button");
    			t = text(/*date*/ ctx[0]);
    			attr_dev(button, "style", button_style_value = `background-color:${/*backcolor*/ ctx[1]}; color:${/*color*/ ctx[2]}`);
    			attr_dev(button, "class", "svelte-wfbvqv");
    			add_location(button, file$2, 19, 0, 485);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, button, anchor);
    			append_dev(button, t);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*Update*/ ctx[3], false, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*date*/ 1) set_data_dev(t, /*date*/ ctx[0]);

    			if (dirty & /*backcolor, color*/ 6 && button_style_value !== (button_style_value = `background-color:${/*backcolor*/ ctx[1]}; color:${/*color*/ ctx[2]}`)) {
    				attr_dev(button, "style", button_style_value);
    			}
    		},
    		i: function intro(local) {
    			if (!button_intro) {
    				add_render_callback(() => {
    					button_intro = create_in_transition(button, slide, { duration: 1000 });
    					button_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let $stepDay;
    	validate_store(stepDay, 'stepDay');
    	component_subscribe($$self, stepDay, $$value => $$invalidate(5, $stepDay = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SaveVocaBut', slots, []);
    	let backcolor = 'transparent';
    	let color = '#535353';
    	let { date, sort } = $$props;

    	stepDay.subscribe(value => {
    		if (value == sort) {
    			$$invalidate(1, backcolor = '#535353');
    			$$invalidate(2, color = '#eeeeee');
    		} else {
    			$$invalidate(1, backcolor = 'transparent');
    			$$invalidate(2, color = '#535353');
    		}
    	});

    	function Update() {
    		set_store_value(stepDay, $stepDay = sort, $stepDay);
    	}

    	$$self.$$.on_mount.push(function () {
    		if (date === undefined && !('date' in $$props || $$self.$$.bound[$$self.$$.props['date']])) {
    			console.warn("<SaveVocaBut> was created without expected prop 'date'");
    		}

    		if (sort === undefined && !('sort' in $$props || $$self.$$.bound[$$self.$$.props['sort']])) {
    			console.warn("<SaveVocaBut> was created without expected prop 'sort'");
    		}
    	});

    	const writable_props = ['date', 'sort'];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<SaveVocaBut> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ('date' in $$props) $$invalidate(0, date = $$props.date);
    		if ('sort' in $$props) $$invalidate(4, sort = $$props.sort);
    	};

    	$$self.$capture_state = () => ({
    		stepDay,
    		slide,
    		backcolor,
    		color,
    		date,
    		sort,
    		Update,
    		$stepDay
    	});

    	$$self.$inject_state = $$props => {
    		if ('backcolor' in $$props) $$invalidate(1, backcolor = $$props.backcolor);
    		if ('color' in $$props) $$invalidate(2, color = $$props.color);
    		if ('date' in $$props) $$invalidate(0, date = $$props.date);
    		if ('sort' in $$props) $$invalidate(4, sort = $$props.sort);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [date, backcolor, color, Update, sort];
    }

    class SaveVocaBut extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { date: 0, sort: 4 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SaveVocaBut",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get date() {
    		throw new Error("<SaveVocaBut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set date(value) {
    		throw new Error("<SaveVocaBut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get sort() {
    		throw new Error("<SaveVocaBut>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set sort(value) {
    		throw new Error("<SaveVocaBut>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\StoreWord\SaveVocaBoard.svelte generated by Svelte v3.59.2 */

    const { console: console_1 } = globals;
    const file$1 = "src\\StoreWord\\SaveVocaBoard.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	return child_ctx;
    }

    // (20:12) {#each voca as item}
    function create_each_block$1(ctx) {
    	let div2;
    	let div0;
    	let t0_value = /*item*/ ctx[2].word + "";
    	let t0;
    	let t1;
    	let div1;
    	let t2_value = /*item*/ ctx[2].definition + "";
    	let t2;
    	let t3;
    	let div2_intro;

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			t0 = text(t0_value);
    			t1 = space();
    			div1 = element("div");
    			t2 = text(t2_value);
    			t3 = space();
    			attr_dev(div0, "class", "woclau svelte-1itmf5m");
    			add_location(div0, file$1, 21, 20, 674);
    			attr_dev(div1, "class", "soclau svelte-1itmf5m");
    			add_location(div1, file$1, 22, 20, 735);
    			attr_dev(div2, "class", "containWord svelte-1itmf5m");
    			add_location(div2, file$1, 20, 16, 616);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, t0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div1, t2);
    			append_dev(div2, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*voca*/ 1 && t0_value !== (t0_value = /*item*/ ctx[2].word + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*voca*/ 1 && t2_value !== (t2_value = /*item*/ ctx[2].definition + "")) set_data_dev(t2, t2_value);
    		},
    		i: function intro(local) {
    			if (!div2_intro) {
    				add_render_callback(() => {
    					div2_intro = create_in_transition(div2, slide, {});
    					div2_intro.start();
    				});
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(20:12) {#each voca as item}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div5;
    	let div2;
    	let div0;
    	let t1;
    	let div1;
    	let t3;
    	let div4;
    	let div3;
    	let each_value = /*voca*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div2 = element("div");
    			div0 = element("div");
    			div0.textContent = "words/clauses";
    			t1 = space();
    			div1 = element("div");
    			div1.textContent = "definitions/meanings";
    			t3 = space();
    			div4 = element("div");
    			div3 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "taitle svelte-1itmf5m");
    			add_location(div0, file$1, 14, 8, 387);
    			attr_dev(div1, "class", "taitle svelte-1itmf5m");
    			add_location(div1, file$1, 15, 8, 438);
    			attr_dev(div2, "id", "containTitle");
    			attr_dev(div2, "class", "svelte-1itmf5m");
    			add_location(div2, file$1, 13, 4, 352);
    			attr_dev(div3, "id", "containSave");
    			attr_dev(div3, "class", "svelte-1itmf5m");
    			add_location(div3, file$1, 18, 8, 540);
    			attr_dev(div4, "id", "containContent");
    			attr_dev(div4, "class", "svelte-1itmf5m");
    			add_location(div4, file$1, 17, 4, 504);
    			attr_dev(div5, "id", "ContainerSaveVoca");
    			attr_dev(div5, "class", "svelte-1itmf5m");
    			add_location(div5, file$1, 12, 0, 316);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div2);
    			append_dev(div2, div0);
    			append_dev(div2, t1);
    			append_dev(div2, div1);
    			append_dev(div5, t3);
    			append_dev(div5, div4);
    			append_dev(div4, div3);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div3, null);
    				}
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*voca*/ 1) {
    				each_value = /*voca*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div3, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: function intro(local) {
    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}
    		},
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let $stepDay;
    	validate_store(stepDay, 'stepDay');
    	component_subscribe($$self, stepDay, $$value => $$invalidate(1, $stepDay = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('SaveVocaBoard', slots, []);
    	let voca = [];

    	onMount(() => {
    		$$invalidate(0, voca = JSON.parse(localStorage.getItem('vocabulary'))[$stepDay].content);
    		console.log(voca);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<SaveVocaBoard> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ stepDay, onMount, slide, voca, $stepDay });

    	$$self.$inject_state = $$props => {
    		if ('voca' in $$props) $$invalidate(0, voca = $$props.voca);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [voca];
    }

    class SaveVocaBoard extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SaveVocaBoard",
    			options,
    			id: create_fragment$2.name
    		});
    	}
    }

    /* src\StoreWord\StoreWord.svelte generated by Svelte v3.59.2 */
    const file = "src\\StoreWord\\StoreWord.svelte";

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[2] = list[i];
    	child_ctx[4] = i;
    	return child_ctx;
    }

    // (11:2) {#each ListVoca as items,i}
    function create_each_block(ctx) {
    	let savevocabut;
    	let current;

    	savevocabut = new SaveVocaBut({
    			props: {
    				date: /*items*/ ctx[2].day,
    				sort: /*i*/ ctx[4]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(savevocabut.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(savevocabut, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(savevocabut.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(savevocabut.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(savevocabut, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(11:2) {#each ListVoca as items,i}",
    		ctx
    	});

    	return block;
    }

    // (15:0) {#key $stepDay}
    function create_key_block(ctx) {
    	let savevocaboard;
    	let current;
    	savevocaboard = new SaveVocaBoard({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(savevocaboard.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(savevocaboard, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(savevocaboard.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(savevocaboard.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(savevocaboard, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_key_block.name,
    		type: "key",
    		source: "(15:0) {#key $stepDay}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$1(ctx) {
    	let div1;
    	let div0;
    	let t;
    	let previous_key = /*$stepDay*/ ctx[0];
    	let current;
    	let each_value = /*ListVoca*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let key_block = create_key_block(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t = space();
    			key_block.c();
    			attr_dev(div0, "id", "conListDay");
    			attr_dev(div0, "class", "svelte-1whwwzm");
    			add_location(div0, file, 9, 0, 284);
    			attr_dev(div1, "id", "containall");
    			attr_dev(div1, "class", "svelte-1whwwzm");
    			add_location(div1, file, 8, 0, 259);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				if (each_blocks[i]) {
    					each_blocks[i].m(div0, null);
    				}
    			}

    			append_dev(div1, t);
    			key_block.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*ListVoca*/ 2) {
    				each_value = /*ListVoca*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(div0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*$stepDay*/ 1 && safe_not_equal(previous_key, previous_key = /*$stepDay*/ ctx[0])) {
    				group_outros();
    				transition_out(key_block, 1, 1, noop);
    				check_outros();
    				key_block = create_key_block(ctx);
    				key_block.c();
    				transition_in(key_block, 1);
    				key_block.m(div1, null);
    			} else {
    				key_block.p(ctx, dirty);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(key_block);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(key_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_each(each_blocks, detaching);
    			key_block.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let $stepDay;
    	validate_store(stepDay, 'stepDay');
    	component_subscribe($$self, stepDay, $$value => $$invalidate(0, $stepDay = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('StoreWord', slots, []);
    	set_store_value(stepDay, $stepDay = 0, $stepDay);
    	let ListVoca = JSON.parse(localStorage.getItem('vocabulary'));
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<StoreWord> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		SaveVocaBut,
    		SaveVocaBoard,
    		stepDay,
    		ListVoca,
    		$stepDay
    	});

    	$$self.$inject_state = $$props => {
    		if ('ListVoca' in $$props) $$invalidate(1, ListVoca = $$props.ListVoca);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [$stepDay, ListVoca];
    }

    class StoreWord extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "StoreWord",
    			options,
    			id: create_fragment$1.name
    		});
    	}
    }

    /* src\App.svelte generated by Svelte v3.59.2 */

    function create_fragment(ctx) {
    	let router;
    	let current;

    	router = new Router({
    			props: {
    				routes: {
    					'/': HomeMain,
    					'/reading': Reading,
    					'/listening': Listening,
    					'/reviving': Reviving,
    					'/game': Game,
    					'/store': StoreWord
    				}
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(router.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(router, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(router.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(router.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(router, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots('App', slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Router,
    		HomeMain,
    		Reading,
    		Listening,
    		Reviving,
    		Game,
    		StoreWord
    	});

    	return [];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment.name
    		});
    	}
    }

    const app = new App({
    	target: document.body
    });

    return app;

})();
//# sourceMappingURL=bundle.js.map
